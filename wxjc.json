{"title": "uni-app微信小程序开发之引入腾讯视频小程序播放插件 ", "author": "Rolan", "pub_time": "2019-12-17 00:01", "content": "目录导航：登录微信小程序管理后台添加腾讯视频播放插件： 在uni-app中引入插件代码：指定整个小程序可使用：指定到对应的分包中使用：在pages.json全局配置文件中对要使用插件的页面配置如下条件编译代码：　　 在.vue页面中使用腾讯视频播放组件：关于如何获取腾讯视频vid问题： 参考资料：腾讯视频小程序播放插件开发文档：decloud uni-app相关配置：微信小程序特有配置: 文章正文：回到顶部登录微信小程序管理后台添加腾讯视频播放插件：　　正式开始使用腾讯视频小程序插件之前需先在微信公众平台 -> 第三方设置 -> 插件管理处添加插件，如下图所示：回到顶部 在uni-app中引入插件代码：　　注意在使用uni-app开发微信小程序时与直接会用微信网页开发工具开发微信小程序是有很大的差别的，因为uni-app可开发多平台的原因，因此不同平台的开发相应的配置需要放到指定的位置才能够生效。而uni-app引入腾讯视频小程序有两种方式一种是整个小程序可使用（小程序中所有的分包可以使用），第二种是指定对应的分包可使用。指定整个小程序可使用：使用插件之前需要在manifest.json中的mp-weixin内声明使用的插件，具体配置参照所用插件的开发文档：1234567891011\"mp-weixin\": {        /* 小程序相关配置 */        \"usingComponents\": true,//是否启用自定义组件模式        \"appid\": \"小程序AppID\",        \"plugins\": {            \"tencentvideo\": {                \"version\": \"1.3.6\",                \"provider\": \"腾讯视频小程序AppID\"            }        }    }指定到对应的分包中使用：如果插件只在（同一个插件不能被多个分包同时引用）一个分包用到，可以单独配置到分包中，这样插件不会随主包加载，可以在pages.json的subPackages中声明插件：1234567891011121314151617{  \"subpackages\": [    {      \"root\": \"package1\",//分包名称      \"pages\": [        \"pages/cat\",        \"pages/dog\"      ],      \"plugins\": {        \"tencentvideo\": {          \"version\": \"1.3.6\",          \"provider\": \"腾讯视频小程序AppID\"        }      }    }  ]}　　回到顶部在pages.json全局配置文件中对要使用插件的页面配置如下条件编译代码：　　12345\"usingComponents\": {    // #ifdef  MP-WEIXIN       \"txv-video\": \"plugin://tencentvideo/video\"    // #endif},回到顶部 在.vue页面中使用腾讯视频播放组件：123456789101112131415<view>           <!--vid中的腾讯视频id最好为动态的数据，方便管理-->          <txv-video :vid=\"VideoId\" playerid=\"txv1\"></txv-video></view>  <script>export default {    data() {        return {            VideoId:'c3029q7tdnp'        };    }}</script>　　　回到顶部关于如何获取腾讯视频vid问题：打开网页腾讯视频=>随便找到一个视频点击鼠标右键=>赋值链接地址（仅供参考）如下图所示：  最后取视频连接地址.html前面的那一小串英文数字编号即可，下图所示：回到顶部 参考资料：腾讯视频小程序播放插件开发文档：https://mp.weixin.qq.com/wxopen/plugindevdoc?appid=wxa75efa648b60994b&token=&lang=zh_CNdecloud uni-app相关配置：https://uniapp.dcloud.io/component/mp-weixin-plugin微信小程序特有配置:https://uniapp.dcloud.io/collocation/manifest?id=mp-weixin"}
{"title": "微信小程序canvas生成海报 文字自动换行 canvas高度动态设置 ", "author": "Rolan", "pub_time": "2020-1-2 00:24", "content": "在微信小程序中分享，官网只提供分享给好友和群聊的能力，未提供分享到朋友圈的api。因此小程序分享到朋友圈通常做法就是利用canvas生成一张动态海报，上面贴一个小程序码图片，分享到朋友圈，长按识别小程序码进入小程序，以达到在朋友圈推广小程序的功能。初始化canvas1.在.wxml中 创建一个canvas, canvasWidth 和 canvasWidth 分别为创建的canvas的宽高。比如我们需要保存的海报尺寸为750px * 1350px; 我们就可以设置canvasWidth = 750；canvasWidth = 1350；这样导出来的图片比较清晰。<view class=\"canvas-box\">\r\n    <canvas canvas-id=\"canvas\" class=\"canvas\" style=\"width: {{canvasWidth}}px; height: {{canvasHeight}}px;\"></canvas>\r\n<view>2.在小程序中canvas层级最高。因此我们需要隐藏canvas,在窗口中不可见。.canvas-box{  \r\n  position: fixed;  \r\n  top: 1000px;  \r\n  left: 1000px;  \r\n  z-index: -10;  \r\n}在js中获得canvas上下文const ctx = wx.createCanvasContext('canvas'); // canvas-id绘制图片小程序绘制图片的api比较简单，一般可直接使用下面的方式const img = '/assets/images/bg.png';\r\nconst imgX = 0;      // 绘制图片在canvas中起点X坐标\r\nconst imgY = 0;      // 绘制图片在canvas中起点Y坐标\r\nconst imgWidth = 0;  // 绘制图片在canvas中宽度\r\nconst imgHeight = 0; // 绘制图片在canvas中高度\r\nctx.drawImage(img, imgX, imgY, canvasWidth, canvasHeight);本地图片小程序绘制本地图片可直接使用，例如上面的 /assets/images/bg.png' 可直接绘制到canvas上面。网络图片小程序不能直接绘制网络图片到canvas中。1.需要通过 wx.getImageInfo 获取图片信息或 wx.downloadFile 下载到本地。2.获取图片信息。网络图片需先配置download域名才能生效。如果需要绘制微信用户头像，也需要将腾讯的域名加入到白名单。这里使用wx.getImageInfo，在页面初始化的时候就请求所有需要绘制到canvas的网络图片.const localImgInfo = {}; // 存储所有网络图片请求到本地的对象\r\nconst imgList = [  \r\n  img1,\r\n  avatar,\r\n];  \r\nimgList.forEach((item, index) => {  \r\n  wx.getImageInfo({  \r\n    src: item,  \r\n  success: function (res) {  \r\n      // 保存到本地数组  \r\n  localImgInfo[item] = res.path;  \r\n  }  \r\n  })  \r\n})\r\n\r\n... (确保网络图片加载完毕后)绘制网络图片\r\n\r\nctx.drawImage(localImgInfo[avatar], imgX, imgY, canvasWidth, canvasHeight);绘制文字ctx.setFontSize(30);          // 文本字体大小\r\nctx.setFillStyle(\"#E1E6F0\");  // 颜色\r\nconst text = '我是文字';\r\nconst textX = 0;  \r\nconst textY = 0;\r\n\r\nctx.fillText(text, textStartX, textY);绘制文字和图片有一个小区别需要注意一下，起始的x,y坐标不一致。绘制图片的x,y坐标是从图片的 左上角 开始计算位置的。绘制文字的x,y坐标是从文字的 右下角 开始计算位置的。文字自动换行ctx.measureText() 能够获取canvas中文字的宽度，可通过此方法手动给文字换行// 将文字绘制到行 长文本自动换行 并返回行数  \r\n/\\*  \r\n\\* params  \r\n\\* @text 需要绘制的文本字符  \r\n\\* @startX 第一行文本的起始X坐标  \r\n\\* @startY 第一行文本的起始Y坐标  \r\n\\* @lineHeight 文本行高  \r\n\\* @MAX\\_WIDTH 单行文字最大宽度，超过临界值自动换行  \r\n\\*  \r\n\\* return rowLength 返回绘制文本的行数  \r\n\\* \\*/\r\nfunction drawText(text, startX, startY, lineHeight, MAX\\_WIDTH) {  \r\n  let allAtr \\= text.split('');  \r\n  let rowArr \\= \\[\\]; // 拆分出来的每一行  \r\n  let rowStrArr \\= \\[\\]; // 每一行的文字数组  \r\n  for (let i \\= 0; i < allAtr.length; i++) {  \r\n    const currentStr \\= allAtr\\[i\\];  \r\n  rowStrArr.push(currentStr);  \r\n  const rowStr \\= rowStrArr.join('');  \r\n  if (ctx.measureText(rowStr).width \\> MAX\\_WIDTH) {  \r\n      rowStrArr.pop(); // 删除最后一个  \r\n  rowArr.push(rowStrArr.join('')); // 完成一行  \r\n  rowStrArr \\= \\[currentStr\\];  \r\n  continue;  \r\n  }  \r\n    // 最后一个字母 直接添加到一行  \r\n  if (i \\=== allAtr.length \\- 1) {  \r\n      rowArr.push(rowStr); // 完成一行  \r\n  }  \r\n  }  \r\n  \r\n  for (let i \\= 0; i < rowArr.length; i++) {  \r\n    ctx.fillText(rowArr\\[i\\], startX, startY \\+ i \\* lineHeight);  \r\n  }  \r\n  return rowArr.length;  \r\n}drawText() 函数主要的作用就是绘制传入的文本，使用 ctx.measureText() 判断单行文字的宽度是否超过单行最大宽度，如果超过就将ctx绘制文本的startY坐标设置为当前startY+文本行高，实现切换到下一行的效果canvas高度动态设置由于项目中生成的海报图片高度随内容变化，导致不同的内容生成的海报高度不一致，所以这边只需要将canvas的高度放在data中，然后根据不同的内容动态计算最终海报的高度，然后设置data中canvas的高度即刻。下面是项目中的实际效果，在这里，海报由三个部分组成，头部，内容，底部。其中头部和底部高度固定，中间的内容高度由后台返回的书籍数量决定，其中可能需要换行的就是书籍的名称和副标题。这里简单的将每一本书作为一块区域，高度固定，因此 内容区域的高度 = 书籍数量 * 书籍高度，通过此方法简单计算出中间内容区的高度，然后动态设置canvas的高度。源码https://github.com/zhaosheng808/canvasPoster提供简单的微信小程序测试号demo，包含请求用户保存canvas图片的授权逻辑。测试号需要将不校验合法域名打开，不然无法下微信头像和外部图片。正式号需要在微信公众平台配置下载域名"}
{"title": "微信小程序长按保存图片 ", "author": "Rolan", "pub_time": "2020-1-2 00:43", "content": "微信浏览器打开h5页面如果是img标签的话，长按会弹出保存图片的选项。但是微信小程序里面不可以，需要自己写这个功能。这个功能有两个点，一个是长按，一个是保存图片到本地。1. 微信小程序关于图片长按的解释，有两种：因此我们选用 bindlongpress 事件2. 微信小程序同样提供了保存图片的接口，是wx.saveImageToPhotosAlbum()3. 值得说的是，保存的接口，两个需要注意的地方：1、需要先授权，调用 wx.getSetting()方法2、保存的图片路径参数，不支持网络路径，而在我们渲染页面时，用到的图片有很大可能是网络路径，这时候我们需要先把网络路径转为可用的本地路径，wx.getImageInfo()方法可以满足需要4. 最后再走个心吧，毕竟我这么可爱1、长按后直接保存未免潦草了些，考虑到用户体验，加入 wx.showActionSheet()2、如果用户拒绝授权 或者 以前拒绝过授权，这时候也应该给他提示，或者展示再次打开授权的入口将将！然后就可以开始写代码了：<image src=\"{{url}}\" data-url=\"{{url}}\" bindlongpress=\"saveImage\"></image>// 长按保存功能--授权部分\r\nsaveImage (e) {\r\n    let _this = this\r\n    wx.showActionSheet({\r\n        itemList: ['保存到相册'],\r\n        success(res) {\r\n            let url = e.currentTarget.dataset.url;\r\n            wx.getSetting({\r\n                success: (res) => {\r\n                    if (!res.authSetting['scope.writePhotosAlbum']) {\r\n                        wx.authorize({\r\n                            scope: 'scope.writePhotosAlbum',\r\n                            success: () => {\r\n                                // 同意授权\r\n                                _this.saveImgInner(url);\r\n                            },\r\n                            fail: (res) => {\r\n                                console.log(res);\r\n                                wx.showModal({\r\n                                    title: '保存失败',\r\n                                    content: '请开启访问手机相册权限',\r\n                                    success(res) {\r\n                                        wx.openSetting()\r\n                                    }\r\n                                })\r\n                            }\r\n                        })\r\n                    } else {\r\n                        // 已经授权了\r\n                        _this.saveImgInner(url);\r\n                    }\r\n                },\r\n                fail: (res) => {\r\n                    console.log(res);\r\n                }\r\n            })   \r\n        },\r\n        fail(res) {\r\n            console.log(res.errMsg)\r\n        }\r\n    })\r\n},\r\n// 长按保存功能--保存部分\r\nsaveImgInner (url) {\r\n    wx.getImageInfo({\r\n        src: url,\r\n        success: (res) => {\r\n            let path = res.path;\r\n            wx.saveImageToPhotosAlbum({\r\n                filePath: path,\r\n                success: (res) => {\r\n                    console.log(res);\r\n                    wx.showToast({\r\n                        title: '已保存到相册',\r\n                    })\r\n                },\r\n                fail: (res) => {\r\n                    console.log(res);\r\n                }\r\n            })\r\n        },\r\n        fail: (res) => {\r\n            console.log(res);\r\n        }\r\n    })\r\n},文章写的比较正序，参考的是这篇倒序文章，喜欢倒序的筒子们可以去看下这篇： https://www.jianshu.com/p/e59...（虽然很痛恨没有视频效果的文章，可是录好了视频的我 实在找不到上传视频的按钮！我好难！！！）"}
{"title": "小程序wifi能力解读与实践 ", "author": "Rolan", "pub_time": "2020-1-3 00:28", "content": "背景\r\n小程序wifi系列接口为系统原生能力。早在2015年，微信就推出了「微信连Wi-Fi」，微信连Wi-Fi是为商家的线下场所提供一套完整和便捷的微信连Wi-Fi的方案。现在已经是一套完整的，便捷的解决方案。顾客通过扫码的方式连接wifi，同时微信还可以向用户下发消息。方案在官方文档已经阐述得很详细，本文就不再赘述。本文重点在于讲解小程序中使用wifi能力遇到的问题和心得。\r\n【微信连wifi】传送门\r\nwifi能力解读\r\nwifi能力简介\r\n在小程序中，使用wifi模块都需要先调用wx.startWifi()来初始化wifi模块。以下能力的使用均需要在wx.startWifi的success回调中使用。\r\n连接wifi\r\nwx.connectWifi({\r\n    SSID: 'mx 的iphone', // Wi-Fi 设备 SSID\r\n    BSSID: '', // Wi-Fi 设备 BSSID\r\n    password: 'xxxxxxxx',\r\n    success(){},\r\n    fail(){},\r\n    complete(){}\r\n})\r\n复制代码connectWifi为我们提供了直连wifi的能力， 仅 Android 与 iOS 11 以上版本支持，需要基础库1.6.0以上。这个一般是我们使用wifi功能的核心API了。在ios中，会出现系统弹框，询问用户是否要连接wifi，只有用户点击确定，connectWifi才会继续进行，否则就走fail回调了。在安卓（以小米note3为例，Anroid9）中则会出现微信连一连的toast。\r\n获取当前已经连接的wifi\r\nwx.getConnectedWifi({\r\n    success(WifiInfo){\r\n        // WifiInfo\r\n    }\r\n})\r\n复制代码从社区中获取的信息得知：signalStrength表示信号强度，iOS 是系统返回的，取值 0-1，安卓经过转换，取值 0-100。数值与信号强度为正比例关系。\r\n获取wifi列表\r\nwx.getWifiList({\r\n    success(e) {\r\n        wx.onGetWifiList((res) {\r\n            // res.wifiList:wifiInfo[]\r\n        })\r\n    }\r\n})\r\n复制代码获取周围的wifi列表，需要先使用getWifiList后使用onGetWifiList进行监听。在ios中，getWifiList会跳到ios系统界面，这是由于ios系统的限制， 目前是无法避免的（其实这么做也无可厚非，wifi信息本来就是敏感的，但是对用户体验有一定的影响）。在安卓中，getWifiList需要获取用户的位置信息，因为可以利用小程序嗅探周边Wi-Fi热点来推断用户所在的位置信息。为了确保用户的隐私不受侵犯，自微信android客户端 7.0.4 起，需要先获取用户地理位置（scope.userLocation）。详情请见wx.getWifiList接口需获取用户位置信息授权后使用\r\n设置AP相关信息\r\nwx.onGetWifiList(function(res) {\r\n    wx.setWifiList({\r\n      wifiList: [{\r\n        SSID: res.wifiList[0].SSID,\r\n        BSSID: res.wifiList[0].BSSID,\r\n        password: '123456'\r\n      }]\r\n    })\r\n})\r\n复制代码\r\n这个接口也挺牛逼，ios特有的。通过设置wifiList，我们在系统页可以直接看到已设置的wifi列表，点了就直接连上了。\r\n其他\r\n\r\nwx.stopWifi 关闭wifi模块\r\nwx.onWifiConnected(function callback)监听连接上 Wi-Fi 的事件\r\nwx.offWifiConnected 取消监听连接上 Wi-Fi 的事件\r\nwx.offGetWifiList(function callback) 取消监听获取到 Wi-Fi 列表数据事件。\r\n\r\n安卓连接wifi\r\n连接指定 Wi-Fi 接口调用时序：\r\nAndroid：startWifi —> connectWifi —> onWifiConnected\r\n复制代码连周边 Wi-Fi 接口调用时序：\r\nAndroid：startWifi —> getWifiList —> onGetWifiList —> connectWifi —> onWifiConnected\r\n复制代码IOS连接wifi\r\n连接指定 Wi-Fi 接口调用时序：(与安卓一致)\r\niOS（仅iOS 11及以上版本支持）：startWifi —> connectWifi —> onWifiConnected\r\n复制代码连周边 Wi-Fi 接口调用时序：\r\niOS（iOS 11.0及11.1版本因系统原因暂不支持）：\r\nstartWifi —> getWifiList —> onGetWifiList —> setWifiList —> onWifiConnected\r\n复制代码实践\r\n笔者在项目中接触到了使用小程序提供的硬件（wifi）能力的场景。利用wifi与socket的能力，我们可以为物联网设备连接wifi。流程如下:\r\n\r\n刚好在开发者社区找到类似的代码片段：\r\n\r\n小程序跟设备数据传输(websocket);\r\n小程序跟设备数据传输(udpsocket);\r\n\r\n\r\nwx.request/wx.connectSocket/wx.uploadFile/wx.downloadFile 的 url 参数允许为 {PORT}/${PATH} 的格式，当且仅当 IP 与手机 IP 处在同一网段且不与本机 IP 相同（一般来说，就是同一局域网，如连接在同一个 wifi 下）时，请求/连接才会成功。\r\n在这种情况下，不会进行安全域的校验，不要求必须使用 https/wss，也可以使用 http/ws。\r\n\r\n局域网通信中，不会进行安全域校验，因此，无需在mp后台添加安全域域名。\r\n总结\r\n借助小程序提供的硬件能力(wifi,蓝牙，NFC)，小程序有了更加广阔的场景。比如【摩拜单车】小程序，有的车需要用户开一下蓝牙，小程序提供的操作原生系统的蓝牙功能便为我们赋能。通过小程序，我们也可以实现与物联网设备通信，通过连接设备热点，利用http/wss/udp传输数据。当然，现在wifi能力还是存在着问题，比如兼容问题，可能有部分安卓手机在连接时会莫名其妙的报错。此时需要对着官方提供的errcode查看具体的原因。\r\n踩过的坑\r\n\r\n安卓部分机型，已经连接wifi，使用connectWifi重新连接，即使传错密码，还是能连上。\r\nA：这个问题目前还没有解决的办法。\r\nios在getWifiList会跳到系统设置页，在connectWifi会出现modal确认是否连接。\r\nA：无法避免。ios系统的限制\r\n调试wifi功能时，无法在开发者工具中调试wifi能力。\r\nA: 目前开发者工具无法进行模拟。并且真机调试时，连接设备热点后会报错。（毕竟真机调试时需要能够访问网络，一般设备热点都不具备访问网络的能力）。目前可以通过 预览+ vconsole解决，还是比较麻烦。\r\n可以主动断开wifi吗？\r\nA: 从文档上看，没有提供这个能力。但是可以尝试连接一个不存在的wifi。\r\n来自文档的注意事项：\r\n\r\n\r\nReference\r\n\r\n微信开放文档 - wifi\r\n微信开放文档 - 局域网通信\r\n小程序WIFI接口和WebSocket创建局域网数据通讯"}
{"title": "探索小程序实现 ", "author": "Rolan", "pub_time": "2020-1-6 00:15", "content": "随着小程序的发展与功能的逐步完善，越来越多的产品需要小程序与 APP 的功能能有一些共性，社区跨平台的解决方案越来越多，比如 taro 等为代表的把一套代码编译成多端运行的机制，本文会使用 Swift 作为原生语言，在 iOS 应用上运行一个小程序 Demo， 使用 Android && React Native 也可以采用同样的思路实现。相关代码仓库： https://github.com/taixw2/rmini编译层编译的目的是为了抹平小程序的与 H5 的差异，利用 Vue 实现数据绑定，利用 Web Component 实现小程序的组件功能。从官网文档中可以看出来，运行一个小程序需要框架（数据绑定渲染）、组件（小程序渲染单元）、api（与原始交互的能力）。框架实现转换成单页应用（一种可行的方案）把所有页面打包成一个 js， 再由 js 管理所有的路由和状态，这种方案适合在 web 端运行，并且是单引擎的方案，在模拟原生的右滑返回等效果也会不尽人意。转换成多页面众所周知，小程序是一个双引擎的框架，上面的方案显然不能达到要求, 双引擎的特点是在运行 javascript 的黑盒子中，无法访问到 DOM && BOM 等。将所有的逻辑代码在原生的 JavascriptCore 中运行，WebView 中的 Javascript 引擎负责数据绑定，需要解决的难点是 JavascriptCore 中的 setData 怎么通知 WebView 渲染， WebView 的事件怎么执行 JavascriptCore，接着往下看。抹平WXMLwxml 是一种类 html 标记语言，他负责所有的渲染规则，包括条件渲染、列表渲染、数据绑定等，与其再实现一种框架，还不如直接利用 Vue 实现同样的功能，再利用各种转换库将 wxml 中的事件转换成 Vue 能够识别的事件，如利用 post-html 可以做到如下的转换:每一个事件绑定的方法全都在原生的 JSContext 中运行，所以此时的事件只需要传递给 JSContext 的作用。抹平WXSSwxss 作为小程序的样式语言，其余 css 的主要区别就是多了一个 rpx 单位，以下是官网的换算表：根据上表可得知， rpx = (750 / 屏幕宽度) * px ;在传统的移动端页面，我们的高清方案，一般需要获取 dpr， 然后修改动态修改 viewport 和 html 上的 font-size，但是小程序的代码因为是放在了设备本地，所以可以在下载小程序页面之后，我们还有一次编译机会，这时就可以把 rpx 根据当前设备的屏幕宽度替换成对应的 px。还有一个 @import ，则利用 scss 或 less 就可以合并到同一个 css 文件中,而全局样式则可以在构建 WXML 的时候再植入进入抹平组件组件具有独特的功能和自己的渲染规则，比如 scroll-view 具有 scroll-x 和 scroll-y 等属性控制滚动条。在 HTML5 中有一个重大的功能 web-component ，它能够自定义 html 元素，并且能够监控属性的变化，非常适合实现小程序组件。如：（使用了 lit-element 框架）这里用了 lit-element 这个框架，能够简化一些操作。抹平 Page 和 AppApp 负责整个应用的生命周期以及存一些全局的数据， getApp 能获取到 app 的信息。 所以类似的结构可能是这样的：getApp 能够直接访问到内部对象，并且在最顶层声明，这样每一个的地方都能访问到 getApp。初始化一个页面都需要是实例化 PageClass, 即使再次进入（不是返回到这个页面）这个页面页需要再次重新实例化，每次实例化都需要关联一个 webviewId, 这个 ID 与原始的 webview 关联，这样每个 PageClass 中的 setData 都能找到对应的 webview 进行再次渲染，所以对应的代码可能是这样的：抹平 API通过 API 能够直接调用原生的功能，比如 wx.request ， 如果直接在 webview 中的 JSContext 中运行的话，则可能存在跨域，但是放在原生就不会存在这个问题。实现JSContext 调用原生代码的功能，需要给 JSContext 中植入一个 JSBridge，如： JSBridge.invoke 和 JSBridge.on , invoke 负责同步任务，on 负责异步任务，原生再利用反射（原生的反射真麻烦）调用对应的原生方法，原生可以利用 while(true) 挂起 JSContext，既可以达到同步和异步的方法。打包 JavascriptJavascript 代码打包后被放在 JavascriptCore 中运行，唯一与 Webview 中的 JSContext 打交道的只有 setData , 先看一下打包流程：利用 App.json 构建入口文件利用 rollup 等工具将所有 Javascript 打包成一个文件（目前没有分包）打包流程及其简单，接下来看一下两个 Javascript 引擎的交互过程。打通 JSContext 到 WebView JavascriptCore每次进入一个页面的时候都需要为这个页面的 webview 分配一个 id, 这个 id 至关重要，作为 native 与 JSContext (原生运行 javascript 的上下文对象) 与 webview 交互的唯一标识，JSContext 中需要实例化一个新的 PageClass 关联这个 id， native 中通过 id 保留 webview 的引用。在 JSContext 中植入一个 JSBridge 用于与原生交互，如： JSBridge.setData(webviewId, appId, data), 当 JSBridge 的 setData 被调用后，通过 appId + webviewId 就能找到对应的 webview, 再将 setData 传入 webview 中，在 Vue 接收到 data 后进行渲染， 整个过程如图：打通 Webview JavascriptCore 到 JSContext有了前面的铺垫，接下来再看 webview 如何调用 JSContext 的方法， Webview 唯一能与 JSContext 交互的方式只有事件，事件触发后，需要通过某种方式触发 JSContext 中的方法，最后调用 setData 再返回来重新渲染 webview。webview 中绑定的方法名众多，如： bindtap=\"a\", bindtap=\"b\", bindtap=\"c\" 等，但是可以通过 “抹平 WXML” 的时候最终只保留一个出口，如:v-on:click=\"callClick('a', $event)\" 等，这样 vue 中的 method 只需要实现对应的几个事件便可：结尾利用原生作为桥梁，在两个引擎之间通信，webview 中的 JSContext 负责接收渲染通知，以及发送事件到 Native 的 JSContext 中，JSContext 独立运行，所以既访问不到 window 对象，也访问不到 document 对象。"}
{"title": "微信小程序 接入 腾讯云验证码 ", "author": "Rolan", "pub_time": "2020-1-7 00:06", "content": "前言：最近做了一个小程序抽奖的活动，出现了部分用户恶意薅羊毛的现象，因此考虑接入腾讯云的验证码。其实腾讯的官方文档写的相当清晰： https://cloud.tencent.com/doc...不想啃文档的筒子们的就往下继续看吧~（虽然大同小异）整体效果1、小程序触发验证，跳转到验证码小程序2、在验证码小程序内通过验证，并携带参数跳回原来的小程序3、在原来的小程序内，监测携带回的参数，并作后续操作前提条件验证码接入前，需要先在 验证码控制台 中注册 AppID 和 AppSecret，注册完成后，您可以在控制台的 基础配置 中查看 AppID (下文extraData中使用) 以及 AppSecret。注意，这里的 appId 和 appSecret 和小程序后台的是不一致的！接入步骤1、在你需要的地方，唤起验证码小程序首先在 app.json 配置 navigateToMiniProgramAppIdList，如下：{\r\n  \"navigateToMiniProgramAppIdList\": [\"wx5a3a7366fd07e119\"]\r\n}这个appId是官方文档中直接提供的，搬上去就好。假设你的唤起方式是通过一个这样的按钮事件：<button bindtap=\"toTCaptcha\">验证</button>toTCaptcha: function () {\r\n    wx.navigateToMiniProgram({\r\n      appId: 'wx5a3a7366fd07e119',\r\n      path: '/pages/captcha/index',\r\n      extraData: {\r\n        appId: 'appId' //您申请的验证码的 appId\r\n      }\r\n    })\r\n  }2、在 app.js 获取验证结果由于小程序间相互跳转过程中产生的数据仅能在 app.js 中获取到，故需要在 app.js 的 onShow 中添加以下代码，来捕获验证结果 captchaResultApp({\r\n  // ...\r\n  onShow: function(options) {\r\n    // 解决各类回调的兼容问题\r\n    if (!this.captchaTicketExpire) this.captchaTicketExpire = {};\r\n\r\n    if (options.scene === 1038 && options.referrerInfo.appId === 'wx5a3a7366fd07e119') {\r\n      const result = options.referrerInfo.extraData;\r\n      if (result.ret === 0) {\r\n        const ticket = result.ticket;\r\n        if (!this.captchaTicketExpire[ticket]) {\r\n          this.captchaResult = result;\r\n          this.captchaTicketExpire[ticket] = true;\r\n        }\r\n      } else {\r\n        // 用户关闭了验证码\r\n        // 这里可以加上一些验证失败提示\r\n      }\r\n    }\r\n  },\r\n  // ...\r\n});验证结果（captchaResult） 参数说明：3、将验证结果返回至服务端校验在小程序页面的 onShow 阶段，将验证结果及待提交的表单数据一起提交到服务器，进行校验。// page.js\r\nconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    // ...\r\n  },\r\n  onShow() {\r\n    const captchaResult = app.captchaResult;\r\n    app.captchaResult = null; // 验证码的票据为一次性票据，取完需要置空\r\n    if (captchaResult && captchaResult.ret === 0) {\r\n      // 将验证码的结果返回至服务端校验，以及后续的操作\r\n      // const ticket = captchaResult.ticket;\r\n      // const randstr = captchaResult.randstr;\r\n    }\r\n  },\r\n  // ...\r\n});用一个词描述这个开发过程：搬上去！"}
{"title": "小程序跨页面交互的作用与方法 ", "author": "Rolan", "pub_time": "2020-1-7 00:24", "content": "去年年末，微信小程序的分包大小已经到达了 12M 大小,一方面说明小程序的确逐步为开发者放开更大的权限，另一方面也说明了对于某些小程序 8M 的大小已经不够用了。我个人今年也是在开发一个 to B 小程序应用。这里列举一些跨页面交互的场景。对于 B 端应用的业务需求来说，小程序开发的复杂度相对比网页开发要复杂一些。一个是双线程的处理机制问题，另一个是页面栈之间交互问题。注: 笔者目前只需要开发微信小程序，为了在小程序页面中可以使用 properties behaviors observers 等新功能，已经使用 Component 构造器来构造页面。具体可以参考\t微信小程序 Component 构造器 。如果你也没有多端开发的需求，建议尝试使用，可以得到不错的体验。性能优化类对于小程序在页面中点击触发 wx.navigateTo 跳转其他页面，中间会有一段时间的空白加载期(对于分包出去的页面，空白期则会更长)，但是这是小程序内部机制，没有办法进行优化。我们只能眼睁睁的等待这段没有意思的空白期过去。当考虑到跳转页面后的第一件事情便是取数逻辑，那么我们是否能够进行优化呢？答案是肯定的。我们没有办法直接在当前页面取得数据之后再进行跳转操作(这样操作更不好)，但是我们却可以利用缓存当前的请求，详情可以参考我之前的博客文章 ——\tPromise对象 3 种妙用 。代码如下:const promiseCache = new Map()\r\n\r\nexport function setCachePromise(key, promise) {\r\n  promiseCache.set(key, promise)\r\n}\r\n\r\nexport function getCachePromise(key) {\r\n  // 根据key获取当前的数据  \r\n  const promise = promiseCache.get(key)\r\n  // 用完删除，目前只做中转用途，也可以添加其他用途\r\n  promiseCache.delete(key)\r\n  return promise  \r\n}做一份全局的 Map,然后利用 Map 缓存 promise 对象，在跳转之前代码为:// 导入 setCachePromise 函数\r\n\r\nComponent({\r\n  methods: {\r\n    getBookData(id) {\r\n      const promise = // promise 请求\r\n        setCachePromise(`xxx:${id}`, promise)      \r\n    },  \r\n    handleBookDetailShow(e) {\r\n      const id = e.detail\r\n      this.getBookData(id)\r\n       wx.navigateTo({url: `xx/xx/x?id=${id}`})\r\n    }\r\n  }\r\n})而跳转之后的代码也如下所示:// 导入 getCachePromise 函数\r\n\r\nComponent({\r\n    properties: {\r\n      id: Number  \r\n    },\r\n    lifetimes: {\r\n      attached () {\r\n        const id = this.data.id  \r\n        // 取得全局缓存的promise\r\n        const bookPromise = getCachePromise(`xxx:${id}`)\r\n        bookPromise.then((res) => {\r\n          // 业务处理\r\n        }).catch(error => {\r\n          // 错误处理  \r\n        })\r\n      }\r\n    },\r\n    methods: {\r\n      getBook() {\r\n        // 获取数据，以便于 错误处理 上拉刷新 等操作  \r\n      }  \r\n    }\r\n})如此便可以同时处理取数和页面加载的逻辑，当然，这个对于页面有耦合性，不利于后续的删除与修改。但考虑如果仅仅加在分包跳转之间可能会有不错的效果。想要无侵入式，可以进一步学习研究\t微信小程序之提高应用速度小技巧 以及\twxpage 框架，同时考虑到无论是 ToC 还是 ToC 用户，都有可能存在硬件以及网络环境等问题，该优化还是非常值得的。当然微信小程序为了减少冷启动时间，提供了\t周期性更新 数据预拉取 功能。注: 上面的 promiseCache 只作为中转的用途，不作为缓存的用途，如果你考虑添加缓存，可以参考我之前的博客文章——\t前端 api 请求缓存方案 。通知类如果是 pc 端中进行交互，对于数据的 CRUD。例如在详情页面进行了数据的修改和删除，返回列表时候就直接调取之前存储的列表查询条件再次查询即可，而对于移动端这种下拉滚动的设计，就没有办法直接调用之前的查询条件来进行搜索。如果从列表页面进入详情页面后，在详情页面只会进行添加或者修改操作。然后返回列表页面。此时可以提示用户数据已经进行了修改，请用户自行决定是否进行刷新操作。如在编辑页面修改了数据:const app = getApp()\r\n\r\ncomponent({\r\n  methods: {\r\n    async handleSave() {\r\n      //...\r\n      app.globalData.xxxChanged = true\r\n      //...  \r\n    }\r\n  }\r\n})列表界面:const app = getApp()\r\n\r\ncomponent({\r\n  pageLifetimes: {\r\n    show() {\r\n      this.confirmThenRefresh()\r\n    }    \r\n  },\r\n  methods: {\r\n    confirmThenRefresh() {\r\n      // 检查 globalData，如果当前没有进行修改，直接返回 \r\n      if(!app.globalData.xxxChanged) return\r\n      wx.showModal({\r\n        // ...\r\n        complete: () => {\r\n          // 无论确认刷新与否，都把数据置为 false \r\n          app.globalData.xxxChanged = false  \r\n        }  \r\n      })  \r\n    }\r\n  }  \r\n})当然了，我们也可以利用 wx.setStorage 或者 getCurrentPage 获取前面的页面 setData 来进行数据通知,以便用户进行页面刷新。订阅发布类如果仅仅只涉及到修改数据的前提下，我们可以选择让用户进行刷新操作，但是如果针对于删除操作而言，如果用户选择不进行刷新，然后用户又不小心点击到了已经被删除的数据，就会发生错误。所以如果有删除的需求，我们最好在返回列表页面前就进行列表的修改，以免造成错误。mittgithub 上有很多的 pub/sub 开源库，如果没有什么特定的需求，找到代码量最少的就是\tmitt 这个库了,作者是喜欢开发微型库的\tdevelopit 大佬,著名的\tpreact 也是出于这位大佬之手。 这里就不做过多的介绍，非常简单。大家可能都能看明白，代码如下(除去 flow 工具的检查):export default function mitt(all) {\r\n  all = all || Object.create(null);\r\n\r\n  return {\r\n    on(type, handler) {\r\n      (all[type] || (all[type] = [])).push(handler);\r\n    },\r\n\r\n    off(type, handler) {\r\n      if (all[type]) {\r\n        all[type].splice(all[type].indexOf(handler) >>> 0, 1);\r\n      }\r\n    },\r\n    emit(type, evt) {\r\n      (all[type] || []).slice().map((handler) => { handler(evt); });\r\n      (all['*'] || []).slice().map((handler) => { handler(type, evt); });\r\n    }\r\n  };\r\n}仅仅只有3个方法，on emit以及 off。只要在多个页面导入 生成的 mitt() 函数生成的对象即可(或者直接放入 app.globalData 中也可)。Component({\r\n  lifetimes: {\r\n    attached: function() {\r\n      // 页面创建时执行\r\n      const changeData = (type, data) => {\r\n        // 处理传递过来的类型与数据\r\n      }\r\n      this._changed = changeData\r\n      bus.on('xxxchanged', this._changed)\r\n    },\r\n    detached: function() {\r\n      // 页面销毁时执行\r\n      bus.off('xxxchanged', this._changed)\r\n    }\r\n  }\r\n})这里mitt可以有多个页面进行绑定事件，如果需求仅仅只涉及到两个页面之间，我们就可以使用 wx.navigateTo 中的 EventChannel (页面间事件信息通道)。可以参考\t微信小程序wx.navigateTo方法里的events参数使用详情及场景 ,该方案的利好在于，传递到下一个页面的参数也可以通过 EventChannel 来通知，以便于解决 properties 传递数据不宜过大的问题。注: 一个页面展示很多信息的时候，会造成小程序页面的卡顿以及白屏。小程序官方也有长列表组件\trecycle-view 。有需求的情况下可以自行研究，这个不在这里详述。鼓励一下如果你觉得这篇文章不错，希望可以给与我一些鼓励，在我的 github 博客下帮忙 star 一下。博客地址参考文档微信小程序 Component 构造器微信小程序之提高应用速度小技巧wxpagemittPromise对象 3 种妙用前端 api 请求缓存方案"}
{"title": "从客户端角度窥探小程序架构 ", "author": "Rolan", "pub_time": "2020-1-7 00:42", "content": "小程序自诞生以来。就以一种百家争鸣的姿态展现在开发者的面前。继2017年1月9日微信小程序诞生后，小程序市场又陆续出现了支付宝小程序、头条小程序、百度智能小程序等等，甚至平安内部，也在发展自己的小程序生态。各家都在微信小程序的基础上，面向自己的业务，对架构进行逐步优化调整，但是万变不离其宗，微信小程序终归为小程序鼻祖，也是得益于微信小程序的思想，才造就了如今这百花齐放的业态。说起微信小程序，在体验上的优化，让我很长一段时间认为，这是 Native 层渲染。事实并不完全是，至今不敢相信，webView 的渲染竟能带来如此体验。本篇主要以一个客户端开发者的角度，来对微信小程序、支付宝小程序一探究竟。本篇旨在原理分析，我并未有真实的小程序架构设计经验。说到小程序，不得不需要指出另外一个问题，苹果爸爸 对于 HTML5 app 的更新 的审核问题，目前会有开发者存在这样的疑问，Hybrid 和 H5 是不是要被苹果拒审了呢？其实从更新描述来看，不难发现苹果的主要目的是针对 “核心功能未在二进制文件内” 的 App ，实际上小程序无论是在设计理念上，还是核心技术上，都不存在这样的问题，小程序并非App，小程序是以 App 为载体，尽可能的对 web 页面进行优化而生成的产物。还有一点是 马甲包 日益猖獗，马甲包最后基本都转化成为了条款内描述的 “现金Bocai、彩票抽奖和慈善捐款” 类型，所以苹果想要尽可能的禁止它。而且从微信小程序开发文档来看，微信小程序是典型的 技术推动产品的结果 。关于RN类技术，更不存在这样的问题了，RN本质为 JS 通过 JSCore 调用 Native 组件。实际上它的核心仍然在 Native 端，当然对 code push 我还尚存疑问。关于 RN 的动态更新上，从 bang's 的描述也不难发现苹果爸爸的态度， 只要不是为了绕过审核去做动态更新就可以接受 。二、从微信小程序的发展史说起微信小程序是什么，微信把小程序定义为是 一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验 。便捷和出色有何而来？小程序技术最初来源于 H5 和 Native 间的简单调用，微信构建了一个 WeixinJSBridge 来为H5提供一些 Native 的功能，例如地图、播放器、定位、拍照、预览等功能。关于 Bridge 的具体实现可以参考之前的文章 写一个易于维护使用方便性能可靠的Hybrid框架 。但是微信逐渐的又遇到了另外一个问题，那就 H5 页面的体验问题，微信团队为了解决 H5 页面的白屏问题，他们引入了最近很火的 离线包 概念，当然微信称之为 微信 Web 资源离线存储 ，实际上是一个东西。Web 开发者可借助微信提供的资源存储能力，直接从微信本地加载 Web 资源而不需要再从服务端拉取，从而减少网页的加载时间。关于离线包的概念，不了解的话可以参考下我之前的文章 iOS 性能优化 -- H5离线秒开 。但是当页面加载大量 CSS 和 JS 时，依然会有白屏问题，包括 H5 页面点击事件的迟钝感和页面跳转的体验问题。那么基于此问题，应运而生的，小程序技术就诞生了。从微信小程序的发展史，不难看出，小程序实际上是近几年开发者对 H5 体验优化而来的，这也切合了前面所说的， 小程序实际上是典型的技术推动产品的结果 。三、微信小程序原理分析微信小程序自称能够解决以下问题：快速的加载。更强大的能力。原生的体验。易用且安全的微信数据开发。高效和简单的开发。快速加载和原生的体验，这其实都是在体验上的升级，更强大能力实际上源于微信小程序为开发者提供了大量的组件，这些组件有基于web技术，也有基于Native技术，在我看来这和 RN 技术不谋而合。后面我会举一个模仿 RN 实现的小例子来阐述一下它的原理。高效和简单的开发是因为微信小程序开发语言实质上还是基于 web 开发规范，这使得开发前端的人来开发小程序显得更容易。还有一点更重要的就是安全，为什么说小程序是安全的？后面会逐步展开，揭开小程序的神秘面纱。快速加载和原生的体验小程序的架构设计与 web 技术还是有一定的差别，吸取了 web 技术的一些优势，也摒弃了 web 技术中体验不好的地方。最主要的特点就是小程序采用双线程机制，即视图渲染和业务逻辑分别运行在不同的线程中。在传统的 web 开发中，网页开发渲染线程和脚本线程是互斥的，所以 H5 页面中长时间的脚本运行可能会导致页面失去响应或者白屏，体验糟糕。为了更好的体验，将页面渲染线程和脚本线程分开执行：渲染层：界面渲染相关的逻辑全部 在webView 线程内执行，一个小程序存在多个页面，一个页面对应一个 webView，微信小程序限制开发者最多只能创建五个页面。逻辑层：Android采用 JSCore ，iOS采用的 JavaScriptCore 框架运行 JS 脚本。怎么在 JavaScriptCore 运行脚本文件后面会讲。双线程模型是小程序框架与大多数前端 web 框架的不同之处，基于这个模型可以更好的管控以及提供更安全的环境。因为逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。客户端的开发者可能对 DOM 有些陌生，了解编译过程的同学应该知道在编译器编译代码的时候，会有一个语法分析的过程，生成抽象语法树 AST，编译器会根据语法树去检查表达式是否合法、括号是否匹配等。实际上DOM也是一种树结构，经过浏览器的解析，最终呈现在用户面前。通过 JavaScript 操纵 DOM 可以随意改变元素的位置，这对于小程序来说是极为不安全的。所以说逻辑层为小程序带来的另一个特点，易于管控和安全。线程通信基于前面提到的 WeixinJSBridge ：逻辑层把数据变化通知到视图层，触发视图层页面的更新，视图层把触发的事件通知到逻辑层进行业务处理。当我们对渲染层进行事件操作后，会通过 WeixinJSBridge 将数据传递到 Native 系统层。Native 系统层决定是否要用 Native 处理，然后丢给 逻辑层进行用户的逻辑代码处理。逻辑层处理完毕后会将数据通过 WeixinJSBridge 返给 View 层，View 渲染更新视图。渲染层根据 微信小程序开发者文档 描述， 在视图层内，小程序的每一个页面都独立运行在一个页面层级上。小程序启动时仅有一个页面层级，每次调用wx.navigateTo，都会创建一个新的页面层级；相对地，wx.navigateBack会销毁一个页面层级 。大概可以理解为，每个 web 页面都是运行在单独的 webView 里面，这样的好处就是让每个 webView 单纯的处理当前页面的渲染逻辑，不需要加载其他页面的逻辑代码，减轻负担能够加速页面渲染，使其能够尽可能的接近原生，这与小程序跳转页面的体验上也是一致的。实际上在小程序源码内有一个 index.html 文件的存在，这是小程序启动后的入口文件。初次加载的时候，主入口会加载相应的 webView ，这其中就会包括前面所提到的，视图层和逻辑层。逻辑层虽然也提供了 webView ，但是并不提供浏览器相关接口，而是单纯的为了获取当前的 JSCore ，执行相关的 JS 脚本文件，这也是开发小程序是没办法直接操作 DOM 的根本原因。当我们每打开一个新页面的时候，调用 navigateTo 都相当于打开了一个新的 webView ，这样一直打开，内存也会变得吃紧，这也是为什么小程序对页面打开数量有限制的原因了。预加载根据小程序开发文档描述： 对于每一个新的页面层级，视图层都需要进行一些额外的准备工作。在小程序启动前，微信会提前准备好一个页面层级用于展示小程序的首页。除此以外，每当一个页面层级被用于渲染页面，微信都会提前开始准备一个新的页面层级，使得每次调用wx.navigateTo都能够尽快展示一个新的页面 。这在客户端的角度来看，相当于打开新页面之后，对下一个页面的 webView 提前做了预加载，这个思路与当前比较流行的 webView 缓存池的思路不谋而合，原因是在 iOS 和 Android 系统上，操作系统启动 webView 都需要一小段时间，预加载会提升页面打开速度，优化白屏问题。基础库内部优化再往深层次来看，通过小程序开发工具的源码，能找到一个 pageframe.html 的模版文件，具体位置在 package.nw/html/pageframe.html ：看标题就应该很清楚了，这是渲染层的核心模块，它的作用就是为小程序准备一个新的页面，小程序每个视图层页面内容都是通过 pageframe.html 模板来生成的，包括小程序启动的首页。通过查看源码，里面定义了一个属性 var __webviewId__ ，我猜想这是每个 webView 页面的页面 ID ，逻辑层处理多个视图层间的业务逻辑可能就是通过这个ID来做的映射关系。在首次启动时，后台会缓存生成的 pageframe.html 模版，在后面的页面打开时，直接加载缓存的 pageframe.html 模版，页面引入的资源文件也可以直接在缓存中加载，包括小程序基础库视图层底层、页面的模版信息、配置信息以及样式等内容，这样避免重复生成，快速打开页面，提升页面渲染性能。注入小程序WXML结构和WXSS样式关于 pageframe.html 最后是怎么生成相应页面的归功于一个叫 nw.js 的框架，具体实现这里就不讲了，更多的偏向于前端的知识了。逻辑层上面了解了渲染层都做了什么之后，下面在窥探一下，小程序的逻辑层都做了什么。参考 eux.baidu.com/blog/fe/微信小… 不难发现，sevice 层的代码是由 WAService.js 实现的，逻辑层实际上主要提供了 Page， App，GetApp 接口和更为丰富 wx 接口模块，包括数据绑定、事件分发、生命周期管理、路由管理等等。关于视图层和逻辑层间的具体交互细节可以看下这张图：我们写的页面逻辑最后都被引入到了一个叫 appservice.html 的页面中，并且分别从 app.js 开始一一执行；小程序代码调用 Page 构造器的时候，小程序基础库会记录页面的基础信息，如初始数据（data）、方法等。需要注意的是，如果一个页面被多次创建，并不会使得这个页面所在的JS文件被执行多次，而仅仅是根据初始数据多生成了一个页面实例（this），在页面 JS 文件中直接定义的变量，在所有这个页面的实例间是共享的。对于逻辑层，从客户端的角度看，我们应该更关注于逻辑层的JS是怎么注入到JSCore中的。四、看看JavaScriptCore是怎么执行JS脚本的说到JavaScriptCore，我们先来讨论下Hybrid App 的构建思路，Hybird App是指混合模式移动应用，即其中既包含原生的结构又有内嵌有 Web 的组件。这种 App 不仅性能和用户体验可以达到和原生所差无几的程度，更大的优势在于 bug 修复快，版本迭代无需发版。Hybird App的实质并没有修改原 Native 的行为，而是将下发的资源进行加载和界面渲染，类似 WebView。下面通过一个例子来模拟一下 avaScriptCore 执行 JS 脚本来让 Native 和 JS 之间的通信。关于 JavaScriptCore 的具体使用可以参考下戴铭的 深入剖析 JavaScriptCore 。我们打算实现这样的功能：通过下发JS脚本创建原生的 UILabel 和 UIButton 控件并响应事件，首先编写 JS 代码如下：(function(){\r\n console.log(\"ProgectInit\");\r\n //JS脚本加载完成后 自动render界面\r\n return render();\r\n })();\r\n\r\n//JS标签类\r\nfunction Label(rect,text,color){\r\n    this.rect = rect;\r\n    this.text = text;\r\n    this.color = color;\r\n    this.typeName = \"Label\";\r\n}\r\n//JS按钮类\r\nfunction Button(rect,text,callFunc){\r\n    this.rect = rect;\r\n    this.text = text;\r\n    this.callFunc = callFunc;\r\n    this.typeName = \"Button\";\r\n}\r\n//JS Rect类\r\nfunction Rect(x,y,width,height){\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n}\r\n//JS颜色类\r\nfunction Color(r,g,b,a){\r\n    this.r = r;\r\n    this.g = g;\r\n    this.b = b;\r\n    this.a = a;\r\n}\r\n//渲染方法 界面的渲染写在这里面\r\nfunction render(){\r\n    var rect = new Rect(20,100,280,30);\r\n    var color = new Color(1,0,0,1);\r\n    var label = new Label(rect,\"这是一个原生的Label\",color);\r\n\r\n    var rect4 = new Rect(20,150,280,30);\r\n    var button = new Button(rect4,\"这是一个原生的Button\",function(){\r\n                            var randColor = new Color(Math.random(),Math.random(),Math.random(),1);\r\n                            TestBridge.changeBackgroundColor(randColor);\r\n                            });\r\n    //将控件以数组形式返回\r\n    return [label,button];\r\n}\r\n复制代码创建一个 OC 类 TestBridge 绑定到 JavaScriptCore 全局对象上：@protocol TestBridgeProtocol <JSExport>\r\n- (void)changeBackgroundColor:(JSValue *)value;\r\n@end\r\n\r\n@interface TestBridge : NSObject<TestBridgeProtocol>\r\n\r\n@property(nonatomic, weak) UIViewController *ownerController;\r\n\r\n@end\r\n复制代码#import \"TestBridge.h\"\r\n\r\n@implementation TestBridge\r\n\r\n- (void)changeBackgroundColor:(JSValue *)value{\r\n    self.ownerController.view.backgroundColor = [UIColor colorWithRed:value[@\"r\"].toDouble green:value[@\"g\"].toDouble blue:value[@\"b\"].toDouble alpha:value[@\"a\"].toDouble];\r\n}\r\n\r\n@end\r\n复制代码在 ViewController 中实现一个界面渲染的 render 解释方法：#import \"ViewController.h\"\r\n#import <JavaScriptCore/JavaScriptCore.h>\r\n#import \"TestBridge.h\"\r\n\r\n@interface ViewController ()\r\n\r\n@property(nonatomic, strong)JSContext *jsContext;\r\n@property(nonatomic, strong)NSMutableArray *actionArray;\r\n@property(nonatomic, strong)TestBridge *bridge;\r\n\r\n@end\r\n\r\n@implementation ViewController\r\n\r\n- (void)viewDidLoad {\r\n    [super viewDidLoad];\r\n    //创建JS运行环境\r\n    self.jsContext = [JSContext new];\r\n    //绑定桥接器\r\n    self.bridge =  [TestBridge new];\r\n    self.bridge.ownerController = self;\r\n    self.jsContext[@\"TestBridge\"] = self.bridge;\r\n    self.actionArray = [NSMutableArray array];\r\n    [self render];\r\n}\r\n\r\n-(void)render{\r\n    NSString * path = [[NSBundle mainBundle] pathForResource:@\"main\" ofType:@\"js\"];\r\n    NSData * jsData = [[NSData alloc]initWithContentsOfFile:path];\r\n    NSString * jsCode = [[NSString alloc]initWithData:jsData encoding:NSUTF8StringEncoding];\r\n    JSValue * jsVlaue = [self.jsContext evaluateScript:jsCode];\r\n    for (int i=0; i<jsVlaue.toArray.count; i++) {\r\n        JSValue * subValue = [jsVlaue objectAtIndexedSubscript:i];\r\n        if ([[subValue objectForKeyedSubscript:@\"typeName\"].toString isEqualToString:@\"Label\"]) {\r\n            UILabel * label = [UILabel new];\r\n            label.frame = CGRectMake(subValue[@\"rect\"][@\"x\"].toDouble, subValue[@\"rect\"][@\"y\"].toDouble, subValue[@\"rect\"][@\"width\"].toDouble, subValue[@\"rect\"][@\"height\"].toDouble);\r\n            label.text = subValue[@\"text\"].toString;\r\n            label.textColor = [UIColor colorWithRed:subValue[@\"color\"][@\"r\"].toDouble green:subValue[@\"color\"][@\"g\"].toDouble blue:subValue[@\"color\"][@\"b\"].toDouble alpha:subValue[@\"color\"][@\"a\"].toDouble];\r\n            label.textAlignment = NSTextAlignmentCenter;\r\n            [self.view addSubview:label];\r\n        }else if ([[subValue objectForKeyedSubscript:@\"typeName\"].toString isEqualToString:@\"Button\"]){\r\n            UIButton * button = [UIButton buttonWithType:UIButtonTypeSystem];\r\n            button.frame = CGRectMake(subValue[@\"rect\"][@\"x\"].toDouble, subValue[@\"rect\"][@\"y\"].toDouble, subValue[@\"rect\"][@\"width\"].toDouble, subValue[@\"rect\"][@\"height\"].toDouble);\r\n            [button setTitle:subValue[@\"text\"].toString forState:UIControlStateNormal];\r\n            button.tag = self.actionArray.count;\r\n            [button addTarget:self action:@selector(buttonAction:) forControlEvents:UIControlEventTouchUpInside];\r\n            [self.actionArray addObject:subValue[@\"callFunc\"]];\r\n            [self.view addSubview:button];\r\n            \r\n        }\r\n    }\r\n}\r\n\r\n-(void)buttonAction:(UIButton *)btn{\r\n    JSValue * action  = self.actionArray[btn.tag];\r\n    [action callWithArguments:nil];\r\n}\r\n\r\n@end\r\n复制代码这样就完成了一个简单的 JS 脚本注入，实际上执行后的样子是这样的：这就是一个简单的执行 JS 脚本的逻辑，实际上 ReactNative 的原理也是基于此，小程序逻辑层与微信客户端的交互逻辑也是基于此。到这里，关于微信小程序渲染层与逻辑层做了什么、怎么做的、优化了什么以及为什么要采用这样的架构来设计，基本都梳理完毕了。小程序这样的分层设计显然是有意为之的，它的中间层完全控制了程序对于界面进行的操作， 同时对于传递的数据和响应时间也做到的监控。一方面程序的行为受到了极大限制， 另一方面微信可以确保他们对于小程序内容和体验有绝对的控制。我们在小程序的 JS 代码里面是不能直接使用浏览器提供的 DOM 和 BOM 接口的，这一方面是因为 JS 代码外层使用了局部变量进行屏蔽，另一方面即便我们可以操作 DOM 和 BOM 接口，它们对应的也是逻辑层模块，并不会对页面产生影响。这样的结构也说明了小程序的动画和绘图 API 被设计成生成一个最终对象而不是一步一步执行的样子， 原因就是 json 格式的数据传递和解析相比与原生 API 都是损耗不菲的，如果频繁调用很可能损耗 过多性能，进而影响用户体验。总结一句话就是 webView渲染，JSCore处理逻辑，JSBridge做线程通信 。后面再简要的分析下支付宝小程序，支付宝小程序属于后起之秀，支付宝小程序在微信小程序的基础上，做了一些优化，单从技术角度来看，有点后来者居上的意思。目前支付宝技术通过官方的媒体账号对外暴漏的一些实现细节也在逐步增多。六、再说说支付宝小程序前端框架下面是小程序 native 引擎，包括了小程序容器、渲染引擎和 JavaScript 引擎，这块主要是把客户端 native 的能力和前端框架结合起来，给开发者提供系统底层能力的接口。在渲染引擎上面，支付宝小程序不仅提供 JavaScript+Webview 的方式，还提供 JavaScript+Native 的方式，在对性能要求较高的场景，可以选择 Native 的渲染模式，给用户更好的体验。这段文字来源于支付宝对外开放的技术博客的描述，从这段描述中，我们能够发现支付宝小程序在架构设计上同样采用的渲染引擎加 JavaScript 引擎两部分，包括页面间的切换实际上和微信小程序逻辑基本一致。下面这张是支付宝小程序应用框架的架构图：运行时架构单从这个运行时架构来看，它与微信小程序不同的地方是，webView 页面也就是渲染层通过消息服务直接与逻辑层进行通讯，而不需要像微信的 JSBridge 那样作为中间层，消息服务具体实现细节目前尚不得知。支付宝的JSBridge只会与逻辑层进行通讯，来给小程序提供一些 Native 能力。支付宝的这种架构主要目的是解决渲染层与逻辑层交互的对象较复杂、数据量较大时，交互的性能比较差的问题。支付宝小程序的设计思路比较值得借鉴，微信小程序线程间的通讯是通过 JSBridge ，序列化 json 进行传递的。支付宝小程序重新设计了V8虚拟机，让逻辑和渲染都有自己的 Local Runtime，存放私有的模块和数据。在渲染层和逻辑层交互时，setData 的 对象会直接创建在 Shared Heap 里面，因此渲染层的 Local Runtime 可以直接读到该对象，并且用于 render 层的渲染，保证了逻辑和渲染的隔离，又减少了序列化和传输成本。当然支付宝还有些其他的优化，包括首页离线缓存，缓存时机的处理以及闪屏处理等等问题，这里就不再延伸讨论了（因为很多细节我也不知道）。小程序SDK根据支付宝小程序对外开放的技术文章来看，架构设计还是非常巧妙的，也很值得我们学习，先看图：参考： 独家！支付宝小程序技术架构全解析小程序SDK在架构设计上把它分为了两部分，一部分是核心库基础引擎，一部分是基于基础库开发的插件功能。从上往下看：第一层小程序层，这是小程序开发者使用小程序 DSL 及各种组件开发的代码层。第二层和第三层架应该是小程序内部封装的一些组件和对外提供的相关API等。第四层和第五层是小程序的运行基础框架，主要包含小程序的逻辑处理引擎及渲染层。支付宝基于 ReactNative 增加了 Native 引擎，可以用原生来渲染 UI 。根据支付宝 mPaaS 的介绍来看，目前支付宝的小程序使用的是 React 版，蚂蚁内部的其他 App 有在使用 React Native 版的小程序。基础组件部分和扩展能力部分更像是基于 Bridge 调用的原生能力。六、最后差不多半年多没有写文章了，趁着公司年会时间稍显充裕，对当前的小程序架构进行了下分析和总结，当然，真正的小程序应该比这还要复杂的多，小程序实际上是多年来大前端融合的一个结果，是一套非常成体系的技术方案，看了这么多我想你对小程序也有了初步认识，小程序的核心实际上还是 渲染层 和 逻辑层 的构建，那么如果让你开发一套 小程序SDK ，你会怎样设计它们呢？"}
{"title": "小程序摸爬滚打之路 ", "author": "Rolan", "pub_time": "2020-1-10 00:12", "content": "上面这张图相信接触过小程序的开发者多多少少都有看到过，小程序的渲染层和逻辑层分别由 2 个线程管理：视图层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS脚本。那么为什么要这样设计呢，为了管控和安全，我们需要阻止开发者使用一些，例如浏览器的window对象，跳转页面、操作DOM、动态执行脚本的开放性接口。我们可以使用客户端系统的 JavaScript 引擎，iOS 下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境。这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口。2.双线程之间的通信既然小程序的模型是双线程模型，那么是如何实现双线程之间的通信呢，由上图可以看出，逻辑层和视图层是通过Native层来进行转发的，这也就是说，我们可以把 DOM 的更新通过简单的数据通信来实现，类似于虚拟DOM的实现，用JS对象模拟DOM树，然后进行diff,然后把差异在视图层进行渲染，这一系列在Native之间的转化则由小程序的基础库来完成。3.组件系统--Exparser框架Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由Exparser组织管理。DOM模型：模型上与WebComponents的ShadowDOM高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。当前Web Component已经支持局部作用域、slot插槽等等现有框架所提供的组件化方法，学习Web Component也是我接下来自己学习的目标之一 Orz 。4.setData干了些什么小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。5.运行机制小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台状态的小程序切换到前台，这个过程就是热启动；冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。小程序开发日常问题1.wx.request()的promise化小程序框架自带的网络请求和Ajax请求非常相似都是异步请求，请求参数中需要送入url、method、data、header等参数，还要设置success成功的回调函数和fail失败的回调函数，如下图所示通过回调函数处理就很容易造成回调地狱，所以Promise化还是很有必要的class request {\r\n  constructor() {\r\n    this._baseUrl = 'https://xxx.com/api';\r\n    this._token = wx.getStorageSync('token');\r\n    this._header = {}\r\n  }\r\n\r\n  /**\r\n   * GET类型的网络请求\r\n   */\r\n  getRequest(url, data, header = this._header) {\r\n    return this.requestAll(url, data, header, 'GET')\r\n  }\r\n\r\n  /**\r\n   * DELETE类型的网络请求\r\n   */\r\n  deleteRequest(url, data, header = this._header) {\r\n    return this.requestAll(url, data, header, 'DELETE')\r\n  }\r\n\r\n  /**\r\n   * PUT类型的网络请求\r\n   */\r\n  putRequest(url, data, header = this._header) {\r\n    return this.requestAll(url, data, header, 'PUT')\r\n  }\r\n\r\n  /**\r\n   * POST类型的网络请求\r\n   */\r\n  postRequest(url, data, header = this._header) {\r\n    return this.requestAll(url, data, header, 'POST')\r\n  }\r\n  \r\n  requestAll(url, data, header, method) {\r\n    return new Promise((resolve, reject) => {\r\n      wx.request({\r\n        url: this._baseUrl + url,\r\n        data: data,\r\n        header: header,\r\n        method: method,\r\n        success: (res => {\r\n          if (res.statusCode === 200) {\r\n            resolve(res)\r\n          } else {\r\n            //其它错误，提示用户错误信息\r\n            reject(res)\r\n          }\r\n        }),\r\n        fail: (res => {\r\n          reject(res)\r\n        })\r\n      })\r\n    })\r\n  }\r\n}\r\n\r\nexport default request\r\n复制代码2.小程序的WXS在小程序的日常开发中大家肯定会遇到需要对数据进行过滤转义的场景，而微信小程序没有像Vue一样的filter过滤器功能，大多数人会在渲染之前对数据进行一次清洗，而WXS就是为了解决这一痛点什么是WXS是小程序出的一套脚本语言，用于 wxml 模板文件中，在模板文件中可以完成页面的结构。不依赖于运行时的基础库脚本，可以在所有版本的小程序中运行。WXS 中不能调用 javascript 中定义的函数或者变量，也不能调用小程序提供的 API，他的运行环境和 javascript 是隔离的。小程序的条件渲染和循环渲染对 WXS 是无效的，就是说如果 WXS 代码包裹在未渲染的代码中，只要渲染的 wxml 部分调用了此模块，此段 WXS 代码依然会被加载。由于运行环境的差异，在 ios 设备上小程序的 WXS 会比 javascript 快 2~20 倍，在 android 设备上运行效率无异。模块想要暴露自己的私有变量和方法，只能通过 module.exports 实现。 若在模块中想要引用其他模块，只能通过 require 实现。只能使用 var 来定义变量，表现形式和 javascript 一样，会有变量提升。WXS 模块只能在定义模块的 wxml 文件中被访问到，使用 或 时，WXS 模块不会被引入到对应的 wxml 文件中。不能使用 new Date() 应该使用 getDate() 。WXS最常见的用处可能就是实现一个过滤器，如下所示<wxs module=\"filter\">\r\n    function getFullPath(url) {\r\n        return \"https://shiyuanjieyi.cn\" + url\r\n    }\r\n    module.exports.getFullPath = getFullPath\r\n</wxs>\r\n<image src=\"{{filter.getFullPath(url)}}\"></image>\r\n复制代码"}
{"title": "如何处理小程序独立分包的数据共享问题 ", "author": "Rolan", "pub_time": "2020-1-10 00:55", "content": "小程序2.3.0版本开始支持独立分包。对于短期的活动落地页，我们会选择使用独立分包，这可以大大提升活动落地页的加载速度。\r\n但与此同时，由于独立分包中不能依赖主包和其他分包中的内容，独立分包的使用也带来了一些数据共享问题。\r\n遇到的问题\r\n公用数据处理复杂\r\n对于页面间的公用数据，我们原本的处理方式是将数据挂在App对象上。但引入了独立分包后，判断的逻辑就变得复杂了。\r\n例如，我们想设计一个计数器counter，能够在小程序的各个地方调用。我们将结果记录在app.globalData.count，这时候需要分三种场景考虑：\r\n\r\n主包和普通分包页面中，通过getApp()来获取App对象;\r\n在App对象中，通过this来获取App对象;\r\n在独立分包或App对象注册前，通过getApp({ allowDefault: true })来获取App对象（新的逻辑）;\r\n\r\n另外，对于3的情况，由于App对象可能未初始化，还要判断globalData、count属性是否存在。\r\n事件被重复绑定\r\n通过wx.onError、wx.onPageNotFound等方法可以监控小程序的运行情况，我们把这些能力封装在npm包中。\r\nexport function report() {\r\n  // 各种处理逻辑\r\n  // ....\r\n}\r\n\r\nwx.onError(report);\r\n复制代码当独立分包和主包都引入了这个npm包，而npm包中调用wx.onXXXX方法进行了绑定，我们可以想到，当用户在独立分包和主包页面之间跳转时，事件的处理函数会被绑定不止一次（主包一次，每个独立分包一次）。\r\n解决思路\r\n\r\n\r\n对于需要在主包、独立分包公用数据的情况，我们考虑将不同场景下读写app对象的能力封装起来，这类似于一个SessionStorage，我们可以在任意场景操作SessionStorage里的公用数据，而数据会在小程序从冷启动到销毁的运行过程中一直保留。\r\n\r\n\r\n对于事件重复绑定的问题，我们使用sessionStorage中的一个key来加锁。实现一个once方法，保证同一个key的逻辑只执行一次，通过如下的方式来调用\r\nexport function report() {\r\n  // 各种处理逻辑\r\n  // ....\r\n}\r\n\r\nonce('_wx_onerror_key_', () => { wx.onError(report); });\r\n复制代码\r\n\r\n具体实现\r\n\r\n为了不与原有的globalData冲突，我们使用一个新的BASIC_KEY，作为App对象上的属性名，来存储sessionStorage的内容。\r\n默认以getApp({ allowDefault: true })获取App对象，为了满足在App()内调用时也能取到正确的App对象，我们可以在App.onLaunch方法时将this传入sessionStorage.setApp(this)。\r\n暴露的api对齐浏览器的sessionStorage，实现如下：\r\n\r\nconst BASIC_KEY = '_imwxutils_sessionStorageData_';\r\nlet app = getApp({ allowDefault: true }) || {};\r\napp[BASIC_KEY] = app[BASIC_KEY] || {};\r\n\r\nexport function setApp(customApp) {\r\n  customApp[BASIC_KEY] = customApp[BASIC_KEY] || app[BASIC_KEY] || {};\r\n  app = customApp;\r\n}\r\n\r\nexport function setItem(key, value) {\r\n  app[BASIC_KEY][key] = value;\r\n}\r\n\r\nexport function getItem(key) {\r\n  return app[BASIC_KEY][key];\r\n}\r\n\r\nexport function removeItem(key) {\r\n  app[BASIC_KEY][key] = null;\r\n}\r\n\r\nexport function clear() {\r\n  app[BASIC_KEY] = {};\r\n}\r\n\r\n复制代码基于sessionStorage我们又可以实现once方法：\r\nimport * as sessionStorage from './session-storage';\r\n\r\nconst ONCE_BASIC_KEY = '_imwxutils_once_record_';\r\n/**\r\n * 全局只执行一次的方法\r\n */\r\nfunction once(key, func) {\r\n  if (!key) {\r\n    return;\r\n  }\r\n  const record = sessionStorage.getItem(ONCE_BASIC_KEY) || {};\r\n\r\n  if (record[key]) { // 之前执行过了\r\n    return;\r\n  }\r\n  record[key] = true;\r\n  sessionStorage.setItem(ONCE_BASIC_KEY, record);\r\n  func();\r\n}\r\n复制代码\r\n以上，通过实现sessionStorage和once方法，我们解决了独立分包与主包之间数据共享以及事件绑重复定的问题。\r\n欢迎交流"}
{"title": "小程序登录的最优流程 ", "author": "Rolan", "pub_time": "2020-1-13 00:16", "content": "18年中旬做过一个小程序，当时是通过转跳到一个登录页，然后点击调用 wx.getUserInfo ，然后发现这个api被禁用了(虽然依然可以用)，然后用<!-- 需要使用 button 来授权登录 -->\r\n<button wx:if=\"{{canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\">授权登录</button>\r\n<view wx:else>请升级微信版本</view>\r\n复制代码因为当时刚好需要用户信息，然后这个api有一个 encryptedData 属性可以获取信息。这样的流程本就可以了，但是意外出现了。思维的禁锢当第二次(2020年)需要开发一个新的小程序，于是也用了老代码， 但是出现了个奇怪的问题。 有兴趣的可以看下面的[奇怪的问题]奇怪的问题：因为微信限制无法转跳到登录页，所以想是否应该在首页设置一个弹窗，点击的时候授权。但是因为考虑到可能会被微信拒绝，故在小程序开发者论坛开了一篇文章app无法转跳到登录页面 and 小程序登录的哲学思考随后发现，登录其实并不需要授权弹窗or页面。（如果服务器不需要保存用户信息)流程下面这个图是小程序官方图 点我转跳代码app.js（小程序的入口文件）的完整代码const loginDataKey = 'loginData'\r\n\r\n//app.js\r\nApp({\r\n  onLaunch: function () {\r\n\r\n    const loginData = wx.getStorageSync(loginDataKey)\r\n    console.log('--loginData--')\r\n    console.log(loginData)\r\n    let toLogin = () => {\r\n      console.log('未登录，去登录..')\r\n      wx.showLoading({title: '登录中', icon: 'loading', mask: true})\r\n      wx.login({\r\n        success(res){\r\n          console.log('wx.login res')\r\n          console.log(res)\r\n          let success = () => {\r\n            console.log('登录成功')\r\n            let loginResponse = {\"openid\":\"ooZAbwpdDdaZV_xiamianshi_mashaike\"}\r\n            wx.setStorageSync(loginDataKey, loginResponse)\r\n            wx.hideLoading()\r\n          }\r\n          let fail = () => {\r\n            wx.hideLoading()\r\n            wx.showToast({\r\n              title: '登录失败，请重新打开小程序试试',\r\n              icon: 'none',\r\n              duration: 1e8\r\n            })\r\n          }\r\n          // TODO 发起网络请求\r\n          // 延时模拟请求登录成功\r\n          setTimeout(success, 500)\r\n        },\r\n        fail(err){\r\n          console.log(err)\r\n          wx.hideLoading()\r\n          wx.showToast({\r\n            title: '登录失败，请重新打开小程序试试',\r\n            icon: 'none',\r\n            duration: 1e8\r\n          })\r\n        }\r\n      })\r\n    }\r\n    // 未登录，去登录\r\n    if(!loginData){\r\n      toLogin()\r\n    // 已登录，但是微信session_key过期\r\n    }else{\r\n      wx.checkSession({\r\n        success () {\r\n          //session_key 未过期，并且在本生命周期一直有效\r\n          console.log('session_key 未过期')\r\n        },\r\n        fail () {\r\n          // session_key 已经失效，需要重新执行登录流程\r\n          console.log('session_key 已经失效，需要重新执行登录流程, 重新登录中')\r\n          toLogin()\r\n        }\r\n      })\r\n    }\r\n\r\n  },\r\n  globalData: {\r\n    userInfo: null\r\n  }\r\n})\r\n复制代码流程如下根据本地储存判断是否登录已登录判断是否失效失效或者未登录去登录登录展示toast拿到信息存储 关闭toast核心wx.login拿到code然后把code通过 auth.code2Session 获取openid和unionid等。这是我通过 auth.code2Session 拿到openid的截图（因为这个是测试号，所以没有unionid）【unionid】是拿来和其他平台打通账号的关键，如果只有一个小程序，都可以不需要这个。效果\r\n\r\n其他\r\n纯展示用户头像昵称等\r\n<open-data type=\"userAvatarUrl\"></open-data>\r\n<open-data type=\"userNickName\"></open-data>\r\n复制代码查看open-data文档\r\n--完--"}
{"title": "微信小程序 动态加载swiper时不显示的问题（爬坑） ", "author": "Rolan", "pub_time": "2020-1-13 00:24", "content": "问题一报错信息TypeError: Cannot read property '$$' of undefined\r\n    at HTMLElement._attached.wx.getPlatform._touchstartHandlerForDevtools解决方法：因为小程序会保留上一次滑动swiper时候的current，所以会出现上次滑动到的current在这次的数据中不存在问题，所以，每次动态加载swiper-item前，需要设置swiper的current属性为0问题二swiper 的current每次设置了0，但是还是不显示 swiper，检查元素是存在的，并且current = -1<swiper current='-1'><swiper>解决方法，动态设置swiper-item的数据时，还需设置current = 0，并且current和swiperList不能在一个this.setData中设置，要先setData swiperList 然后在setData current我是这样写的：this.setData({\r\n  swiperItem: list\r\n},()=>{\r\n  this.setData({\r\n    current: 0\r\n  })\r\n})\r\n//在每次给swiper赋值之后在它的回调中在赋值current之后没有问题成功解决，希望对你有所帮助。"}
{"title": "京东购物小程序cookie方案实践 ", "author": "Rolan", "pub_time": "2020-1-13 00:32", "content": "早期为了解决“会话保持”的需求，社区中出现了「cookie方案」并最终成为W3C标准：当某个网站登录成功后，客户端（浏览器）收到一个cookie标识（文本）并保存下来，在后续请求中会自动带上这个字段，由此Web后台可以判断是否同一个用户，从而使“会话”得以延续。微信小程序没有像浏览器一样内置实现了cookie方案，需要开发者自行模拟，而原先京东购物小程序及京喜小程序（现微信一级购物入口）是从微信及手Q购物H5中迁移迭代出来的，也就是说我们不仅要在小程序中模拟一套cookie方案，并且要保持和原业务对cookie处理逻辑的一致，为此我们将实现方向确定为“基于小程序开放能力，和浏览器保持一致”。微信小程序开放了 数据缓存 Storage 和 网络 Network 这两种能力，通过这两套API，我们可以自行DIY一个cookie方案。PS：本文所有代码及使用示例都可以 在这里 找到，阅读本文时配合实践，效果更佳。二、浏览器中的cookie为了保持后端对cookie的处理逻辑和原来的H5一致，小程序的实现需要往浏览器看齐。所以模拟小程序的cookie前，先看看浏览器的cookie机制，主要有以下几个部分：本地存储：浏览器会在本地分配一块空间，存储cookie请求携带：每次发起请求，都会从本地取出cookie并追加在请求头上响应设置：当响应头有Set-Cookie字段时，需要解析并更新过期时间：每个cookie字段有单独的过期时间，并且到期会自动清除读写操作：暴露API给前端JS调用，可进行增删改查操作作用域：路径path、域名domin编码：cookie值，在网络传输需要encode，建议存储也一样其它：HttpOnly、Secure、SameSite在浏览器的 DevTools 中，可以看到当前站点下的Cookie明细：三、小程序中的cookie实现方案设计在小程序中模拟Cookie，主要涉及五个部分：其中我们会重点关注 「Cookie基础库」 的实现，另外也会给出「Request基础库」的封装示例。本地存储小程序提供了 「数据缓存 Storage API」（可以理解为Web规范中的 LocalStorage ），支持存储“原生类型、Date、及能够通过JSON.stringify序列化的对象”。我们可以利用这些API，在Storage中新开一个 cookies 字段进行存储：// 存：\r\nwx.setStorageSync('cookies', cookies)\r\n// 取：\r\nwx.getStorageSync('cookies')\r\n复制代码其中 cookies 的「存储结构」如下：// cookies = \r\n{\r\n    cookie1: { // “最小cookie单元” ==> cookieItem\r\n        name: 'cookie1', // cookie名\r\n        value: 'xxx',    // cookie值\r\n        expires: 'Fri, 17 Jan 2020 08:49:41 GMT' // 过期时间，使用GMT（格林威治标准时间）格式\r\n    }\r\n},\r\n复制代码上面的 cookie1 便是一个“最小cookie单元 cookieItem ”，包含了3个字段（name、value、expires），是本文中定义的「标准cookie格式」，也是cookie操作的基本单元。打开【微信开发工具】的 Storage 选项卡，可以查看本地存储的情况：读写操作这部分主要作为“公共基础库“的角色，为外部业务提供增删改查cookie的API。1. 获取cookie———— getCookie()步骤：从Storage中取出完整cookies ==> 取出指定name的cookie项 ==> 校验有效期 ==> 返回值value实现如下：function getCookie(name = '') {\r\n    let cookies = wx.getStorageSync('cookies') // try/catch 略过\r\n    let { value, expires } = cookies[name] || {}\r\n\r\n    return (name && expires && !isExpired(expires)) ? decodeURIComponent(cookieItem.value) : ''\r\n}\r\n复制代码2. 设置cookie———— setCookie()步骤：从Storage中取出完整cookies ==> 解析入参 ==> 覆盖更新 ==> 同步到本地Storage首先看下本API设计需求：设置单个/多个cookie直接传值/传cookieItem（Object）时间格式maxAge/expires调用示例如下：setCookie({\r\n    cookie1: 12345,\r\n    cookie2: '12345'\r\n})\r\n\r\nsetCookie({\r\n    cookie1: {\r\n        value: 12345,\r\n        maxAge: 3600 * 24  // 自定义有效期（这里示例是24小时）\r\n    },\r\n    cookie2: {\r\n        value: '12345',\r\n        expires: 'Wed, 21 Oct 2015 07:28:00 GMT' // 标准GMT格式\r\n    }\r\n})\r\n复制代码这里可对入参遍历，而cookie子项无论直接传值value还是传了详细object，都尽量的获取 name/value/expires/maxAge ，传给格式化函数转为标准的 cookieItem ：function setCookie(cookiesParam) {\r\n    let oldCookies = wx.getStorageSync('cookies') // try/catch 略过\r\n    let newCookies = {} // 由 cookiesParam 转化为标准格式后的cookies\r\n\r\n    for (let name in cookiesParam) {\r\n        if (isObject(cookiesParam[name])) { // 传入是Object格式\r\n            let { value, expires, maxAge } = cookiesParam[name]\r\n            // 转换为标准cookie格式（cookieItem）\r\n            newCookies[name] = getStandardCookieItem({ name, value, expires, maxAge })\r\n        } else {\r\n            newCookies[name] = getStandardCookieItem({ name, value: cookiesParam[name] })\r\n        }\r\n    }\r\n\r\n    // 同步到本地Storage\r\n    saveCookiesToStorage(Object.assign({}, oldCookies, newCookies))\r\n}\r\n复制代码3. 删除cookie———— removeCookie()步骤：从Storage中取出完整cookies ==> 删除指定的cookie项 ==> 同步到本地Storagefunction removeCookie(cookieName) {\r\n    let cookies = wx.getStorageSync('cookies') // try/catch 略过\r\n\r\n    delete cookies[cookieName]\r\n\r\n    saveCookiesToStorage(Object.assign({}, cookies))\r\n}\r\n复制代码四、Cookie 在网络中的传递本节主要简单实现设计图中的【Request基础库】部分如上图所示，Cookie在网络中的传输主要有四个过程：Set-Cookie\r\nCookie\r\nCookie\r\n以下是对一个请求的抓包示例：在小程序中，请求发起有两种方式： HTTP 和 WebSocket ，这里以HTTP为例，先对请求api进行「封装」：function requestPro({ url, data, header, method = 'GET' }) {\r\n    return new Promise((resolve, reject) => {\r\n        wx.request({\r\n            url,\r\n            data,\r\n            header: Object.assign({}, { 'Cookie': CookieLib.getCookiesStr() }, header), // 请求头————带上Cookie\r\n            success (res) {\r\n              let { data : resData, header, statusCode } = res\r\n              let setCookieStr = header['Set-Cookie'] || header['set-cookie'] || ''\r\n\r\n              CookieLib.setCookieFromHeader(setCookieStr) // 响应头————解析Set-Cookie\r\n              resolve(resData)\r\n            },\r\n            fail (err) {\r\n                reject(err)\r\n            }\r\n          })\r\n    })\r\n}\r\n复制代码如上代码所示，Cookie在前端侧请求模块中的处理主要有3点：1. 请求携带步骤：（每次发请求前）从Storage中取出完整cookies ==> 转化为HTTP规范的请求头Cookie格式 ==> 设置到 Request Header 中上面代码中的 getCookiesStr() 直接取cookies拼接即可，返回示例： cookie1=xxx;cookie2=yyy 。2. 响应设置步骤：（每次收到响应后）解析 Response Header 的 Set-Cookie 字段 ==> 转为标准Cookie格式 ==> setCookie()这里处理 Set-Cookie 内容时，有几个点需要留意： - 最基本的格式： Set-Cookie: <cookie-name>=<cookie-value> - 可能同时包含多个cookie字段，以,分割（但需要排除时间值里的,） - 时间格式：Max-Age/Expires （不区分大小写）具体实现可在文末Demo中找到。3. 编码问题「Cookie值编码方式」是容易产生困惑的地方，目前看到的广泛做法都是使用「URL编码」。但笔者翻阅 RFC6265 发现，原始规范中并没有对编码进行指定，比如在第四章 Server Requirements （服务端）中是这样描述：To maximize compatibility with user agents, servers that wish to store arbitrary data in a cookie-value SHOULD encode that data, for example, using Base64 [RFC4648].\r\n“为了最好的兼容效果，服务端应该对cookie值进行编码，例如使用Base64。”而在第五章 User Agent Requirements （客户端，也就是浏览器），则是“建议以第四章服务端的实现为准”。总之规范并没有指定使用「URL编码」，但基于该编码方案已经深入人心，也就顺其自然成了“默认选择”。那这里也不做例外，浏览器怎么做，咋们小程序也保持一致。在浏览器中，推荐cookie值经过 encode 编码后保存下来，所以直接取到的也是 encode 后的值，所以追加在请求头 Cookie 字段，就不需要 decode 解码了，直接拼接即可（但基础库API的get操作最终需要进行 decode 解码）。而对于响应头 Set-Cookie 的值，我们认为后端已经做了 encode 编码，所以前端不需要处理，直接存进 Storage 即可。五、性能优化（高频读写）前面实现中每次读写cookie都会调用小程序Storage API（而且是同步的），小程序框架会读写到本地Storage。 对于高频场景，可以将cookie在内存中维护一份，读写都直接走「内存层」，有更新才同步到「Storage层」。1. 初始化首先需要在内存中声明一个 _COOKIES （命名自行diy），建议在cookie基础库中声明，便于统一维护。2. 读前面初始化时已经从Storage读取一次cookies，后续getCookie就直接读内存的 _COOKIES 即可。3. 写写操作直接更新内存，间接更新Storage。 如果有高频写场景，可以考虑做个任务队列进行节流。六、单元测试微信官方在2019年5月推出了「小程序自动化 SDK」 miniprogram-automator ，经过半年多的迭代，目前已基本稳定下来。在购物小程序场景试用了一下，cookie相关的用例很快就完成了，简直是开发者的福音：真香！！！实际项目中，对cookie的单元测试可以分为两类：小程序全局范围的cookie验证（比如初始化小程序后，有没有种下版本号、访问行为等关键cookie）cookie基础库API验证（比如get/set/remove等各个API是否正常工作）以验证 setCookie() API为例：it('API验证：setCookie()', async () => {\r\n    await miniProgram.evaluate(() => {\r\n        wx.CookieLib.setCookie({ // 调用API\r\n            cookie1: 12345,\r\n        })\r\n    })\r\n\r\n    let { cookies } = await miniProgram.callWxMethod('getStorageSync', 'cookies')\r\n    expect(cookies['cookie1'].value).toBe(12345) // 期望成功设置cookie1为12345\r\n})\r\n复制代码这里为了方便测试用例调用基础库API，在小程序启动前，把Cookie基础库（CookieLib）挂到了 wx 对象上，实现方式是使用node读写文件的API去【植入代码】：fs.appendFileSync('./your_project/app.js', ''\\n wx.CookieUtil = require(\\'./lib/cookie.js\\');\\n'')\r\n复制代码七、Cookie安全Cookie安全是一个比较大的话题，这里只简单列出和小程序相关的几个点。path、domin、HttpOnly、Secure、SameSite小程序中已经做了一些安全措施，比如只能走HTTPS、合法域名需要管理员到微信后台进行配置、Storage只能由写入它的小程序中访问，等等。 因此 path、domin、HttpOnly、Secure、SameSite 这些字段在小程序环境下的价值没有浏览器环境大，本例中没有使用（懒..），而实际业务场景可以按自身情况决定是否要使用。白名单机制前端维护（大小/数量） 通常浏览器保持的Cookie数据不超过4k，部分浏览器限制同一站点最多cookie数为20个。 如果业务庞大的话，建议在Cookie基础库做一套「白名单」机制，在白名单内才可以写入，以此防止“非法写入”或“内容超大导致信息丢失”的问题。后台维护（网关白名单） 同样的，建议从网关层面，建立一个“可信cookie”白名单，自动过滤请求中的“非法cookie”字段。前端防篡改小程序前端更多是防“误改”————即在操作Cookie过程中，发生了意料之外的修改。通常发生在JS“引用拷贝”特性上，比如前面提到的内存维护一个 _Cookies ，如果有一个API getAllCookies() 直接将这份内存版cookies暴露出去，对象引用容易被连带修改。所以cookie基础库需要控制暴露API的能力范围，并对取值进行“深拷贝”。SessionSession机制将用户状态放在了服务端维护，具备更好的安全性，而且目前各种后端对于session的存储和同步都有很成熟的技术方案，有条件的业务应以Session为主做会话保持。指纹上报用户访问时生成设备指纹并上报（通常是登录/结算等环节），业务后台配合风控系统，遇到异常请求时下发验证环节。八、完整小程序实现Demo代码片段： developers.weixin.qq.com/s/x4sFASmh7…九、小结本文先解析了浏览器的 Cookie机制 运作原理，然后使用「数据缓存」和「网络」能力，以 公共基础库 的形式，在小程序中实现了一套 Cookie方案。希望对大家有所帮助。"}
{"title": "迷你PS小程序-集成的开放式画报、油墨电子签名、图片拖拽可单独食用 ... ", "author": "Rolan", "pub_time": "2020-1-13 00:58", "content": "米娜桑，哦哈哟~个人制作，该文章主要讲解最近基于 uni-app 框架编写的集图文拖拽等多方位编辑、油墨电子签名、开放式海报于一体的小程序的制作思路和实现代码。目录1、完整源码链接2、实现思路3、核心代码3-1、图文多方位编辑3-2、油墨电子签名3-3、开放式海报3-4、小结4.效果展示和体验1、完整源码链接：完整代码：https://github.com/TensionMax/mini-ps其中演示的文字编辑、图片编辑、油墨电子签名、开放式海报可单独食用，含文档说明。2、实现思路该工具主要由五个不同组件模块：文字编辑、图片编辑，油墨电子签名、控制、开放式海报1、文字编辑模块设置好的文字参数对象插入到文字队列中。2、图片编辑模块设置好的图片参数对象插入到图片队列中。3、油墨电子签名模块完成绘制后转为利用 canvasToTempFilePath 转成临时图片，获取参数后插入图片队列中，也可以直接导出。4、利用控制模块调整/文字队列和图片队列的参数。5、开放式海报模块，利用控制台的参数将PS画板上的效果绘制到canvas上来实现的效果，接着再利用 canvasToTempFilePath 转成图片导出。3、核心代码3-1、文字/图片编辑模块文字/图片编辑模块主要是实现移动/缩放功能，其他附带的属于甜品，由于两个模块功能类似，该篇仅讲解图片编辑模块。HTML<img\r\n style=\"position: absolute\"\r\n :style=\"{\r\n     left: item.x+'px', \r\n     top: item.y+'px',\r\n     width: item.w+'px',\r\n     height: item.h+'px',\r\n     }\"\r\n  @touchstart='touchStart($event,item,index)' \r\n  @longpress='longPress($event,item,index)'\r\n  @touchmove.stop='touchMove($event,item,index)' \r\n  @touchcancel=\"touchEnd($event,item,index)\" \r\n  @touchend='touchEnd($event,item,index)'\r\n  v-for=\"(item,index) of imagelist\"\r\n  :key=\"index\" \r\n  :src=\"item.src\"\r\n  />在 imageList 的数组标签中，每个绑定的事件中用 $event 来调用事件本身的参数，其中 $event 的 touches 或 changedTouches 包含我们需要的位置参数，示例如下：touches:[{\r\n        clientX: 14 //与显示区域(不含顶部栏)左上角的水平距离\r\n        clientY: 16 //与显示区域(不含顶部栏)左上角的垂直距离\r\n        pageX: 14 //与整个页面(不含顶部栏)左上角的水平距离\r\n        pageY: 16 //与整个页面(不含顶部栏)左上角的垂直距离\r\n        },\r\n        {\r\n        clientX: 14\r\n        clientY: 16\r\n        pageX: 14\r\n        pageY: 16\r\n        }]touches 长度为2代表双指触碰，通过判定双指触摸点的变化方向可实现双指缩放效果。因为每个标签都设置为 style=\"position: absolute\" 所以只需要根据位置参数来更新 x、y、w、h 即可题外话-性能问题一次移动多次操作DOM影响性能—— 虚拟DOM了解一下为何不用事件委派—— 不必要，Vue已经帮我们做了优化，在非常影响性能时再考虑图片编辑Demo3-2、油墨电子签名板由于 touchmove 事件在小程序真机的触发频率和精确度很迷，不太好根据速度来判定绘制的线宽，我只好用其他方式去实现，虽然效果不完美。其实现思路是通过多次的循环绘制以达到油墨效果，每次循环绘制的长度和宽度都不相同。HTML<canvas \r\ncanvas-id=\"canvas\" \r\n@touchstart.stop=\"touchStart\" \r\n@touchmove.stop=\"touchMove\"\r\n@touchend.stop=\"touchEnd\"\r\n>\r\n</canvas>JAVASCRIPTexport default {\r\ndata() {\r\n    return {\r\n        lineWidth0: 5, //初始线宽 建议1~5\r\n        ctx: null,\r\n        x0: 0, //初始横坐标或上一段touchmove事件中触摸点的横坐标\r\n        y0: 0, //初始纵坐标或上一段touchmove事件中触摸点的纵坐标\r\n        t0: 0, //初始时间或上一段touchmove事件发生时间\r\n        v0: 0, //初始速率或touchmove事件间发生速率\r\n        lineWidth: 0, //动态线宽\r\n        keenness: 5, //油墨程度 建议0~5\r\n        k: 0.3, //油墨因子，即每次绘制线条时线宽的变化程度\r\n    }\r\n},\r\nonReady() {\r\n    this.ctx = uni.createCanvasContext('canvas', this);\r\n    this.ctx.setLineCap('round')\r\n},\r\nmethods: {\r\n    //设置初始值\r\n    touchStart(e) {\r\n        this.lineWidth = this.lineWidth0\r\n        this.t0 = new Date().getTime()\r\n        this.v0 = 0\r\n        this.x0 = e.touches[0].clientX\r\n        this.y0 = e.touches[0].clientY\r\n    },\r\n\r\n    touchMove(e) {\r\n        let dx = e.touches[0].clientX - this.x0,\r\n            dy = e.touches[0].clientY - this.y0,\r\n            ds = Math.pow(dx * dx + dy * dy, 0.5),\r\n            dt = (new Date().getTime()) - this.t0,\r\n            v1 = ds / dt; //同 this.v0 初始速率或touchmove事件间发生速率\r\n        if (this.keenness === 0) { //油墨为0时\r\n            this.ctx.moveTo(this.x0, this.y0)\r\n            this.ctx.lineTo(this.x0 + dx, this.y0 + dy)\r\n            this.ctx.setLineWidth(this.lineWidth)\r\n            this.ctx.stroke()\r\n            this.ctx.draw(true)\r\n        } else {\r\n            //由于touchMove的触发频率问题，这里采用for循环绘制，原理如图所示\r\n            //这里的k因为\r\n            let a = this.keenness\r\n            if (this.keenness > 5) {\r\n                a = 5\r\n            }\r\n            for (let i = 0; i < a; i++) {\r\n                this.ctx.moveTo(this.x0 + dx * i / a, this.y0 + dy * i / a)\r\n                this.ctx.lineTo(this.x0 + dx * (i + 1) / a, this.y0 + dy * (i + 1) / a)\r\n                //此时touchmove事件间发生与上一个事件的发生的速率比较\r\n                if (v1 < this.v0) {\r\n                    this.lineWidth -= this.k\r\n                    if (this.lineWidth < this.lineWidth * 0.25) this.lineWidth = this.lineWidth * 0.25\r\n                } else {\r\n                    this.lineWidth += this.k\r\n                    if (this.lineWidth > this.lineWidth * 1.5) this.lineWidth = this.lineWidth * 1.5\r\n                }\r\n                this.ctx.setLineWidth(this.lineWidth)\r\n                this.ctx.stroke()\r\n                this.ctx.draw(true)\r\n            }\r\n        }\r\n        this.x0 = e.touches[0].clientX\r\n        this.y0 = e.touches[0].clientY\r\n        this.t0 = new Date().getTime()\r\n        this.v0 = v1\r\n    },\r\n    touchEnd(e) {\r\n        this.x0 = 0\r\n        this.y0 = 0\r\n        this.t0 = 0\r\n        this.v0 = 0\r\n    }\r\n}\r\n}使用的大部分是canvas的基础api，注意绘制单位都为px。油墨电子签名Demo3-3、开放式海报模块如果说微信小程序是银色金滩，那么截至2020年1月6日或者未来，小程序的canvas就是金滩上充斥着未知数个的玻璃块的那一片 ——鲁迅说起小程序canvas，那bug不是一般的多，部分不常见bug我会在代码注释里说明。HTML<canvas canvas-id=\"generate\" :style=\"{ width: canvasW + 'rpx', height: canvasH + 'rpx'}\"></canvas>相关介绍spread 语法async 函数如果图片是网络路径，记得获取临时路径。//别忘了在函数前加 async\r\nlet src = 'https://s2.ax1x.com/2020/01/05/lrCDx0.jpg'\r\nsrc = (await uni.getImageInfo({src}))[1].path;JAVASCRIPT输出字段部分//为方便设置，以下除角度外，单位均以rpx为主\r\ndata() {\r\n    return {\r\n        canvasW:720,\r\n        canvasH:1000,\r\n        img:[{\r\n            src: 'https://s2.ax1x.com/2020/01/05/lrCDx0.jpg',\r\n            x: 0,\r\n            y: 0,\r\n            w: 100,\r\n            h: 100,\r\n            r: 50,//圆角度\r\n            degrees: 30,//旋转度\r\n            mirror: true//是否镜像\r\n            }],\r\n        text:[{\r\n                content: 'TensionMax',\r\n                x: 50,\r\n                y: 50,\r\n                w: 100,\r\n                lineHeight: 35,//行间距\r\n                color: '#000000',\r\n                size: 28,\r\n                weight: 'normal',//字体粗细\r\n                lineThrough: true,//是否贯穿\r\n            }],\r\n        ctx: null,\r\n        k: null //单位转换因子\r\n    };\r\n}JAVASCRIPTrpx 或 upx与 px 的单位统一转换方法px2rpx() {\r\n    //当转换的参数只有一个时直接返回数值如\r\n    //当不为一个时返回数组，然后用spread语法将其展开为几个参数\r\n    //Math.floor()是为了防止在安卓机上造成的数据紊乱，开发者工具无此bug\r\n    if (arguments.length === 1) return Math.floor(arguments[0] / this.k)\r\n    let params = []\r\n    for (let i of arguments) {\r\n        params.push(Math.floor(i / this.k))\r\n    }\r\n    return params\r\n},\r\nrpx2px() {\r\n    if (arguments.length === 1) return Math.floor(arguments[0] * this.k)\r\n    let params = []\r\n    for (let i of arguments) {\r\n        params.push(Math.floor(i * this.k))\r\n    }\r\n    return params\r\n},JAVASCRIPT绘制图片的函数async drawImg() {\r\nthis.ctx.setFillStyle('#FFFFFF')\r\nthis.ctx.fillRect(0, 0, ...this.rpx2px(this.canvasW, this.canvasH)) //绘制背景\r\nfor (let i of this.img) { //for循环绘制图片\r\n    i.src = (await uni.getImageInfo({src: i.src}))[1].path;//获取图片临时路径\r\n    this.ctx.save() //保存当前绘制内容\r\n    if (i.mirror) { //如果设置镜像\r\n        //因为canvas的translate属性是基于原点（初始原点为右上角）变化\r\n        //所以需要先将原点移动至图片中心，变化后再还原\r\n        //旋转变化同理\r\n        this.ctx.translate(...this.rpx2px(i.x + i.w / 2, i.y + i.h / 2))\r\n        this.ctx.scale(-1, 1)\r\n        this.ctx.translate(...this.rpx2px(-i.x - i.w / 2, -i.y - i.h / 2))\r\n    }\r\n    if (i.degrees) { //如果设置旋转\r\n        this.ctx.translate(...this.rpx2px(i.x + i.w / 2, i.y + i.h / 2))\r\n        this.ctx.rotate(i.degrees * Math.PI / 180)\r\n        this.ctx.translate(...this.rpx2px(-i.x - i.w / 2, -i.y - i.h / 2))\r\n    }\r\n    this.radiusRect(...this.rpx2px(i.x, i.y, i.w, i.h, i.r)) //圆角或矩形路径绘制\r\n    this.ctx.clip() //裁剪\r\n    this.ctx.drawImage(i.src, ...this.rpx2px(i.x, i.y, i.w, i.h))\r\n    this.ctx.restore() //恢复非裁剪区域\r\n}\r\nthis.ctx.draw(true) \r\n}\r\n\r\nradiusRect(x, y, w, h, r) {\r\n    if (r > w / 2 || r > h / 2) {\r\n        r = Math.min(w, h) / 2\r\n    }\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(x, y); // 将操作点移至左上角\r\n    this.ctx.arcTo(x + w, y, x + w, y + r, r); // 画右上角的弧\r\n    this.ctx.lineTo(x + w, y) //可省略，但由于安卓真机的小程序bug，留之，下同。\r\n    this.ctx.arcTo(x + w, y + h, x + w - r, y + h, r); // 画右下角的弧\r\n    this.ctx.lineTo(x + w, y + h) //可省略\r\n    this.ctx.arcTo(x, y + h, x, y + h - r, r); // 画左下角的弧\r\n    this.ctx.lineTo(x, y + h) //可省略\r\n    this.ctx.arcTo(x, y, x + r, y, r); // 画左上角的弧\r\n    this.ctx.lineTo(x, y) //可省略\r\n},绘制自定义文字文字绘制稍微麻烦些，主要是canvas不会自动帮我们换行排版，网上类似的实现方法太多，该篇就不讲，直接放在Demo里面。开放式海报Demo3-4、小结既然我们知道了这几个组件自定义调整参数的方式，那么最后只需要一个父组件作为控制台来调整他们的参数即可，可以通过 props 、 sync 修饰符 等来实现父子通信，当然如果想做更复杂的可以考虑用 Vuex 传参。接下来就可以根据这思路来实现繁琐的业务逻辑了。4、效果展示效果图如下，如果由什么疑问欢迎到下方评论区讨论。"}
{"title": "小程序、H5登录授权、分享、支付流程 ", "author": "Rolan", "pub_time": "2020-1-14 00:32", "content": "前言对于前端来说，微信的 支付 、 分享 、 登录 是一定要掌握的，今天这篇文章，主要对这三方面的流程进行详细的介绍。主要内容如下：域名相关知识介绍该网站不安全，请不要输入密码\r\n微信小程序授权登录流程op=>operation: openid判断是否登录授权\r\nop2=>operation: 根据wx.login获取code\r\nop3=>operation: 调用服务端根据code换取openid\r\nop4=>operation: 通过用户授权，获取信息，存到数据库\r\nop->op2->op3->op4\r\n复制代码如果你从来没有阅读过小程序登录授权的文档，建议你看一下下面的地址：服务端官方文档 客户端文档nodejs + 小程序实现授权登录前端部分根据本地是否有userId判断是否登录，如果没有登录，则获取用户的openidonLoad() {\r\n   if(!this.data.userId) {\r\n       this.getSession()\r\n   }\r\n},\r\n getSession() {\r\n   wx.login({\r\n     success: (res) => {\r\n       if (res.code) {\r\n         app.get(Api.getSession, {\r\n           code: res.code\r\n         }).then(res => {\r\n           store.setItem('openid', res.openid)\r\n         })\r\n       }\r\n     }\r\n   })\r\n }复制代码点击授权按钮，发起登录请求。getUserInfo(e) {\r\n    let userInfo = e.detail.userInfo;\r\n    userInfo.openid = store.getItem('openid')\r\n    app.get(Api.login, {\r\n        userInfo\r\n    }).then(res => {\r\n        store.setItem('userId', res.data.userId)\r\n        this.setData({\r\n            userId: res.userId\r\n        })\r\n    })\r\n}复制代码服务端部分在 config 里面，定义公用的 appid 和 appsecretmodule.exports = {\r\n    wx: {\r\n        appId: 'wx0ef10432747d8f57',\r\n        appsecret: 'cc47a6127687e999a1dffa756ff83c0e'\r\n    },\r\n    mp: {\r\n        appId: 'wx0691f1dcf6e5e231',\r\n        appSecret: 'c7ed875e338120f15f49476a6596eb4f'\r\n    }\r\n}复制代码然后通过调用小程序 官方文档 的接口，获取到 appid 传给客户端let express = require('express');\r\nlet router = express.Router();\r\nlet request = require('request');\r\nlet config = require('./config');\r\nlet uril = require('./../../util/index')\r\nconfig = Object.assign({}, config.mp);\r\n\r\nrouter.get('/getSession', (req, res) => {\r\n    let code = req.query.code\r\n    if (!code) {\r\n        res.json(uril.handleFail('code不能为空', 10001))\r\n    }\r\n    let sessionUrl = `https://api.weixin.qq.com/sns/jscode2session?appid=${config.appId}&secret=${config.appSecret}&js_code=${code}&grant_type=authorization_code`;\r\n    request(sessionUrl, (err, response, body) => {\r\n        let result = util.handleResponse(err, response, body)\r\n        res.json(result)\r\n    })\r\n})复制代码登录接口 的编写// 小程序授权登录\r\nrouter.get('/login',async function(req,res){\r\n  let userInfo = JSON.parse(req.query.userInfo);\r\n  if (!userInfo){\r\n    // 如果接口没有信息，则返回错误信息\r\n    res.json(util.handleFail('用户信息不能为空',10002))\r\n  }else{\r\n    // 查询当前用户是否已经注册\r\n    let userRes = await dao.query({ openid: userInfo.openid},'users_mp');\r\n    if (userRes.code == 0){\r\n      // 如果已经注册，直接把查出来的信息返回给客户端\r\n      if (userRes.data.length >0){\r\n        res.json(util.handleSuc({\r\n          userId: userRes.data[0]._id\r\n        }))\r\n      }else{\r\n        // 如果这个用户之前没有注册，则在数据库插入用户信息\r\n        let insertData = await dao.insert(userInfo,'users_mp');\r\n        if (insertData.code == 0){\r\n          let result = await dao.query({ openid: userInfo.openid }, 'users_mp');\r\n          res.json(util.handleSuc({\r\n            userId: result.data[0]._id\r\n          }))\r\n        }else{\r\n          res.json(insertData);\r\n        }\r\n      }\r\n    }else{\r\n      res.json(userRes);\r\n    }\r\n  }\r\n})复制代码上述代码的 handleFail 和 handleResponse 是封装的对数据的统一处理，如果有兴趣，参见 github 地址。这里不展示代码。需要注意的是，这种实现方式，获取 openid 的行为放在后端实现了。如果放在前端实现也可以，但是会相对比较麻烦一点。此时，suerId就已经在数据库存储，并且在本地保存了，下次登录的时候，如果有userId存在就不需要再次登录了。H5的登录授权和分享流程H5的登录授权略有不同。如果用户登录授权页面，发现该用户没有登录授权，则需要跳转到授权页面。 官方文档 给出的流程如下：1 第一步：用户同意授权，获取code2 第二步：通过code换取网页授权access_token3 第三步：刷新access_token（如果需要）4 第四步：拉取用户信息(需scope为 snsapi_userinfo)5 附：检验授权凭证（access_token）是否有效在项目中代码如下：(这里代码没有实现刷新access_token和拉取用户信息)页面加载的时候，判断是否已经授权。mounted(){\r\n   this.checkUserAuth();\r\n },\r\nmethods:{\r\n// 检查用户是否授权过\r\ncheckUserAuth(){\r\n  let openId = this.$cookie.get('openId');\r\n  if(!openId){\r\n    // 如果没有登录授权，则跳转到微信提供的跳转页面。\r\n    window.location.href = API.wechatRedirect;\r\n  }else{\r\n  // 如果用户已经授权，则调用获取微信配置信息接口\r\n    this.getWechatConfig();\r\n  }\r\n},复制代码API.wechatRedirect:wechatRedirect:'/api/wechat/redirect?url=http%3A%2F%2Fm.51purse.com%2F%23%2Findex&scope=snsapi_userinfo',复制代码「注意」url地址需要 encodeURIComponent 编码才可以。m.51purse.com 需要与你在微信公众号后台配置的 授权域名 一致！nodejs 对登录授权回调接口的实现主要是拿到客户端的请求参数，请求微信提供的 接口// 用户授权重定向\r\nrouter.get('/redirect',function (req,res) {\r\n  let redirectUrl = req.query.url, scope = req.query.scope, callback = 'http://m.51purse.com/api/wechat/getOpenId';\r\n  cache.put('redirectUrl', redirectUrl);\r\n  // 获取到客户端带过来的数据，请求微信接口\r\n  let authorizeUrl = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=${config.appId}&redirect_uri=${callback}&response_type=code&scope=${scope}&state=STATE#wechat_redirect`;\r\n  res.redirect(authorizeUrl);\r\n})\r\n复制代码当用户点击 确认授权 之后，会执行跳转 callbacl：http://m.51purse.com/api/wechat/getOpenId 。而这个接口也是node端实现的，具体内容如下：// 用code换取access_token的方法\r\nexports.getAccessToken = function(code){\r\n  let token_url = `https://api.weixin.qq.com/sns/oauth2/access_token?appid=${config.appId}&secret=${config.appSecret}&code=${code}&grant_type=authorization_code`;\r\n  return new Promise((resolve, reject) => {\r\n    request.get(token_url, function (err, response, body) {\r\n      let result = util.handleResponse(err, response, body);\r\n      resolve(result);\r\n    })\r\n  });\r\n}\r\n\r\n\r\n// 根据code获取用户的OpenId\r\nrouter.get('/getOpenId',async function(req,res){\r\n  let code = req.query.code;\r\n  console.log(\"code:\"+code);\r\n  if(!code){\r\n    res.json(util.handleFail('当前未获取到授权code码'));\r\n  }else{\r\n    // 用code换取access_token\r\n    let result = await common.getAccessToken(code);\r\n    if(result.code == 0){\r\n      // 换取access_token成功\r\n      let data = result.data;\r\n      let expire_time = 1000 * 60 * 60 * 2;\r\n      // 往客户端写入cookie：openId\r\n      res.cookie('openId', data.openid, { maxAge: expire_time });\r\n      let openId = data.openid;\r\n      let userRes = await dao.query({ 'openid': openId },'users');\r\n      if (userRes.code == 0){\r\n        if (userRes.data.length>0){\r\n          // 从数据库查找到用户信息后，回调到客户端的页面\r\n          let redirectUrl = cache.get('redirectUrl');\r\n          res.redirect(redirectUrl);\r\n        }else{\r\n          let userData = await common.getUserInfo(data.access_token, openId);\r\n          let insertData = await dao.insert(userData.data,'users');\r\n          if (insertData.code == 0){\r\n            // 从数据库查找到用户信息后，回调到客户端的页面\r\n            let redirectUrl = cache.get('redirectUrl');\r\n            res.redirect(redirectUrl);\r\n          }else{\r\n            // 返回错误信息\r\n            res.json(insertData);\r\n          }\r\n        }\r\n      }else{\r\n        // 返回错误信息\r\n        res.json(userRes);\r\n      }\r\n    }else{\r\n      // 返回错误信息\r\n      res.json(result);\r\n    }\r\n  }\r\n})\r\n复制代码「注意」：上面的代码为了简单，删除了一些不必要的代码，如有兴趣，访问gitHub。H5分享流程同样，如果你没有阅读过微信H5开发的 官方文档 ,建议你先阅读。关于分享，你应该阅读以下内容：当再次回调到页面的时候，从cookie已经拿到openId了。客户端会继续执行下面的代码。获取到服务端返回的配置信息，从而初始化分享的功能。在这之前，你需要 npm install wx-jssdk// 这个信息统一定义在api.js中，这里为了方便，放在前面，便于查看。\r\nAPI.wechatConfig: /api/wechat/jssdk\r\n\r\n\r\n// 获取微信配置信息\r\ngetWechatConfig(){\r\n  this.$http.get(API.wechatConfig+'?url='+location.href.split('#')[0]).then(function(response){\r\n    let res = response.data;\r\n    if(res.code == 0){\r\n      let data = res.data;\r\n      wx.config({\r\n        debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\r\n        appId: data.appId, // 必填，公众号的唯一标识\r\n        timestamp: data.timestamp, // 必填，生成签名的时间戳\r\n        nonceStr: data.nonceStr, // 必填，生成签名的随机串\r\n        signature: data.signature,// 必填，签名\r\n        jsApiList: data.jsApiList // 必填，需要使用的JS接口列表\r\n      })\r\n      wx.ready(()=>{\r\n        util.initShareInfo(wx);\r\n      })\r\n    }\r\n  })\r\n}复制代码util/index.js 里面对分享的功能进行了封装。export default {\r\n  //获取浏览器地址栏参数值\r\n  getUrlParam(name){\r\n    let reg = new RegExp('(^|&)'+name+'=([^&]*)');\r\n    let r = window.location.search.substr(1).match(reg);\r\n    if(r!=null)return decodeURIComponent(r[2]);\r\n  },\r\n  initShareInfo(wx){\r\n    let shareInfo = {\r\n      title: 'xxxx', // 分享标题\r\n      desc: 'xxxx', // 分享描述\r\n      link: 'http://m.51purse.com/#/index', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致\r\n      imgUrl: '', // 分享图标\r\n    }\r\n    wx.onMenuShareAppMessage(shareInfo);\r\n    wx.onMenuShareTimeline(shareInfo);\r\n    wx.onMenuShareQQ(shareInfo);\r\n    wx.onMenuShareQZone(shareInfo);\r\n    // 下面两种方法为新的方法,上面的方法将会被淘汰。\r\n    wx.updateAppMessageShareData(shareInfo);\r\n    wx.updateTimelineShareData(shareInfo);\r\n  }\r\n}\r\n复制代码nodejs端对 /wechat/jssdk 接口的实现如下：// common.getToken()方法 获取基础接口的Token\r\n\r\nexports.getToken = function(){\r\n  let token = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${config.appId}&secret=${config.appSecret}`;\r\n  return new Promise((resolve, reject)=>{\r\n    request.get(token, function (err, response, body) {\r\n      let result = util.handleResponse(err, response, body);\r\n      resolve(result);\r\n    })\r\n  })\r\n}\r\n----\r\n\r\nrouter.get('/jssdk',async function(req,res){\r\n  let url = req.query.url;\r\n  let result = await common.getToken();\r\n  if (result.code == 0){\r\n    let token = result.data.access_token;\r\n    let params = {\r\n      // 生成随机字符串\r\n      noncestr:util.createNonceStr(),\r\n      // 生成时间戳\r\n      timestamp:util.createTimeStamp(),\r\n      url\r\n    }\r\n      let str = util.raw(params);\r\n      console.log('str:::' + JSON.stringify(params))\r\n      let sign = createHash('sha1').update(str).digest('hex');\r\n      res.json(util.handleSuc({\r\n        appId: config.appId, // 必填，公众号的唯一标识\r\n        timestamp: params.timestamp, // 必填，生成签名的时间戳\r\n        nonceStr: params.noncestr, // 必填，生成签名的随机串\r\n        signature: sign,// 必填，签名\r\n        jsApiList: [\r\n          'updateAppMessageShareData',\r\n          'updateTimelineShareData',\r\n          'onMenuShareTimeline',\r\n          'onMenuShareAppMessage',\r\n          'onMenuShareQQ',\r\n          'onMenuShareQZone',\r\n          'chooseWXPay'\r\n        ] // 必填，需要使用的JS接口列表\r\n      }))\r\n    }\r\n  }else{\r\n    res.json(result);\r\n  }\r\n})复制代码以上代码主要获得基础的 token ,然后用基础 token 结合签名、时间戳、随机数等相关的参数，返回给客户端相应的参数。需要注意的是， 基础token 和 accessToken 的区别。建议 参考文章 。到此，微信H5接入jssdk实现分享就已经完成了。小程序支付小程序支付前端流程获取openId调起数字签名后端支付流程拼接常规参数生成签名拼接xml数据调用下单接口获取预支付Id：prepay_id生成支付sdk定义回调接口，接受微信支付消息支付的主要逻辑在服务端下面把服务端的流程通过代码的方式表述出来。首先在util中封装了一些支付需要的公共方法/**\r\n * 公共函数定义\r\n */\r\nlet createHash = require('create-hash');\r\nmodule.exports = {\r\n  // 生成随机数\r\n  createNonceStr(){\r\n    return Math.random().toString(36).substr(2,15);\r\n  },\r\n  // 生成时间戳\r\n  createTimeStamp(){\r\n    return parseInt(new Date().getTime() / 1000) + ''\r\n  },\r\n  // 生成签名\r\n  getSign(params, key){\r\n    let string = this.raw(params) + '&key=' + key;\r\n    let sign = createHash('md5').update(string).digest('hex');\r\n    return sign.toUpperCase();\r\n  },\r\n  // 生成系统的交易订单号\r\n  getTradeId(type='wx'){\r\n    let date = new Date().getTime().toString();\r\n    let text = '';\r\n    let possible = '0123456789';\r\n    for(let i=0;i<5;i++){\r\n      text += possible.charAt(Math.floor(Math.random() * possible.length))\r\n    }\r\n    return (type == 'wx'?'ImoocWxJuZi':'ImoocMpJuZi') + date + text;\r\n  },\r\n  // Object 转换成json并排序\r\n  raw(args){\r\n    let keys = Object.keys(args).sort();\r\n    let obj = {};\r\n    keys.forEach((key)=>{\r\n      obj[key] = args[key];\r\n    })\r\n    // {a:1,b:2} =>  &a=1&b=2\r\n    // 将对象转换为&分割的参数\r\n    let val = '';\r\n    for(let k in obj){\r\n      val += '&' + k + '=' +obj[k];\r\n    }\r\n    return val.substr(1);\r\n  }\r\n}复制代码下面是对支付的方法的封装，其中调用了util中的函数。客户端调用的就是下面的 order 方法。/**\r\n * 微信小程序、H5通用支付封装\r\n */\r\nlet config = require('./../pay/config')\r\nlet request = require('request')\r\nlet util = require('../../util/util')\r\nlet createHash = require('create-hash')\r\nlet xml = require('xml2js')\r\nconfig = config.mch;\r\nmodule.exports = {  \r\n  order: function (appid,attach, body, openid, total_fee, notify_url, ip){\r\n    return new Promise((resolve,reject)=>{\r\n      let nonce_str = util.createNonceStr();\r\n      let out_trade_no = util.getTradeId('mp');\r\n      // 支付前需要先获取支付签名\r\n      let sign = this.getPrePaySign(appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no);\r\n      // 通过参数和签名组装xml数据，用以调用统一下单接口\r\n      let sendData = this.wxSendData(appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no, sign);\r\n      let self = this;\r\n      let url = 'https://api.mch.weixin.qq.com/pay/unifiedorder';\r\n      request({\r\n        url,\r\n        method: 'POST',\r\n        body: sendData\r\n      }, function (err, response, body) {\r\n        if (!err && response.statusCode == 200) {\r\n          xml.parseString(body.toString('utf-8'),(error,res)=>{\r\n            if(!error){\r\n              let data = res.xml;\r\n              console.log('data:' + JSON.stringify(data));\r\n              if (data.return_code[0] == 'SUCCESS' && data.result_code[0] == 'SUCCESS'){\r\n                // 获取预支付的ID\r\n                let prepay_id = data.prepay_id || [];\r\n                let payResult = self.getPayParams(appid, prepay_id[0]);\r\n                resolve(payResult);\r\n              }\r\n            }\r\n          })\r\n        } else {\r\n          resolve(util.handleFail(err));\r\n        }\r\n      })\r\n    })\r\n  },\r\n  // 生成预支付的签名\r\n  getPrePaySign: function (appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no) {\r\n    let params = {\r\n      appid,\r\n      attach,\r\n      body,\r\n      mch_id: config.mch_id,\r\n      nonce_str,\r\n      notify_url,\r\n      openid,\r\n      out_trade_no,\r\n      spbill_create_ip: ip,\r\n      total_fee,\r\n      trade_type: 'JSAPI'\r\n    }\r\n    let string = util.raw(params) + '&key=' + config.key;\r\n    let sign = createHash('md5').update(string).digest('hex');\r\n    return sign.toUpperCase();\r\n  },\r\n  // 签名成功后 ，根据参数拼接组装XML格式的数据，调用下单接口\r\n  wxSendData: function (appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no,sign) {\r\n    let data = '<xml>' + \r\n      '<appid><![CDATA[' + appid + ']]></appid>' + \r\n      '<attach><![CDATA[' + attach + ']]></attach>' + \r\n      '<body><![CDATA[' + body + ']]></body>' + \r\n      '<mch_id><![CDATA[' + config.mch_id + ']]></mch_id>' + \r\n      '<nonce_str><![CDATA[' + nonce_str + ']]></nonce_str>' + \r\n      '<notify_url><![CDATA[' + notify_url + ']]></notify_url>' + \r\n      '<openid><![CDATA[' + openid + ']]></openid>' + \r\n      '<out_trade_no><![CDATA[' + out_trade_no + ']]></out_trade_no>' + \r\n      '<spbill_create_ip><![CDATA[' + ip + ']]></spbill_create_ip>' + \r\n      '<total_fee><![CDATA[' + total_fee + ']]></total_fee>' + \r\n      '<trade_type><![CDATA[JSAPI]]></trade_type>' + \r\n      '<sign><![CDATA['+sign+']]></sign>' + \r\n    '</xml>'\r\n    return data;\r\n  },\r\n  getPayParams:function(appId,prepay_id){\r\n    let params = {\r\n      appId,\r\n      timeStamp:util.createTimeStamp(),\r\n      nonceStr:util.createNonceStr(),\r\n      package: 'prepay_id=' + prepay_id,\r\n      signType:'MD5'\r\n    }\r\n    let paySign = util.getSign(params,config.key);\r\n    params.paySign = paySign;\r\n    return params;\r\n  }\r\n}复制代码最后定义 /pay/payWallet 的支付接口，里面调用公用的order方法。// 小程序支付\r\nrouter.get('/pay/payWallet',function(req,res){\r\n  let openId = req.query.openId;//用户的openid\r\n  let appId = config.appId;//应用的ID\r\n  let attach = \"小程序支付课程体验\";//附加数据\r\n  let body = \"欢迎学习慕课首门支付专项课程\";//支付主体内容\r\n  let total_fee = req.query.money;//支付总金额\r\n  let notify_url = \"http://localhost:3000/api/mp/pay/callback\"\r\n  let ip = \"123.57.2.144\";\r\n  wxpay.order(appId,attach,body,openId,total_fee,notify_url,ip).then((result)=>{\r\n    res.json(util.handleSuc(result));\r\n  }).catch((result)=>{\r\n    res.json(util.handleFail(result.toString()))\r\n  });\r\n})复制代码这里的流程请参见 官方描述 。官方描述的非常清楚，这儿就不描述更多了，其实主要就是拼接一些参数，获取 签名 。然后根据签名加上其他需要的 参数 (参见上述代码)再凭借xml的数据。然后再调用统一下单接口 https://api.mch.weixin.qq.com/pay/unifiedorder 。生成 prepay_id之后，生成小程序端需要的一些参数，然后把这些参数返回个小程序客户端，供小程序的客户端调用微信小程序的支付功能。小程序前端支付非常简单，只是简单的调用服务端提供的 payWallet 接口，传入 openId 和 money 即可。然后获取到相应的参数，调用微信提供的 requestPayment 拉起支付即可。主要代码逻辑如下：pay() {\r\n    app.get(Api.payWallet,{\r\n      openId: Store.getItem('openId'),\r\n      money: this.data.index\r\n    }).then((res) => {\r\n      // 支付\r\n      wx.requestPayment({\r\n        timeStamp: res.timeStamp,\r\n        nonceStr: res.nonceStr,\r\n        package: res.package,\r\n        signType: res.signType,\r\n        paySign: res.paySign,\r\n        success: function (errmsg) {\r\n          if (errmsg == 'requestPayment:ok') {\r\n            wx.showToast({\r\n              title: '支付成功',\r\n              icon: 'success'\r\n            });\r\n          }\r\n        },\r\n        fail: function (res) {\r\n          if (res.errMsg == 'requestPayment:fail cancel') {\r\n            wx.showToast({\r\n              title: '支付取消',\r\n              icon: 'none'\r\n            });\r\n          } else {\r\n            wx.showToast({\r\n              title: res.errmsg,\r\n              icon: 'none'\r\n            });\r\n          }\r\n        }\r\n      })\r\n    });\r\n  }\r\n复制代码到这里，小程序端的支付功能就已经实现了。"}
{"title": "微信小程序加入购物车动画的实现（向上、向下） ", "author": "Rolan", "pub_time": "2020-1-14 00:42", "content": "场景描述：一般情况下，加入购物车的动画效果都会是上图的3的路线，在这篇文章里，我们来实现1和2路线的加入购物车的动效（3路线的动画效果网上有很多，具体可以参考这篇文章来实现： www.cnblogs.com/greengage/p… ）。实现方式：不管是上图中的哪一种效果，我们都是用CSS3里的cubic-bezier（三次贝塞尔曲线）来实现的。具体什么是三次贝塞尔曲线，可以参考这篇文章： www.bbsmax.com/A/RnJWwpbRJ…#实现流程：1、获取屏幕的高度大小wx.getSystemInfo({//  获取页面的有关信息\r\n      success: function (res) {\r\n        wx.setStorageSync('systemInfo', res)\r\n        var ww = res.windowWidth;\r\n        var hh = res.windowHeight;\r\n        that.globalData.ww = ww;\r\n        that.globalData.hh = hh;\r\n      }\r\n    });\r\n复制代码2、获取点击的位置（购物车的位置我们定为最上方或者最下方），定义移动距离/*加入购物车动效*/\r\n  _flyToCartEffect: function (events) {\r\n    //获得当前点击的位置，距离可视区域左上角\r\n    var touches = events.touches[0];\r\n    var diff = {\r\n      x: '25px',\r\n      y: app.globalData.hh -touches.clientY-40 + 'px'//向下\r\n      // y: 25- touches.clientY  + 'px'//向上\r\n\r\n    },\r\n      style = 'display: block;-webkit-transform:translate(' + diff.x + ',' + diff.y + ') rotate(350deg) scale(0)';  //移动距离\r\n    this.setData({\r\n      isFly: true,\r\n      translateStyle: style\r\n    });\r\n    var that = this;\r\n    setTimeout(() => {\r\n      that.setData({\r\n        isFly: false,\r\n        translateStyle: '-webkit-transform: none;',  //恢复到最初状态\r\n        isShake: true,\r\n      });\r\n      setTimeout(() => {\r\n        var counts = that.data.cartTotalCounts + that.data.productCounts;\r\n        that.setData({\r\n          isShake: false,\r\n          cartTotalCounts: counts\r\n        });\r\n      }, 200);\r\n    }, 1000);\r\n  },\r\n复制代码3、在css里调用beizer函数.fiexd-cart.animate{\r\n  animation: aCartScale 200ms cubic-bezier(.17,.67,.83,.67);\r\n  animation-fill-mode: backwards;\r\n}\r\n复制代码aCartScale是，在曲线的最后，实现了个购物车抖动的动画@-webkit-keyframes aCartScale{\r\n  0%{\r\n    -webkit-transform: scale(1.1);\r\n  }\r\n  100% {\r\n    -webkit-transform: scale(1);\r\n  }\r\n}\r\n复制代码至此，流程全部介绍完毕，下面是全部的代码（里面可能有一些没用的css样式代码，读者可以自行根据需要删除）：js代码：var app = getApp();\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    isFly:false\r\n  },\r\n\r\n  /*添加到购物车*/\r\n  onAddingToCartTap: function (events) {\r\n    //防止快速点击\r\n    if (this.data.isFly) {\r\n      return;\r\n    }\r\n    this._flyToCartEffect(events);\r\n  },\r\n  /*加入购物车动效*/\r\n  _flyToCartEffect: function (events) {\r\n    //获得当前点击的位置，距离可视区域左上角\r\n    var touches = events.touches[0];\r\n    var diff = {\r\n      x: '25px',\r\n      y: app.globalData.hh -touches.clientY-40 + 'px'//向下\r\n      // y: 25- touches.clientY  + 'px'//向上\r\n\r\n    },\r\n      style = 'display: block;-webkit-transform:translate(' + diff.x + ',' + diff.y + ') rotate(350deg) scale(0)';  //移动距离\r\n    this.setData({\r\n      isFly: true,\r\n      translateStyle: style\r\n    });\r\n    var that = this;\r\n    setTimeout(() => {\r\n      that.setData({\r\n        isFly: false,\r\n        translateStyle: '-webkit-transform: none;',  //恢复到最初状态\r\n        isShake: true,\r\n      });\r\n      setTimeout(() => {\r\n        var counts = that.data.cartTotalCounts + that.data.productCounts;\r\n        that.setData({\r\n          isShake: false,\r\n          cartTotalCounts: counts\r\n        });\r\n      }, 200);\r\n    }, 1000);\r\n  },\r\n\r\n})\r\n复制代码wxml代码：<view class=\"container detail-container\">\r\n  <view class=\"fixed-btns-box\" bindtap=\"onCartTap\">\r\n    <view class=\"fiexd-cart {{isShake?'animate':''}}\">\r\n      <image src=\"../../imgs/icon/cart@top.png\"></image>\r\n      <view wx:if=\"{{cartTotalCounts>0}}\">{{cartTotalCounts}}</view>\r\n    </view>\r\n  </view>\r\n\r\n  <view \r\n  style=\"position: fixed;right: 50rpx;bottom:100rpx;width: 100rpx;\"\r\n  class=\"add-cart-btn {{product.stock==0?'disabled':''}}\" bindtap=\"onAddingToCartTap\">\r\n    <text style=\"width: 360rpx\">加入分享</text>\r\n    <image class=\"cart-icon\" src=\"../../imgs/icon/cart.png\"></image>\r\n    <image id=\"small-top-img\" class=\"small-top-img {{isFly?'animate':''}}\" src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1575871576&di=dda9d07660c88bea6553c3279b0a8cf0&imgtype=jpg&er=1&src=http%3A%2F%2Fpic.pc6.com%2Fup%2F2011-9%2F2011926155953.jpg\"\r\n      mode=\"aspectFill\" style=\"{{translateStyle}}\"></image>\r\n  </view>\r\n\r\n\r\n  \r\n\r\n  <view class=\"fixed-btns-box2\" bindtap=\"onCartTap\">\r\n    <view class=\"fiexd-cart {{isShake?'animate':''}}\">\r\n      <image src=\"../../imgs/icon/cart@top.png\"></image>\r\n      <view wx:if=\"{{cartTotalCounts>0}}\">{{cartTotalCounts}}</view>\r\n    </view>\r\n  </view>\r\n\r\n</view>\r\n复制代码wxss代码：.detail-container {\r\n  background-color:#F9F9F9\r\n}\r\n.detail-header-box,.detail-bottom-box{\r\n  background-color: #fff;\r\n}\r\n.detail-topic-img{\r\n  display: flex;\r\n  justify-content: center;\r\n}\r\n.detail-topic-img image{\r\n  width: 100%;\r\n}\r\n\r\n.fixed-btns-box{\r\n  position: fixed;\r\n  top:50rpx;\r\n  right:12px;\r\n  width: 80rpx;\r\n\r\n}\r\n.fixed-btns-box2{\r\n  position: fixed;\r\n  right:12px;\r\n  width: 80rpx;\r\n  bottom: 50rpx;\r\n\r\n}\r\n.fiexd-cart image{\r\n  height: 64rpx;\r\n  width: 64rpx;\r\n}\r\n.fiexd-cart view{\r\n  font-size: 24rpx;\r\n  background-color: #AB956D;\r\n  color: white;\r\n  position: absolute;\r\n  right: 64rpx;\r\n  top: 0rpx;\r\n  height: 36rpx;\r\n  width: 36rpx;\r\n  line-height: 36rpx;\r\n  border-radius: 36rpx;\r\n  text-align: center;\r\n}\r\n.fiexd-cart.animate{\r\n  animation: aCartScale 200ms cubic-bezier(.17,.67,.83,.67);\r\n  animation-fill-mode: backwards;\r\n}\r\n\r\n@-webkit-keyframes aCartScale{\r\n  0%{\r\n    -webkit-transform: scale(1.1);\r\n  }\r\n  100% {\r\n    -webkit-transform: scale(1);\r\n  }\r\n}\r\n\r\n\r\n\r\n.product-counts,.add-cart-btn{\r\n  height: 100%;\r\n  display: flex;\r\n  font-size: 24rpx;\r\n  align-items: center;\r\n  justify-content: center;\r\n}\r\n.product-counts{\r\n  width: 50%;\r\n}\r\n.add-cart-btn{\r\n  position: relative;\r\n  flex: 1;\r\n}\r\n.add-cart-btn:active{\r\n  color: #fff;\r\n}\r\n.add-cart-btn.disabled{\r\n  color: #D5D5DB;\r\n}\r\n\r\n\r\n\r\n.small-top-img{\r\n  height: 160rpx;\r\n  width: 160rpx;\r\n  right:6rpx;\r\n  position: absolute;\r\n  opacity: 0;\r\n}\r\n.small-top-img.animate{\r\n  opacity: 1;\r\n  -webkit-transition:all 1000ms cubic-bezier(0.175, 0.885, 0.32, 1.275);\r\n}\r\n\r\n\r\n\r\n\r\n.add-cart-btn .cart-icon{\r\n  margin-left: 40rpx;\r\n  height: 32rpx;\r\n  width: 32rpx;\r\n}\r\n\r\n\r\n.disabled{\r\n    pointer-events: none;\r\n}\r\n\r\n复制代码"}
{"title": "小程序 canvas 生成海报 - 解决屏幕图片失真，解决无法使用外网图片 ... ", "author": "Rolan", "pub_time": "2019-9-30 00:58", "content": "源代码在最下方\r\n\r\n最终结果\r\n\r\n\r\ncanvas（画布） 元素用于在网页上绘制图形。画布是一个矩形区域，您可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。\r\n\r\n注意\r\n需要注意的是，目前的canvas可以简单分为两种。一种是传统网页中的canvas，一种是小程序中的canvas。两者的功能是完全一样的。只是标签的样式，和 api 略有区别而已。目前我们主要讲解小程序中的canvas。\r\ncanvas 的应用场景\r\n\r\n\r\n在线游戏\r\n\r\n\r\n在线图表\r\n\r\n\r\n页面特效\r\n\r\n\r\n广告\r\n\r\n\r\n图片合成 小程序中常见\r\n\r\n\r\n点我加速\r\n\r\n\r\n\r\n头像红旗\r\n\r\n\r\n\r\n\r\n海报日历\r\n\r\n\r\n\r\n其他\r\n\r\n\r\n\r\n   \r\n\r\n\r\n简单体验\r\n\r\n我们来画一条直线\r\n\r\n在canvas中，把画直线的步骤分解为以下几步：\r\n\r\n编写标签\r\n获取画布实例\r\n定起点\r\n连接终点\r\n连线 （也叫描边）\r\n上色\r\n\r\n编写标签\r\n\r\n默认的宽高 为 300px * 150 px\r\n不同于普通的标签，必须要提供一个属性 canvas-id，用于在 js中获取该对象（不是dom对象！！！）\r\n\r\n<canvas canvas-id=\"firstCanvas\"></canvas>\r\n复制代码获取画布实例\r\n\r\n通过 canvas-id 来获取\r\n该实例 不是dom元素，可以理解为另一种对象如 Math Date String等即可\r\n\r\nindex.js\r\nPage({\r\n  onLoad() {\r\n    // 1 获取画布上下文对象\r\n    const context = wx.createCanvasContext(\"firstCanvas\");\r\n    console.log(context);\r\n  }\r\n})\r\n复制代码点起点\r\n在canvas中，存在一个坐标系 如下图：\r\n\r\n我们在canvas中所讲的坐标都是相对于canvas内部坐标而言\r\n\r\n\r\n定个起点\r\n    // 定起点\r\n    context.moveTo(10, 10);\r\n复制代码定终点\r\n\t// 定终点\r\n\tcontext.lineTo(300,150);\r\n复制代码连线\r\n\t// 连线\r\n    context.stroke();\r\n复制代码上色\r\n    // 上色\r\n    context.draw();\r\n复制代码完整代码\r\nindex.wxml\r\n<!-- 1 写标签 -->\r\n<canvas canvas-id=\"firstCanvas\"></canvas>\r\n复制代码index.js\r\nPage({\r\n  onLoad() {\r\n    // 2 获取画布上下文对象\r\n    const context = wx.createCanvasContext(\"firstCanvas\");\r\n    // 3 定起点\r\n    context.moveTo(10, 10);\r\n    // 4 定终点\r\n    context.lineTo(300,150);\r\n    // 5 连线\r\n    context.stroke();\r\n    // 6 上色\r\n    context.draw();\r\n  }\r\n})\r\n复制代码效果\r\n\r\n内置的其他规则图形\r\ncanvas中还封装了画规则图形的方法，如：\r\n\r\n\r\n画空心的矩形\r\n\r\n\r\n画圆弧\r\n\r\n\r\n画实心的矩形\r\n\r\n\r\n画文字（把字符串画上去）\r\n\r\n\r\n画矩形\r\n\r\nCanvasContext.strokeRect(number x, number y, number width, number height)\r\n\r\n\r\nCanvasContext.strokeRect(画在画布的X,画在画布的Y,画多宽，画多高)\r\n\r\n    // 1 获取画布上下文对象\r\n    const context = wx.createCanvasContext(\"firstCanvas\");\r\n    // 2 调用canvas内置的画“矩形”的方法\r\n    context.strokeRect(10, 10, 100, 100);\r\n    // 3 上色 \r\n    context.draw();\r\n复制代码效果\r\n\r\n画圆弧\r\n\r\nCanvasContext.arc(number x, number y, number r, number sAngle, number eAngle, boolean counterclockwise)\r\n\r\n\r\nCanvasContext.arc(圆心的横坐标X,圆心的纵坐标Y, 半径的长度, 开始的弧度, 结束的弧度, ？是否反向来画)\r\n\r\n代码\r\n  drawArc() {\r\n    // 1 获取画布上下文对象\r\n    const context = wx.createCanvasContext(\"firstCanvas\");\r\n    // context.arc(圆心的横坐标X,圆心的纵坐标Y, 半径的长度, 开始的弧度, 结束的弧度);\r\n    // 2 调用内置的画 “圆弧” 的方法\r\n    context.arc(100, 100, 100, this.angleToArc(0), this.angleToArc(90));\r\n    // 3 开始描边\r\n    context.stroke();\r\n    // 4 上色\r\n    context.draw();\r\n  },\r\n  /**\r\n   * 将角度转为弧度\r\n   * @param {number} angle 角度\r\n   */\r\n  angleToArc(angle) {\r\n    return angle * Math.PI / 180;\r\n  }\r\n复制代码效果\r\n\r\n画实心的矩形\r\n\r\nCanvasContext.fillRect(number x, number y, number width, number height)\r\n\r\n    // 1 获取画布上下文对象\r\n    const context = wx.createCanvasContext(\"firstCanvas\");\r\n    // 2 调用canvas内置的 画填充 “矩形”的方法\r\n    context.fillRect(10, 10, 100, 100);\r\n    // 3 上色 \r\n    context.draw();\r\n复制代码效果\r\n\r\n画文字\r\n\r\nCanvasContext.strokeText(string text, number x, number y, number maxWidth)\r\n\r\n\r\nCanvasContext.strokeText(要绘制的文本, 文本起始点的 x 轴坐标, number y, 需要绘制的最大宽度，可选)\r\n\r\n代码\r\n    // 1 获取画布上下文对象\r\n    const context = wx.createCanvasContext(\"firstCanvas\");\r\n    // 2 画 “文字”\r\n    context.strokeText(\"hello world\", 100, 100);\r\n    // 3 上色 \r\n    context.draw();\r\n复制代码效果\r\n\r\n\r\n设置样式\r\n经过以上的演示我们也发现，线条的颜色一直是黑色，这肯定是无法满足我们骚跳的心的。现在来学习一下关于设置canvas线条样式相关API。\r\n\r\n设置线条颜色\r\n设置线条粗细\r\n设置填充颜色\r\n设置文本大小\r\n\r\n设置线条颜色\r\n**特别要注意 **，setStrokeStyle是个函数，1.9.90版本后停止维护，使用以下的方式来修改。\r\n\r\nCanvasContext.setStrokeStyle(\"red\") 已过时，不推荐\r\nCanvasContext.strokeStyle=\"red\";  正解\r\n\r\n代码\r\n    const context = wx.createCanvasContext(\"firstCanvas\");\r\n    context.moveTo(10, 10);\r\n    context.lineTo(300, 150);\r\n    // 5 修改颜色 需要在stroke之前修改\r\n    context.strokeStyle = \"red\";\r\n    context.stroke();\r\n    context.draw();\r\n复制代码效果\r\n\r\n\r\n设置线条粗细\r\n**特别要注意 **，setLineWidth 是个函数，1.9.90版本后停止维护，使用以下的方式来修改。\r\n\r\nCanvasContext.setLineWidth(20) 已过时，不推荐\r\nCanvasContext.lineWidth=20;  正解\r\n\r\n代码\r\n    const context = wx.createCanvasContext(\"firstCanvas\");\r\n    context.moveTo(10, 10);\r\n    context.lineTo(300, 150);\r\n    // 设置线条宽度\r\n    context.lineWidth = 20;\r\n    context.stroke();\r\n    context.draw();\r\n复制代码效果\r\n\r\n\r\n设置填充颜色\r\n**特别要注意 **，setFillStyle 是个函数，1.9.90版本后停止维护，使用以下的方式来修改。\r\n\r\nCanvasContext.setFillStyle(\"red\") 已过时，不推荐\r\nCanvasContext.fillStyle=\"red\";  正解\r\n\r\n代码\r\n    const context = wx.createCanvasContext(\"firstCanvas\");\r\n    // 设置填充颜色\r\n    context.fillStyle = \"red\";\r\n    context.fillRect(10, 10, 100, 100);\r\n    context.draw();\r\n复制代码效果\r\n\r\n\r\n设置文本大小\r\n**特别要注意 **，setFontSize 是个函数，1.9.90版本后停止维护，使用以下的方式来修改。\r\n\r\nCanvasContext.setFontSize(\"20\") 已过时，不推荐\r\nCanvasContext.font=\"sans-serif\";  正解\r\nfont 当前字体样式的属性。符合 CSS font 语法 的 DOMString 字符串，至少需要提供字体大小和字体族名。默认值为 10px sans-serif。\r\n\r\n代码\r\n    const context = wx.createCanvasContext(\"firstCanvas\");\r\n    // 必须要同时提供 字号 和 字体\r\n    context.font=\"10px  sans-serif\";\r\n    context.strokeText(\"10px\", 10, 10);\r\n    // 必须要同时提供 字号 和 字体\r\n    context.font=\"50px  sans-serif\";\r\n    context.strokeText(\"50px\", 50, 100);\r\n    // 必须要同时提供 字号 和 字体\r\n    context.font=\"80px  sans-serif\";\r\n    context.strokeText(\"80px\", 80, 180);\r\n    context.draw();\r\n复制代码效果\r\n\r\n进阶\r\n\r\n在本环节主要讲解稍微复杂一点的功能。要实现以下功能\r\n但是需要先做一点技术铺垫\r\n\r\n主要用到的api有：\r\n\r\n获取系统信息\r\n选择相册图片\r\n获取网络图片信息\r\ncanvas 描绘 图片到画布上\r\n将画布保存成一张图片\r\n将图片下载到本地\r\n\r\n基本API\r\n\r\n以下api是实现以上案例所必须的\r\n\r\n获取系统信息\r\n\r\n获取屏幕大小、设备像素比等\r\n\r\n代码\r\nwx.getSystemInfo({\r\n  success (res) {\r\n    console.log(res.model)\r\n    console.log(res.pixelRatio)\r\n    console.log(res.windowWidth)\r\n    console.log(res.windowHeight)\r\n    console.log(res.language)\r\n    console.log(res.version)\r\n    console.log(res.platform)\r\n  }\r\n})\r\n复制代码选择相册图片\r\n\r\n从本地相册选择图片或使用相机拍照\r\n\r\n代码\r\nwx.chooseImage({\r\n  count: 1,// 最多可以选择的图片张数\r\n  sizeType: ['original', 'compressed'],// 所选的图片的尺寸\r\n  sourceType: ['album', 'camera'],//  选择图片的来源\r\n  success (res) {\r\n    // tempFilePath可以作为img标签的src属性显示图片\r\n    const tempFilePaths = res.tempFilePaths\r\n  }\r\n})\r\n复制代码代码\r\nwx.getSystemInfo({\r\n  success (res) {\r\n    console.log(res.model)\r\n    console.log(res.pixelRatio)\r\n    console.log(res.windowWidth)\r\n    console.log(res.windowHeight)\r\n    console.log(res.language)\r\n    console.log(res.version)\r\n    console.log(res.platform)\r\n  }\r\n})\r\n复制代码获取网络图片信息\r\n获取图片信息。网络图片需先配置download域名才能生效。\r\n\r\ncanvas提供了将图片画到画布上的功能，但是要求所提供的图片必须是外网下的图片\r\n因此可以借助该方法将网络图片变成本地图片，同时返回该图片的信息\r\n\r\n代码\r\nwx.getImageInfo({\r\n  src: 'cloud://c-73e071.632d-c-73e071/92637.jpg',\r\n  success (res) {\r\n    console.log(res.width)\r\n    console.log(res.height)\r\n  }\r\n})\r\n复制代码绘制图像到画布\r\n\r\n不能使用本地图片，要使用外网图片的 必须要先 使用 wx.getImageInfo 下载到本地\r\n\r\n有三个版本的写法：\r\n\r\ndrawImage(imageResource, dx, dy)\r\ndrawImage(imageResource, dx, dy, dWidth, dHeight)\r\ndrawImage(imageResource, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)\r\n说明drawImage(图片路径, 原图的x, 原图的y, 原图的宽度, 原图的高度, 画布的x, 画布的y, 画多宽, 画多高)\r\n\r\n代码\r\ncontext.drawImage('xxxx.jpg', 0, 0,100, 100);\r\n复制代码将画布保存成一张图片\r\n\r\n在 draw() 回调里调用该方法才能保证图片导出成功\r\n\r\n代码\r\nwx.canvasToTempFilePath({\r\n  x: 100,\r\n  y: 200,\r\n  width: 50,\r\n  height: 50,\r\n  destWidth: 100,\r\n  destHeight: 100,\r\n  canvasId: 'myCanvas',\r\n  success(res) {\r\n    console.log(res.tempFilePath)\r\n  }\r\n})\r\n复制代码将图片下载到本地\r\n保存图片到系统相册\r\n代码\r\nwx.saveImageToPhotosAlbum({\r\n  success(res) { }\r\n})\r\n复制代码案例实现\r\n其实要实现一样案例，最麻烦的不是这些API的调用，而是如何根据不同的图片，合成比例合适的 不模糊的图片；\r\n为什么说比例合适\r\n因为在canvas中，只支持 px 单位，那么在使用javascript来描绘图片时，就不存在 rpx、vw、%这些相对单位了。只能依靠手动来计算。如，在 canvas中，画出一个大小为 屏幕宽的一半 屏幕高的一半的矩形？\r\n为什么说不模糊\r\n问题的原因还是因为 手机的屏幕 都是高清屏，具体的原因可以参照 链接\r\n如我们想要生成图片大小为 100px * 100px，那么就需要将 canvas的大小设置为 width = 图片的宽度 * 设备像素比\r\nheight = 图片的高度 * 设备像素比\r\n文件目录\r\n\r\nindex 首页\r\nresult 合成图片的页面\r\n\r\n\r\n首页 index\r\nindex\r\n\r\npages/index/index.wxml\r\n<!-- 用来显示 被选择的图片的 -->\r\n<image mode=\"widthFix\" src=\"{{src}}\"></image>\r\n<!-- 选择相册图片 -->\r\n<button bindtap=\"handleTap\">选择图片</button>\r\n<!-- 跳转到 结果页面 -->\r\n<button bindtap=\"handleCreateFlag\">生成小红旗</button>\r\n复制代码pages/index/index.js\r\n主要实现3个功能\r\n\r\n点击 “选择图片” 将选择的图片打印到页面上\r\n将被 选择的图片 显示的页面上\r\n点击 “生成红旗”，跳转到结果页面（在结果页面完成生成）\r\n\r\nPage({\r\n  data: {\r\n    src: \"\"\r\n  },\r\n  // 选择图片\r\n  handleTap() {\r\n    wx.chooseImage({\r\n      count: 1,\r\n      sizeType: ['original', 'compressed'],\r\n      sourceType: ['album', 'camera'],\r\n      success: (result) => {\r\n        this.setData({\r\n          src: result.tempFilePaths[0]\r\n        })\r\n        // 保存图片路径\r\n        wx.setStorageSync('src', this.data.src);\r\n      }\r\n    });\r\n  },\r\n  // 生成红旗\r\n  handleCreateFlag() {\r\n    // 跳转到结果页面\r\n    wx.navigateTo({\r\n      url: '/pages/result/index'\r\n    });\r\n  }\r\n})\r\n复制代码结果页面 result\r\nresult\r\n\r\nresult/index.wxml\r\n3个标签\r\n\r\ncanvas 标签，通过定位将其隐藏\r\nimage 标签，用来显示合成的图片\r\nbutton 标签，用来点击 下载图片\r\n\r\n<!-- canvas 标签-->\r\n<canvas class=\"cas\" style=\"width:{{canvasWidth}};height:{{canvasHeight}};\" canvas-id=\"firstCanvas\"></canvas>\r\n<!-- 用来显示 合成成功的图片 -->\r\n<image class=\"res_image\" mode=\"widthFix\" src=\"{{resSrc}}\"></image>\r\n<!-- 点击下载图片 -->\r\n<button bindtap=\"handleSave\">下载图片</button>\r\n复制代码result/index.wxss\r\n两个样式\r\n\r\n把canvas藏起来（因为是 原生组件，所以它的层级比一般的标签都要高（定位+zindex也无法解决））\r\n设置图片标签的样式\r\n\r\npage {\r\n  overflow-x: hidden;\r\n  overflow-y: auto;\r\n  width: 100vw;\r\n  height: 100vh;\r\n}\r\n.cas {\r\n  position: absolute;\r\n  top: 1000vw;\r\n  left: 1000vh;\r\n  z-index: -1;\r\n  opacity: 0;\r\n}\r\n.res_image {\r\n  width: 100%;\r\n  display: block;\r\n}\r\n\r\n复制代码result/index.js\r\n易错点：\r\n\r\n外网的图片，需要先将图片服务器添加到白名单中（否则真机调试会失败）\r\n没有动态设置 canvas的宽和高（参照第29、31行）\r\n\r\n\r\nimport regeneratorRuntime from '../../lib/runtime/runtime';\r\nimport { getImageInfo, canvasToTempFilePath, saveImageToPhotosAlbum } from \"../../wxAsync/index.js\";\r\nPage({\r\n  data: {\r\n    // 默认的canvas的宽度\r\n    canvasWidth: 1,\r\n    // 默认的canvas高度\r\n    canvasHeight: 1,\r\n    // 最终生成的图片路径\r\n    resSrc: \"\"\r\n  },\r\n  // 全局变量\r\n  saveImgSrc: \"\",\r\n  async onLoad() {\r\n    // 红旗图片\r\n    const flagSrc = \"https://632d-c-73e071-1252056196.tcb.qcloud.la/3434.jpg?sign=a4f1c2106d1e61551829c2f99820c0ba&t=1569678566\";\r\n    // const baseSrc = \"https://632d-c-73e071-1252056196.tcb.qcloud.la/92637.jpg?sign=8952d1eaa69a35510418fe25dc25d6c5&t=1569678606\";\r\n    // 上个页面选择的图片路径 柯南图片\r\n    const baseSrc = wx.getStorageSync(\"src\");\r\n    // 设备像素比\r\n    const { pixelRatio } = wx.getSystemInfoSync();\r\n\r\n    // 获取 画布实例\r\n    const context = wx.createCanvasContext('firstCanvas');\r\n    console.log(context);\r\n    // 下载到本地的 柯南图片\r\n    const baseImg = await getImageInfo(baseSrc);\r\n    // 下载到本地的 红旗图片\r\n    const flagImg = await getImageInfo(flagSrc);\r\n    // 将canvas的宽度设置中 图片的宽度\r\n    const canvasWidth = baseImg.width + \"px\";\r\n    // 将canvas的宽度设置中 图片的高度\r\n    const canvasHeight = baseImg.height + \"px\";\r\n    //  setData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）。\r\n    // 因此需要将 描绘 图片的步骤写在回调中，否则 真机调试有bug！\r\n    this.setData({ canvasWidth, canvasHeight }, () => {\r\n      // 如果个别机型出现图片失败错误，可以加上定时器。\r\n      setTimeout(() => {\r\n        // 先将柯南 描绘到画布上\r\n        context.drawImage(baseImg.path, 0, 0, baseImg.width, baseImg.height);\r\n        // 把红旗 描绘到画布上\r\n        context.drawImage(flagImg.path, baseImg.width - (pixelRatio * 50), baseImg.height - (pixelRatio * 50), (pixelRatio * 50), (pixelRatio * 50));\r\n        context.draw(true, async () => {\r\n          // 将 画布生成 成图片\r\n          const res1 = await canvasToTempFilePath({\r\n            canvasId: \"firstCanvas\"\r\n          });\r\n          // 让图片显示 合成后的效果\r\n          this.setData({ resSrc: res1.tempFilePath })\r\n          // 保存起来，当点击保存图片时调用\r\n          this.saveImgSrc = res1.tempFilePath;\r\n        });\r\n      }, 100);\r\n    });\r\n  },\r\n\r\n  // 点击保存图片\r\n  handleSave() {\r\n    saveImageToPhotosAlbum(this.saveImgSrc);\r\n  }\r\n})\r\n\r\n复制代码github地址\r\nhttps://github.com/itcastWsy/AppletPoster.git"}
{"title": "这个新能力能让假期玩得更开心？看看微信和开发者们怎么说 ... ", "author": "Rolan", "pub_time": "2019-10-8 00:00", "content": "叮！告诉你一个“不幸”的消息：明天就要上班啦！在今天这个假期余额严重不足的时刻，此时小伙伴们的内心OS肯定是：放假时间要比上班过得尤其快！尽管大家还沉浸在宛如脱缰野马一样的愉悦当中，不愿意接受一睁眼便要去上班这一残酷事实，但为了帮助大家更快地适应工作节奏，晓程序观察（yinghoo-tech）的小伙伴们还是毅然决然地决定充当一个推手，帮大家拉回现实。整个国庆期间，虽然大多数开发者们都在好吃好喝好玩着，但是小程序们可没有“休息”，依然在用户的手机里“疲于奔命”，为用户的美好假期出一份力。但是，在没有开发者的照看下，小程序们多少还是会遇到一些问题。不但用户反馈“无门”，由于不能及时处理，开发者想要再去解决，也无从查起。所以，这些小烦恼总会影响开发者们的愉快假期。现在，一个小程序新能力的上线，打破了这一局面，它就是「实时日志」能力。「实时日志」可以实时记录用户在使用小程序过程中遇到的种种问题，而开发者只需知道用户的Open ID，即可快速找到问题，丝毫不费力，开发者们的假期也可以过得更舒心了。对此，我们邀请到「实时日志」能力的微信官方开发人员与几位开发者，一起来聊聊这一能力是什么？能够帮助开发者解决哪些问题？01「实时日志」能力的作用是什么？帮助开发者解决了哪些痛点？微信官方：「实时日志」可以帮助开发者快速排查小程序bug、定位问题。以前，在用户遇到问题的时候，需要用户在手机端把日志上传，进行反馈，然后开发者在小程序后台去把日志下载下来查看。整个流程冗长，不是特别顺畅，过程中需要找到用户，所以有一定的效率成本。有了这个实时日志后就不再需要麻烦用户，开发者在后台就可以直接看到用户的日志，然后排查问题了。02如何接入与使用这一能力？群接龙：「实时日志」是微信提供的一个能力，在用户端加入一段代码就能解决，也就是微信自带的一个API(应用程序编程接口）。接入之后，用户在使用小程序的时候，出现任何问题，日志都会实时同步到后台，管理日志的话，也是在微信的管理后台上操作，所以排查问题就很方便了。「实时日志」主要的使用场景有哪些？群接龙：场景就是，我们在调试一些本地无法复现，但是用户又很频繁去反馈的一些问题，「实时日志」可以大大提升我们从客服到开发，然后再反馈给用户的完整链路的效率。以前，我们客服人员会收到一些用户反馈反复出现的bug，其实很多用户反馈的都是同一个bug，这个时候我们很难去复现和定位这个问题，然后用户就会很不耐烦。举个例子的话。小程序用户端就像我们的孩子，你有几十万个孩子，你不可能每个孩子去询问发生了什么问题。这个时候「实时日志」，就像是在每个孩子身上装了一个智能手表，发生了什么事情你就可以通过手机去检测他是那个孩子出了问题那个孩子闯祸了，就可以直接找到出问题的那个孩子。04接入「实时日志」能力之后，开发者可以用它来做哪些事？微信读书：我们会用它来做问题排查和调试BUG。在没有这个能力之前，我们主要是应用小程序原生的那一套反馈系统和我们自己有一套类似于客服聊天的一个系统来发现问题。但是，有时候会出现一些问题，比如，用户上报的日志有缺失，定位不到日志等等。现在，有了「实时日志」的话，我们就可以直接根据用户的Open ID，直接在后台筛选就可以，很方便定位到出现问题的日志。另外一个使用的场景是，我们做业务内测的情况。以前主要是根据反馈来做，测试的同学看到有问题，他得去查一下用户大概是什么时候发的反馈，然后我们再去系统里把反馈找出来。现在，因为测试账号都是固定的，所以就可以用同一个Open ID来实时监控测试的日志就可以了，这一点也是优化了运营的工作流程。05有了这个新能力，在处理问题时，时间与流程上有哪些优化？客服小助手：过去，用户反馈一个问题过来，我们需要反复确认，而且只能依赖后台去查看，不过最好是前端能够复现的问题，比较麻烦的话，就只能大概猜测问题在哪里，然后做代码的调整。「实时日志」能力上线后，直接向用户要微信号跟发生问题的时间，就可以直接拉到当时的日志，不用像之前一样去跟他了解怎么复现等一系列问题，省去了人工沟通的环节。对开发来说，都希望自己的小程序可控。不过，上线一个新功能，确实难以避免bug，但是有了这个能力，相当于多了一层保障，多了一种处理的手段。06接入及使用「实时日志」过程中，开发者该注意哪些问题？微信官方&开发者：1、这是一项通用的基础能力，无论哪一类小程序，都建议接入，会方便定位与排查问题；2、目前，小程序的后台限制了每个小程序每天存储100万条日志，只保留3天，所以开发者需要及时排查、及时解决问题；3、不需要把所有日志都导出来，信息太大的话，不利于排查，也会占用存储空间，起到适得其反的效果，建议结合实际情况选择性导出等。"}
{"title": "小程序模块化 ", "author": "Rolan", "pub_time": "2019-10-8 00:10", "content": "原本需要 24 个工作日才能完成的任务，我却在 0.5 个工作日内完成了，是如何实现的呢？趁着放假有空，写篇文章给大家分享一下我们小程序模块化加速项目开发的思路吧。阅读基础：有小程序项目经验，有查阅官方文档习惯的小伙伴随着公司小程序项目日益繁多，仅仅靠着官方提供的框架、组件、API，已经远远不能满足项目高效迭代的要求了，于是我们组内萌生了对小程序进行模块化的想法。实际项目中我们对小程序模块化已经涉及各个模块，我总结一下，从三个方向跟大家分享我们不一样的模块化思路：\tPage+ ，\tbasePage ，\t适配层 。Page+Page() 作为页面的入口，我们可以通过对其入参对象的封装实现：生命周期的改造、全局状态管理和新增页面功能。官方删除了小程序分享回调 complete，一起来尝试将其恢复吧。一般我们的逻辑是这样的：// pages/index/index.js\r\nPage({\r\n  // 数据初始化\r\n  data: {\r\n    shareFlag: false,        //页面是否处于分享中\r\n    shareComplete: false     //分享回调事件\r\n  },\r\n  // onShow 生命周期\r\n  onShow: function () {\r\n    const { shareFlag, shareComplete } = this.data\r\n    if( shareFlag ){\r\n      this.data.shareFlag = false    //变量不涉及页面渲染，不使用 setData\r\n      shareComplete && shareComplete()\r\n    }\r\n  },\r\n  // 分享事件\r\n  onShareAppMessage: function () {\r\n    let shareInfo = {\r\n      title: '分享测试标题',\r\n      path: '',\r\n      complete: function () {\r\n        console.log('页面分享成功啦~')\r\n      }\r\n    }\r\n    this.data.shareFlag = true\r\n    this.data.shareComplete = typeof (shareInfo.complete) == 'function' ? shareInfo.complete : false\r\n    return shareInfo\r\n  }\r\n})在单页面内实现分享回调这样操作是可行的，如果多页面、多项目都要实现该功能，重复拷贝代码，则显格外得繁琐。我们来将这个功能抽离封装一下吧。// pages/index/index.js\r\nimport PagePlus from './pagePlus.js'\r\nPagePlus({\r\n  // 分享事件\r\n  onShareAppMessage: function () {\r\n    return {\r\n      title: '分享测试标题',\r\n      path: '',\r\n      complete: function () {\r\n        console.log('页面分享成功啦~')\r\n      }\r\n    }\r\n  }\r\n})// pages/index/pagePlus.js\r\nconst PagePlus = (pageObj) => {\r\n  const _onShow = pageObj.onShow,\r\n    _onShareAppMessage = pageObj.onShareAppMessage,\r\n    _data = {\r\n      shareStatus: false,   //页面是否处于分享中\r\n      shareComplete: false  //分享回调事件\r\n    }\r\n  Object.assign(_data, pageObj.data)\r\n  delete pageObj.data\r\n  pageObj.onShow = function () {\r\n    typeof _onShow == 'function' && _onShow.apply(this)\r\n    const { shareStatus, shareComplete } = this.data\r\n    if (shareStatus) {\r\n      this.data.shareStatus = false //变量不涉及页面渲染，不使用 setData\r\n      shareComplete && shareComplete()\r\n    }\r\n  }\r\n  pageObj.onShareAppMessage = function () {\r\n    const shareInfo = typeof _onShareAppMessage == 'function' && _onShareAppMessage.apply(this)\r\n    this.data.shareStatus = true\r\n    shareInfo && (this.data.shareComplete = shareInfo.complete)\r\n    return shareInfo\r\n  }\r\n  Page({ data: _data, ...pageObj })\r\n}\r\nexport default PagePlus我们来增加一个新的生命周期回调——\tonReshow （页面非首次显示回调，常用于详情页操作影响上一页列表数据的场景）。// pages/index/index.js\r\nimport PagePlus from './pagePlus.js'\r\nPagePlus({\r\n  // 监听页面非首次显示\r\n  onReshow: function(){\r\n    console.log('onReshow lifeCallBack')\r\n  },\r\n  onShareAppMessage: function () {\r\n    return {\r\n      title: '分享测试标题',\r\n      path: '',\r\n      complete: function () {\r\n        console.log('页面分享成功啦~')\r\n      }\r\n    }\r\n  }\r\n})// pages/index/pagePlus.js\r\nclass BasePage{\r\n  data = {\r\n    pagePlus: {\r\n      shareStatus: false,   //页面是否处于分享中\r\n      shareComplete: false, //分享回调事件\r\n      firstEnter: true      //第一次进入页面\r\n    }\r\n  }\r\n  methods = {\r\n    onShow: this.onShow,\r\n    onShareAppMessage: this.onShareAppMessage,\r\n    onReshow: this.onReshow\r\n  }\r\n  onShow(){\r\n    const { shareStatus, shareComplete, firstEnter } = this.data.pagePlus\r\n    if (firstEnter) {\r\n      this.data.pagePlus.firstEnter = false\r\n    } else {\r\n      this.onReshow()\r\n    }\r\n    if (shareStatus) {\r\n      this.data.pagePlus.shareStatus = false\r\n      shareComplete && shareComplete()\r\n    }\r\n  }\r\n  onShareAppMessage(shareInfo){\r\n    this.data.pagePlus.shareStatus = true\r\n    shareInfo && (this.data.pagePlus.shareComplete = shareInfo.complete)\r\n  }\r\n}\r\n\r\nconst PagePlus = (pageObj) => {\r\n  const basePage = new BasePage()\r\n  for (var i in basePage.methods) {\r\n    basePage.methods[i] = (() => {\r\n      const key = i\r\n      const _temFn = basePage.methods[key]\r\n      return function () {\r\n        if (key == 'onShareAppMessage') {\r\n          const shareInfo = typeof pageObj[key] == 'function' && pageObj[key].apply(this, arguments)\r\n          _temFn.apply(this, [shareInfo])\r\n          return shareInfo\r\n        }\r\n        typeof pageObj[key] == 'function' && pageObj[key].apply(this, arguments)\r\n        typeof _temFn == 'function' && _temFn.apply(this, arguments)\r\n      }\r\n    })()\r\n  }\r\n  Object.assign(basePage.data, pageObj.data)\r\n  delete pageObj.data\r\n  Page({ data: basePage.data, ...pageObj, ...basePage.methods })\r\n}\r\n\r\nexport default PagePlus自此，我们修改了原生的生命周期回调和增加了新的生命周期回调。当然我们还能为 Page+ 赋予更多的功能，例如：页面刷新 ：下拉自动刷新当前页。定时器自动清除 ：离开页面时，自动清除页面执行的定时器。全局状态管理 ：页面间数据共享，相关数据关联的组件即时渲染更新。相关的代码实现，大家可以自己思考一下怎么实现；我的实现细节，如果大家感兴趣的话就在下方给我留言吧，你们的回复是我更新的动力哦。basePage小程序页面彼此独立，使用 Component 都需要各自引用，为了实现页面公共 Component 的统一管理，这个时候就可以引入 basePage 的概念：以 basePage 作为父组件，其他公共 Component 作为子组件，页面通过 basePage 对公共 Component 进行管理。实现原理1、定义一个 Component ，作为 basePage 。2、每个页面统一引用 basePage ，且规定页面的元素都需要写到 <basePage/> 标签内部 。3、通过 basePage 引用页面公共的 Component ，并进行业务逻辑编辑。实现细节实际使用过程中，我发现有两个问题：1、Page 和 basePage 通信是非常频繁的，需要通过 WXML 数据绑定和 triggerEvent 触发事件，略显麻烦。2、setTimeout、webSocket 等后台进程，可能触发\t非当前显示页面 的渲染更新，而绝大部分情况，我们只需要\t当前显示页面 的渲染更新。针对这两种场景的优化，我们可以把当前显示页面的 basePage 实例对象赋值到 global 的某个具体变量；每当 Page 触发 show 生命周期回调的时候，我们就对这个变量赋值的实例对象进行更新，这样我们就可以通过 global 的变量直接操作当前显示页面的 basePage 了。部分代码示例{\r\n  \"文件路径\": \"pages/index/index.json\",\r\n  \"usingComponents\": {\r\n    \"basePage\": \"../../components/basePage/index\"\r\n  }\r\n}<!--pages/index/index.wxml-->\r\n<basePage>\r\n  <!-- \r\n  页面元素\r\n  -->\r\n</basePage>// components/basePage/index.js\r\nComponent({\r\n  /**\r\n   * Component 所在页面的生命周期函数\r\n   */\r\n  pageLifetimes: {\r\n    show: function () {\r\n      global.basePage = this\r\n    },\r\n    hide: function () {\r\n      global.basePage = null\r\n    }\r\n  }\r\n}){\r\n  \"文件路径\": \"components/basePage/index.json\",\r\n  \"说明\": \"在此处统一引入页面公共的 Component\",\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}<!--components/basePage/index.wxml-->\r\n<slot />适配层如果你的项目对代码后续维护、迭代和可移植性有较高需求，或者需要多项目并行，这个时候通过适配层去调用各个功能模块就显得尤为重要。适配层方面我做的还是比较粗糙的，如果有建议欢迎指出。适配层的时机项目不是 bugfix 级别的迭代，都有适配层设计的必要。如果是\t新项目 ，心底不认为自己是“咸鱼”而是代码的“亲爹”，\t适配层完全可以作为标配 去实现；这就是展现自己对代码全局观的时候了，把自己对代码的理解都用适配层去诠释吧。如果是\t旧项目迭代 ，在项目排期允许的情况下，尽可能理解原代码的基本实现细节；对比新的项目是要束手束脚一些，适配层的设计要在\t尽可能少改变原有代码 的情况下进行；如果排期比紧急，适配层的完整实现\t可以在几个版本迭代中逐步实现 。模块设计必须高内聚低耦合如果功能模块的设计过于松散、耦合复杂，这就意味着适配层将需要做各种兼容，这和适配层设计的初衷背道而驰，不做也罢。配置文件如果你的代码有移植性要求，为这些不同环境准备对应的配置文件吧，配置文件可以通过自制脚手架实现，也可以粗暴地手动替换，在保证尽可能不出错的情况下实现即可。功能模块的入口所有整合的功能模块都需要通过适配层进行调用，适配层就是你的“王之财宝”。规范 && 文档适配层是从代码的全局考虑，如果是项目是分工完成，项目的开发人员都需要遵守适配层规范进行代码开发；文档我一直都认为都是非常必要的，但还是经常会懈怠，没有进行完整的文档编写，但我基本会在所有项目成员都能理解适配层的情况下，进行简单的口头说明。因为开心说一些废话一次需求迭代中，几乎涉及手头上的所有小程序项目；刚好就在需求前的半个月，我们小组完成了对所有项目模块化改造；虽然需求来得很急，我们还是很完美的实现了。毕竟\t模块化之前，每个项目的改造都是独立的工作量；模块化之后，就只有适配层迭代的工作量了 。不过真是辛苦了测试小伙伴，因为对所有项目进行模块化改造，意味着测试小伙伴对所有项目进行回归测试，感谢测试小伙伴，比心！这篇文章，对 Page+ 的具体实现展示比较详细，感觉对 basePage 和适配层讲的都比较偏概念。毕竟这部分内容都和业务逻辑联系比较紧密，很难抽象深入讲解。刚好还有假期还有一段时间，如果自己还有时间就再写一篇关于最近项目的模块化剖析吧，哈哈。"}
{"title": "手把手教大家写一个刷简书阅读量的小程序 ", "author": "Rolan", "pub_time": "2019-10-8 00:14", "content": "本人是很不喜欢作弊的，但是我不作弊，不代表其他人不作弊，为了公平起见，我们也要作弊，除非官方把作弊渠道给封锁了。这里我教你们用golang(谷歌开发的计算机程序语言)来开发这个小程序，我尽量写的让小白都可以看懂。第一步，安装go语言开发环境1.在这里下载go语言安装包， https://golang.google.cn/dl/ ，对应自己的系统下载。双击安装，安装之后就可以编译解析go语言了，给这里的文科生们多说一句，我们的电脑运行的是01010的二进制代码，安装了这个之后，就可以把我们的写的代码执行,如下的伪代码。if n > 2  {\r\n  dosomething\r\n}2.下载计算机语言编辑器， https://www.sublimetext.com/ ，对应自己的系统下载安装。第二步，编码下面我直接写好注释给大家，大家可以下载，package main\r\n\r\n//刷阅读量，import是导入一些第三方的代码库\r\nimport (\r\n    \"fmt\"\r\n    \"github.com/satori/go.uuid\"\r\n    \"net/http\"\r\n    \"time\"\r\n    \"strconv\"\r\n    \"math/rand\"\r\n    \"bufio\"\r\n    \"bytes\"\r\n    // \"io/ioutil\"\r\n    \"os\"\r\n    \"github.com/urfave/cli\"\r\n)\r\n\r\n//这个是简书的网页地址\r\nvar urlS = \"https://www.jianshu.com/p/\"\r\n\r\nfunc GetUID() string {\r\n    id := uuid.NewV4()\r\n    uid := id.String()\r\n\r\n    return uid\r\n    // return strings.Replace(uid, \"-\", \"\", -1)\r\n}\r\n\r\nvar (\r\n    app        *cli.App\r\n    configPath string\r\n)\r\n\r\n\r\n//这个是我们的刷阅读量的主要程序代码\r\nfunc GetURL(id, se []byte) {\r\n\r\n    second, err := strconv.Atoi(string(se))\r\n    if err != nil {\r\n        fmt.Println(\"参数错误\")\r\n    } else {\r\n        for i := 0; i < second; i++ {\r\n\r\n\r\n            var jsonStr = []byte(\"\")\r\n            req, err := http.NewRequest(\"GET\", urlS+string(id), bytes.NewBuffer(jsonStr))\r\n\r\n            req.Header.Set(\"accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\")\r\n            req.Header.Set(\"accept-encoding\", \"gzip, deflate, br\")\r\n            req.Header.Set(\"cache-control\", \"max-age=0\")\r\n            req.Header.Set(\"cookie\", \"if_shakespeare=1; sajssdk_2015_cross_new_user=1; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%2216d8ce3c19a32-020def57eb3a8b-1d3d6b55-1296000-16d8ce3c19b484%22%2C%22%24device_id%22%3A%2216d8ce3c19a32-020def57eb3a8b-1d3d6b55-1296000-16d8ce3c19b484%22%2C%22props%22%3A%7B%22%24latest_referrer%22%3A%22%22%2C%22%24latest_referrer_host%22%3A%22%22%2C%22%24latest_traffic_source_type%22%3A%22%E7%9B%B4%E6%8E%A5%E6%B5%81%E9%87%8F%22%2C%22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC_%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%22%7D%7D; Hm_lvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1570026800; __yadk_uid=uWSzDAQMYbu8bBnFhwbLRJ2DlBqNpOQ4; locale=zh-CN; Hm_lpvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1570026810\")\r\n            req.Header.Set(\"if-none-match\", \"155d5-MblZWRdrcEosECyhXQuwjqwKi40\")\r\n            req.Header.Set(\"sec-fetch-mode\", \"navigate\")\r\n            req.Header.Set(\"sec-fetch-site\", \"same-origin\")\r\n            req.Header.Set(\"sec-fetch-user\", \"?1\")\r\n            req.Header.Set(\"upgrade-insecure-requests\", \"1\")\r\n            req.Header.Set(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36\")\r\n\r\n            client := &http.Client{}\r\n            resp, err := client.Do(req)\r\n            if err != nil {\r\n                panic(err)\r\n            }\r\n            defer resp.Body.Close()\r\n\r\n            fmt.Println(\"response Status:\", resp.Status)\r\n            fmt.Println(\"response Headers:\", resp.Header)\r\n\r\n\r\n            Urls2 := \"https://www.jianshu.com/shakespeare/notes/\"+string(id)+\"/mark_viewed\"\r\n\r\n            //模仿\r\n            data23 := `{\"fuck\":1}`\r\n            var jsonStr23 = []byte(data23)\r\n\r\n            req2, err := http.NewRequest(\"POST\", Urls2, bytes.NewBuffer(jsonStr23))\r\n\r\n\r\n            req2.Header.Set(\"accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\")\r\n            req2.Header.Set(\"accept-encoding\", \"gzip, deflate, br\")\r\n            req2.Header.Set(\"cache-control\", \"max-age=0\")\r\n            req2.Header.Set(\"cookie\", \"if_shakespeare=1; sajssdk_2015_cross_new_user=1; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%2216d8ce3c19a32-020def57eb3a8b-1d3d6b55-1296000-16d8ce3c19b484%22%2C%22%24device_id%22%3A%2216d8ce3c19a32-020def57eb3a8b-1d3d6b55-1296000-16d8ce3c19b484%22%2C%22props%22%3A%7B%22%24latest_referrer%22%3A%22%22%2C%22%24latest_referrer_host%22%3A%22%22%2C%22%24latest_traffic_source_type%22%3A%22%E7%9B%B4%E6%8E%A5%E6%B5%81%E9%87%8F%22%2C%22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC_%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%22%7D%7D; Hm_lvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1570026800; __yadk_uid=uWSzDAQMYbu8bBnFhwbLRJ2DlBqNpOQ4; locale=zh-CN; Hm_lpvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1570026810\")\r\n            req2.Header.Set(\"if-none-match\", \"155d5-MblZWRdrcEosECyhXQuwjqwKi40\")\r\n            req2.Header.Set(\"sec-fetch-mode\", \"navigate\")\r\n            req2.Header.Set(\"sec-fetch-site\", \"same-origin\")\r\n            req2.Header.Set(\"sec-fetch-user\", \"?1\")\r\n            req2.Header.Set(\"upgrade-insecure-requests\", \"1\")\r\n            req2.Header.Set(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36\")\r\n\r\n            client2 := &http.Client{}\r\n            resp2, err := client2.Do(req2)\r\n            if err != nil {\r\n                panic(err)\r\n            }\r\n            defer resp2.Body.Close()\r\n\r\n            fmt.Println(\"response Status:\", resp2.Status)\r\n            fmt.Println(\"response Headers:\", resp2.Header)\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\nfunc init() {\r\n    app = cli.NewApp()\r\n    app.Name = \"刷阅读量\"\r\n    app.Usage = \"刷刷刷\"\r\n    app.Author = \"baojiao\"\r\n    app.Flags = []cli.Flag{\r\n        cli.StringFlag{\r\n            Name:        \"c\",\r\n            Value:       \"\",\r\n            Destination: &configPath,\r\n            Usage:       \"./yaml/conf.yaml\",\r\n        },\r\n    }\r\n}\r\n\r\n\r\n//这个是我们的代码入口，所有执行最开始的地方\r\nfunc main() {\r\n\r\n    reader := bufio.NewReader(os.Stdin)\r\n    fmt.Print(\"请输入文章id:\")//这个id文章开头可以有教你怎么获取。\r\n    data, _, _ := reader.ReadLine()\r\n\r\n    reader3 := bufio.NewReader(os.Stdin)\r\n    fmt.Print(\"请输入每次刷新次数:\")\r\n    data3, _, _ := reader3.ReadLine()\r\n\r\n    fmt.Printf(\"正在准备启动，执行文章id为%s，每任意1-10秒刷%s次.\\r\\n\", data, data3)\r\n    time.Sleep(time.Second * 3)\r\n\r\n    //随机数种子\r\n    rand.Seed(time.Now().UnixNano())\r\n\r\n    for i := 0; i < 3000000; i++ {\r\n        x := rand.Intn(10)\r\n        //1-10秒随机执行时间\r\n        time.Sleep(time.Second * time.Duration(x))\r\n        GetURL(data, data3)\r\n    }\r\n    // return nil\r\n}第三，运行程序go run main.go最后执行的成果，这里面还有一些小bug，明天我起来改。"}
{"title": "微信PC版2.7.1正式更新，真的能在电脑上打开小程序了！ ", "author": "Rolan", "pub_time": "2019-10-8 00:19", "content": "微信Windows版2.7.1正式更新两个变化值得关注近日，微信 for windows 2.7.1版正式更新，主要有两个方面的变化。一是，可以在PC版微信上打开小程序了，比如来自聊天消息中的小程序、文章中的小程序等；二是，新增了「聊天文件管理」功能，此功能位于左侧工具栏，打开可显示微信聊天中的所有文件。还可以按照发送者、聊天、类型来筛选，每个文件下方还会显示来自哪个聊天以及文件发送者。晓程序说：关于第一个变化“PC版微信支持打开小程序”，我们此前已有深度解析，请点击阅读；第二个功能可以说是非常人性化了，以前，要找一个文件只能通过微信聊天一一查找，非常不方便。现在，有了「聊天文件管理」功能，工作效率嗖嗖提升啊！2微信支付分接入打车平台用户可享受先打车后付款来自微信支付官方消息，微信支付分正式接入打车平台，用户开启微信支付分后，分数达标的话，即有机会享受“先打车后付款”服务，上车免预付，到达目的地后自动扣款。首家接入微信支付分“先乘后付”模式的是「极速打车」小程序，它集合了曹操出行、首汽约车、神州专车等多个网约车服务平台。晓程序说：不得不说，“先乘后付”确是一个值得点赞的服务，尤其是在国庆假期期间，约车十分频繁的情况下，用户就方便了许多。据悉，除了「极速打车」小程序，「百度地图」打车、「高德地图」打车、「欧了约车」等网约车平台接下里也将陆续接入了微信支付分的“先乘后付”服务。3微信已处理4万多个涉嫌“民族资产解冻”欺诈群9月30日，微信安全中心发文称，近期，微信团队收到用户投诉，有部分帐号在微信群内实施“民族资产解冻”类诈骗行为。微信表示，对此类违法违规行为绝不姑息。目前为止，微信安全团队共计对4万多个涉嫌“民族资产解冻”欺诈群进行限制处理，并对3000多个微信帐号进行限制功能使用或封停帐号等阶梯式处罚。后续将根据用户投诉提交证据，继续加强处理，并向公安机关提交违法违规证据线索。小程序动态1小程序增加「回到主页」功能近日，我们发现不少小程序都增加了「回到主页」功能，其入口，位于小程序左上角。至于这个“共同变化”是否为内测功能，目前尚不得知。晓程序说：虽然此前更新的最新版本微信中，小程序菜单已有「回到主页」功能，但入口还是有点深，用起来不太方便。如果任何页面左上角都有「回到主页」，那以后使用就更方便了。2小程序下拉入口中「最近使用」变成两行近日，安卓版微信的小程序下拉入口有了新变化，其中，「最近使用」的小程序由此前一行变成了两行。也就是说，「最近使用」最多可显示7个小程序，而过去的一行仅能显示3个小程序及「…」按钮。不过，仅有部分安卓微信用户的小程序下拉入口有更新，所以目前还在内测阶段。晓程序说：小程序下拉入口自上线以来已有多次变动，此次变化中，「最近使用」入口被放大。根据此前9月19日微信公开课零售专场的数据，「最近使用」的流量要远大于「我的小程序」，所以，此番变动也不足为奇。"}
{"title": "仿微信下拉显示小程序的控件(超简单实现) ", "author": "Rolan", "pub_time": "2019-10-8 00:52", "content": "GitHub地址：https://github.com/wenwenwen888/PullLoadMoreViewPullLoadMoreView仿微信下拉显示小程序的控件(超简单实现)先看预览图(转换后有一点点失真):前言项目需要做一个以前微信下拉显示小程序的效果，结果Google百度过并没有找到很多的开源库。而且实现方式还挺复杂，或者不适用于自己(大多数为需要ListView实现)该库主要参考这篇文章 ，实现的原理大家看这篇文章就好了，感谢该Po在该篇文章的前提下，一共作出了以下修改把Kotlin改为了Java把可滑动控件的主布局改为了NestedScrollView(原文为ListView)，按照原理，你可以改为任意一个可滑动的控件(但是需要您亲自下载library修改)一些代码的优化，譬如NestedScrollView的布局直接在xml里实现接口的添加和优化，使得更加方便需要修改更多内容的可以下载library自行修改有不妥之处请Issues指出,谢谢UsageWith Gradle:  implementation 'com.wenwenwen888:pullloadmoreview:1.1.0'\r\nHow to use（直接clone项目查看demo更加直观哦）一：xml主布局配置 <?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<com.wenwenwen.view.PullLoadMoreView xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    android:id=\"@+id/pullLoadMoreView\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    app:top_background_color=\"#fff\">\r\n\r\n    <android.support.v4.widget.NestedScrollView\r\n        android:id=\"@+id/nestedScrollview\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\">\r\n\r\n        <LinearLayout\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:orientation=\"vertical\">\r\n\r\n            <TextView\r\n                android:layout_width=\"match_parent\"\r\n                android:layout_height=\"300dp\"\r\n                android:gravity=\"center\"\r\n                android:text=\"test1\" />\r\n\r\n            <TextView\r\n                android:layout_width=\"match_parent\"\r\n                android:layout_height=\"300dp\"\r\n                android:gravity=\"center\"\r\n                android:text=\"test2\" />\r\n\r\n            <TextView\r\n                android:layout_width=\"match_parent\"\r\n                android:layout_height=\"300dp\"\r\n                android:gravity=\"center\"\r\n                android:text=\"test3\" />\r\n\r\n            <TextView\r\n                android:layout_width=\"match_parent\"\r\n                android:layout_height=\"300dp\"\r\n                android:gravity=\"center\"\r\n                android:text=\"test4\" />\r\n\r\n        </LinearLayout>\r\n\r\n    </android.support.v4.widget.NestedScrollView>\r\n\r\n</com.wenwenwen.view.PullLoadMoreView>\r\n//此配置为顶部布局的背景颜色\r\napp:top_background_color=\"#fff\"\r\n二: 头部xml的配置//添加头部布局\r\npullLoadMoreView.addHeadView(R.layout.top_layout);\r\n三：可设置回调监听//添加监听滑动布局的open/close\r\npullLoadMoreView.setViewStateListener(new PullLoadMoreView.ViewStateListener() {\r\n    @Override\r\n    public void onViewState(PullLoadMoreView.VIewState viewState) {\r\n        if (viewState == PullLoadMoreView.VIewState.OPEN) {\r\n            Toast.makeText(MainActivity.this, \"Open\", Toast.LENGTH_SHORT).show();\r\n        } else {\r\n            Toast.makeText(MainActivity.this, \"Close\", Toast.LENGTH_SHORT).show();\r\n        }\r\n    }\r\n });\r\nGitHub地址：https://github.com/wenwenwen888/PullLoadMoreView"}
{"title": "uni-app开发一个小视频应用(一) ", "author": "Rolan", "pub_time": "2019-10-9 00:02", "content": "一、uni-app简介uni-app 是一个使用 Vue.js 开发所有前端应用的框架，是一种终极的跨平台解决方案，这里的平台，主要指的是App平台(android、ios)、小程序平台、H5平台。开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。uni-app将常用的组件和api进行了跨平台封装，并且保持与微信小程序的组件和api一致，同时兼容以微信的方式去调用api，即在uni-app中除了可以使用全局的uni对象去调用微信小程序中同名的api还可以使用全局的wx对象去调用api。uni-app使用vue的语法以及微信小程序api，所以学习成本非常低。<script>\r\n    export default {\r\n        onLoad() {\r\n            uni.showLoading({\r\n                title: '加载中-uni'\r\n            });\r\n            // 二者是等价的\r\n            wx.showLoading({\r\n                title: '加载中-uni'\r\n            })\r\n        }\r\n    }\r\n</script>二、uni-app初始目录及文件介绍① pages.json : 该文件是用来对 uni-app 进行全局配置，决定页面文件的路径(pages)、窗口样式(globalStyle)、原生的导航栏(globalStyle)、底部的原生tabbar(tabBar) 等。它类似微信小程序中app.json的页面管理部分。需要注意的是，微信小程序权限配置也是在app.json文件中，通过permission进行配置，而uni-app则将权限配置移到了manifest.json文件中。② manifest.json: 该文件是应用的配置文件，主要用于指定应用的名称、图标、权限等。③ App.vue : 该文件是应用的主组件，所有页面都是在App.vue下进行切换的，是页面入口文件，在这个文件里，你可以初始化一些通用的组件，调用一些应用生命周期函数，应用生命周期(onLaunch、onShow、onHide)仅可在App.vue中监听，在其它页面监听无效，以及设置一些全局的样式，即在App.vue中的<style></style>内置设置全局样式。④ main.js: 该文件是应用的入口文件，主要作用是初始化App.vue主组件并安装需要的插件，如vuex，需要注意的是，uni-app中是不能使用vue-router插件的，因为路由须在pages.json中进行配置。// main.jsimport Vue from 'vue'\r\nimport App from './App'\r\n\r\nVue.config.productionTip = false\r\n\r\nApp.mpType = 'app'\r\n\r\nconst app = new Vue({ // ①官方写法\r\n    ...App\r\n})\r\n// const app = new Vue(App); // ②等价于上面的写法\r\n\r\n// const app = new Vue({ // ③可正常渲染出页面，但onLaunch、onShow、onHide应用生命周期失效\r\n//      render: h => h(App)\r\n// });\r\napp.$mount()main.js中官方写法是在创建Vue实例的时候传入一个对象，并且对根组件App.vue进行解构后传入，其写法和直接传入根组件是一样的，但是如果通过写法③虽然可以正常渲染出页面，但是根组件上的应用生命周期函数将失效⑤ pages文件夹: 主要用于存放应用中的页面，应用中的页面就是.vue组件。⑥ static文件夹: 主要用于存放应用中的图片等静态资源。⑦ uni.scss: 主要存放uni-app内置的常用样式变量。⑧ unpackage文件夹: 主要存放uni-app编译运行后生成的打包相关输出文件。三、开始开发一个小视频应用① 初始化项目打开HBuilderX IDE，新建一个名称为mini-video的初始化uni-app项目，这里勾选uni-app即可创建，项目创建完成后，打开pages/index/index.vue，将<template>中的模板内容content部分清空，将uni-app初始项目中与应用无关的东西进行清空、修改即可。② 创建底部导航栏组件首先要弄清楚我们的uni-app已经提供了tabBar的配置，即提供了底部导航栏的，那为什么还需要自定义底部导航栏呢 ？因为uni-app提供的默认底部导航栏tabBar的背景颜色只支持十六进制，所以无法设置为透明。同时我们又需要将底部导航栏中的页面设置为tabBar页面，所以我们还是要进行tarBar的配置，而一配置tabBar，那么就会自动出现uni-app提供的默认导航栏，所以我们必须在应用启动onLaunch的时候将默认tabBar进行隐藏，那么没有了默认导航栏，我们怎么进行tabBar页面的切换呢？我们可以通过<navigator>组件设置不同的跳转方式，实现应用内各种页面之间的跳转。记住APP和微信小程序是不支持<a>标签跳转的。底部导航栏有五个页面: 首页(index.vue)、关注(follow.vue)、加号(添加好友friend.vue)、消息(news.vue)、我(personal.vue)。所以需要在pages中模仿index新建出剩余的四个页面，页面新建完成后，需要配置到pages.json中的tarBar中，只需要配置list即可，如:{\r\n    \"tabBar\": { // 在pages.json中添加上tabBar配置，如下\r\n        \"list\": [\r\n            {\"pagePath\":\"pages/index/index\"},\r\n            {\"pagePath\":\"pages/follow/follow\"},\r\n            {\"pagePath\":\"pages/friend/friend\"},\r\n            {\"pagePath\":\"pages/news/news\"},\r\n            {\"pagePath\":\"pages/personal/personal\"}\r\n        ]\r\n    }\r\n}// App.vue中onLaunch的时候隐藏掉uni-app自带的tabBar<script>\r\n    export default {\r\n        setTimeout(() => {\r\n            uni.hideTabBar(); // 隐藏tabBar\r\n        }, 1000);\r\n    }\r\n</script>在ios和安卓App平台上运行时，会出现tabBar隐藏失败的情况，解决办法就是隐藏的时候需要添加一个1000ms左右的延迟// 项目根目录下新建一个components目录，并在其中新建一个tab-bar.vue即自定义底部导航栏组件<template>\r\n    <view class=\"tab\">\r\n        <navigator open-type=\"switchTab\" url=\"/pages/index/index\" class=\"tab-box\">\r\n            首页\r\n        </navigator>\r\n        <navigator open-type=\"switchTab\" url=\"/pages/follow/follow\" class=\"tab-box\">\r\n            关注\r\n        </navigator>\r\n        <view class=\"tab-box\">\r\n            + <!--暂时用加号代替，后面会替换成字体图标-->\r\n        </view>\r\n        <navigator open-type=\"switchTab\" url=\"/pages/news/news\" class=\"tab-box\">\r\n            消息\r\n        </navigator>\r\n        <navigator open-type=\"switchTab\" url=\"/pages/personal/personal\" class=\"tab-box\">\r\n            我\r\n        </navigator>\r\n    </view>\r\n</template>\r\n\r\n<style>\r\n.tab{\r\n    height:50px;\r\n    width:100%;\r\n    position:fixed;\r\n    bottom: 0;\r\n    left: 0;\r\n    z-index: 20;\r\n}\r\n.tab-box{\r\n    float: left;\r\n    width: 20%;\r\n    color: #FFFFFF;\r\n    text-align: center;\r\n    height: 50px;\r\n    line-height: 50px;\r\n    font-size:20px\r\n}\r\n.icon-box{\r\n    width: 60%;\r\n    height: 30px;\r\n    background: #FFFFFF;\r\n    color: #000000;\r\n    margin: 10px 20%;\r\n    line-height:30px;\r\n    border-radius: 5px;\r\n    font-size: 15px;\r\n}\r\n</style>③ 添加图标字体添加图标字体非常简单，就是登录iconfont网站，然后创建一个图标项目，然后搜索自己需要的图标，比如加号、搜索、返回，将它们加入到项目中，然后点击下载即可，下载完成后解压，找到iconfont.css这个文件，这个就是我们要用到的图标字体的css样式，直接引入到项目中即可，为了方便使用，我们将图标字体css文件作为一个全局样式引入到App.vue组件中。使用的时候，我们只需要在需要添加图标字体的标签上，添加上\"iconfont 具体的图标样式名\"即可，如:// App.vue<style>\r\n    /*每个页面公共css */\r\n    @import url(\"./static/iconfont.css\");\r\n</style>// components/tab-bar.vue<view class=\"tab-box\">\r\n    <view class=\"iconfont icon-jiahao icon-box\" ><!--添加一个加号图标字体样式，注意是两个样式名哦-->\r\n    </view>\r\n</view>④ 创建首页头部导航栏首页头部导航栏，最左侧是一个搜索图标，中间是推荐和同城，右侧无内容。同样，我们的uni-app是有一个默认头部导航栏的，所以我们首先要隐藏掉默认的头部导航栏，要隐藏默认头部导航栏，我们需要在pages.json文件中设置其navigationStyle属性值为custom即自定义，如:{\r\n    \"globalStyle\": {\r\n        \"navigationStyle\":\"custom\" // 设置头部导航栏为自定义模式，头部导航栏会自动消失\r\n    }\r\n}// /components/index-header.vue<template>\r\n    <view class=\"index-header\"><!--固定定位到首页顶部-->\r\n        <view class=\"iconfont icon-icon-- icon\"></view> <!--绝对定位到左侧-->\r\n        <view class=\"middle\"> <!--搜索图标绝对定位后，middle将会上移动到顶部，在搜索图标下面，里面内容居中显示即可-->\r\n            <view class=\"text\">推荐</view>|\r\n            <view class=\"text\">同城</view><!--变成行内元素-->\r\n        </view>\r\n    </view>\r\n</template>\r\n\r\n<style scoped>\r\n.index-header {\r\n    height: 35px;\r\n    line-height: 35px;\r\n    width: 100%;\r\n    position: fixed;\r\n    top: 25px;\r\n    left: 0;\r\n    margin: 0 auto;\r\n    background: #000000;\r\n    z-index: 20;\r\n}\r\n.icon {\r\n    position: absolute;\r\n    left: 0;\r\n    top: 0;\r\n    color: white;\r\n    width: 20%;\r\n    text-align: center;\r\n}\r\n.middle {\r\n    text-align: center;\r\n    color: white;\r\n}\r\n.text {\r\n    display: inline;\r\n    margin: 0 10px;\r\n}\r\n\r\n</style>⑤ 创建视频播放组件视频播放组件即一个全屏的页面，然后里面嵌入一个<video>组件即可实现。这里需要特别说一下如何让页面全屏显示，我们设置页面全屏通常会让需要全屏的元素设置上width: 100%; height: 100%;可是当我们给视频播放组件根元素标签设置上width为100%，height为100%后，它并没有全屏显示，因为当样式属性值为百分数的时候，其是相对于父元素的，即是父元素宽高的100%，而此时视频播放组件的父元素是html、body，它们并没有设置宽高，所以我们需要在App.vue中设置一下全局样式，将html和body的宽高设置为100%，此后其中的子元素设置百分数的时候才会其作用。// App.vuehtml,body {\r\n    width: 100%;\r\n    height: 100%;\r\n    margin: 0;\r\n    padding: 0;\r\n}// /components/video-player.vue<template>\r\n    <view class=\"video-player\">\r\n        <video class=\"video\" \r\n               :src= \"video.src\" \r\n               :controls=\"false\"\r\n               :loop=\"true\">\r\n        </video>\r\n    </view>\r\n</template>\r\n<script>\r\n    export default {\r\n        props: [\"video\"]\r\n    }\r\n</script>\r\n<style>\r\n    .video-player {\r\n        width: 100%;\r\n        height: 100%;\r\n    }\r\n    .video {\r\n        width: 100%;\r\n        height: 100%;\r\n        z-index: 19;\r\n    }\r\n</style>⑥ 创建视频列表组件视频列表组件，我们使用的是<swiper>组件，里面<swiper-item>部分则为上面的视频播放组件。// /components/video-list.vue<template>\r\n    <view class=\"video-list\">\r\n        <view class=\"swiper-box\">\r\n            <swiper class=\"swiper\" :vertical=\"true\">\r\n                <swiper-item v-for=\"(item,index) in videos\" :key=\"index\">\r\n                    <view class=\"swiper-item\">\r\n                        <video-player                         \r\n                             :video=\"item\"                        \r\n                            :index=\"index\">\r\n                        </video-player>\r\n                    </view>\r\n                </swiper-item>\r\n            </swiper>\r\n        </view>\r\n    </view>\r\n</template>\r\n\r\n<script>\r\n    import VideoPlayer from \"./video-player.vue\";\r\n    export default {\r\n        components: {\r\n            \"video-player\": VideoPlayer\r\n        },\r\n        props:['list'],\r\n        data() {\r\n            return {\r\n                videos:[],\r\n            }\r\n        },\r\n        watch:{            \r\n            list(){                \r\n                this.videos=this.list;            \r\n            }        \r\n        }\r\n    }\r\n</script>\r\n\r\n<style scoped>\r\n    .video-list {\r\n        width: 100%;\r\n        height: 100%;\r\n    }\r\n    .swiper-box{    \r\n        height:100%;    \r\n        width: 100%;\r\n    }\r\n    .swiper{    \r\n        height:100%;    \r\n        width: 100%;\r\n    }\r\n    .swiper-item {\r\n        width: 100%;\r\n        height: 100%;\r\n        background: red;\r\n    }\r\n</style>⑦ 向视频列表组件传入列表数据视频列表组件和视频播放组件都已经完成后，就可以在首页onLoad的时候获取视频数据，然后传递给视频列表组件，视频列表组件在遍历传递过来的视频列表将视频地址传入对应的视频播放组件中即可，这里采用mock数据的方式提供视频列表。// pages/index/index.vue<template>\r\n    <view class=\"content\">\r\n        <index-header></index-header> <!--首页头部导航栏组件-->\r\n        <video-list :list=\"list\"></video-list> <!--视频列表组件-->\r\n        <tab-bar></tab-bar> <!--首页底部导航栏组件-->\r\n    </view>\r\n</template>\r\n<script>\r\n    import TabBar from \"../../components/tab-bar.vue\";\r\n    import IndexHeader from \"../../components/index-header.vue\";\r\n    import VideoList from \"../../components/video-list.vue\";\r\n    export default {\r\n        components: {\r\n            \"tab-bar\": TabBar,\r\n            \"index-header\": IndexHeader,\r\n            \"video-list\": VideoList\r\n        },\r\n        data() {\r\n            return {\r\n                list: []\r\n            }\r\n        },\r\n        onLoad() {\r\n            this.getVideos();\r\n        },\r\n        methods: {\r\n            getVideos() {\r\n                const res = [\r\n                    {\r\n                        id: 0,\r\n                        src: \"http://alimov2.a.yximgs.com/bs2/gdtPostRoll/postRoll-MTA3MDY0NDY3Mzk.mp4\",\r\n                        autho: \"张三\",\r\n                        title: \"仙娜美\",\r\n                        loveNumber: 10000,\r\n                        commentNumber: 2000,\r\n                        shareNumber: 30000\r\n                    },\r\n                    {\r\n                        id: 1,\r\n                        src: \"http://upmov.a.yximgs.com/upic/2019/02/13/22/BMjAxOTAyMTMyMjUxMTlfNDc4ODM2MzlfMTA3Mjc5ODU2MjhfMV8z_b_B1fbc185eaca8cc06efa2d4f713e13e8c.mp4\",\r\n                        autho: \"李四\",\r\n                        title: \"【搞笑】最强猜歌王\",\r\n                        loveNumber: 40000,\r\n                        commentNumber: 5000,\r\n                        shareNumber: 60000\r\n                    },\r\n                    {\r\n                        id: 2,\r\n                        src: \"http://bdmov.a.yximgs.com/bs2/gdtPostRoll/postRoll-MTA3MDk5Mjc5OTg.mp4\",\r\n                        autho: \"王五\",\r\n                        title: \"特制流泪芥末酱\",\r\n                        loveNumber: 70000,\r\n                        commentNumber: 8000,\r\n                        shareNumber: 90000\r\n                    }\r\n                ];\r\n                this.list = res;\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n<style>\r\n    .content {\r\n        width: 100%;\r\n        height: 100%;\r\n    }\r\n</style>"}
{"title": "uni-app开发一个小视频应用(二) ", "author": "Rolan", "pub_time": "2019-10-9 00:32", "content": "一、前情回顾uni-app开发一个小视频应用(一)上篇文章，我们已经实现了首页的头部导航栏组件、底部的tabBar导航栏组件、中间的视频列表组件以及视频列表组件中的视频播放组件，传入视频列表渲染后已经可以上下滑动进行视频切换和播放，接下来我们将完成首页的剩余部分，左侧信息栏组件、右侧图标栏组件，以及完善视频切换动画、播放控制等功能。二、创建左侧信息栏组件左侧的信息栏组件，主要分三块: 作者名、视频标题名、音乐名。这个左侧信息栏信息是和当前播放视频相关联的，所以应该在循环视频列表的时候，将左侧信息栏组件一起渲染出来，所以左侧信息栏组件应该加到<swiper-item>中。// components/list-left.vue<template>\r\n    <view class=\"list-left\">\r\n        <view class=\"author\">\r\n            @祝晓晗\r\n        </view>\r\n        <view class=\"title\">\r\n            妈呀，遇到老同学了，缘分呐! @老丈人说车 @抖音小助手\r\n        </view>\r\n        <view class=\"music-box\"> <!--该music-box主要是为了在music内容滚动的时候在超出music-box范围后能够隐藏超出部分-->\r\n            <view class=\"music\">\r\n                @祝晓晗创作的原声 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  @祝晓晗创作的原声\r\n            </view>\r\n        </view>\r\n    </view>\r\n</template>\r\n<style scoped>\r\n    .list-left{\r\n        width: 70%;\r\n        height: 120px;\r\n        color: white;\r\n    }\r\n    .author {\r\n        height: 35px;\r\n        line-height: 35px;\r\n        font-size: 17px;\r\n    }\r\n    .title {\r\n        width: 100%;\r\n        line-height: 25px;\r\n        font-size: 12px;\r\n        word-wrap: break-word;\r\n        color: #FFFAF0;\r\n    }\r\n    .music-box {\r\n        overflow: hidden; <!--滚动的时候超出部分隐藏-->\r\n        width: 70%;\r\n    }\r\n    .music {\r\n        width: 200%;\r\n        height: 35px;\r\n        line-height: 35px;\r\n        font-size: 12px;\r\n        animation: scroll-x 5s linear 0.2s infinite; <!--应用动画-->\r\n    }\r\n    @keyframes scroll-x{ <!--添加文字水平滚动动画-->\r\n        0% {\r\n            transform: translate3d(80%, 0, 0); <!--80%位置出现，然后向左边滚动-->\r\n        }\r\n        100% {\r\n            transform: translate3d(-80%, 0, 0); <!--动画结束后到达-80%位置-->\r\n        }\r\n    }\r\n</style>\r\n// components/video-list.vue<template>\r\n    <view class=\"video-list\">\r\n        <view class=\"swiper-box\">\r\n            <swiper class=\"swiper\" :vertical=\"true\">\r\n                <swiper-item v-for=\"(item,index) in videos\" :key=\"index\">\r\n                    <view class=\"swiper-item\">\r\n                        <video-player                         \r\n                             :video=\"item\"                        \r\n                            :index=\"index\">\r\n                        </video-player>\r\n                    </view>\r\n                    <view class=\"left-box\"> <!--将左侧信息栏组件放到<swiper-item>中同视频一起渲染出来-->\r\n                        <list-left></list-left>\r\n                    </view>\r\n                </swiper-item>\r\n            </swiper>\r\n        </view>\r\n    </view>\r\n</template>\r\n\r\n<style>\r\n.left-box { <!--给左侧列表组件添加绝对定位 并设置z-index以显示到视频上方-->\r\n        position: absolute;\r\n        bottom: 50px;\r\n        left: 10px;\r\n        z-index: 20; \r\n}\r\n</style>三、创建右侧图标栏组件右侧图标栏组件，主要分为: 头像图标(头像设置border-radius)、收藏图标(iconfont图标)、评论图标(iconfont图标)、分享图标(iconfont图标)、音乐图标(图片设置border-radius)，右侧图标栏组件设置一个固定宽度，然后让各种图标依次排列即可，如:// components/list-right.vue<template>\r\n    <view class=\"list-right\">\r\n        <view class=\"author-img\">\r\n            <img class=\"img\" src=\"../static/zxh.jpg\"/>\r\n        </view>\r\n        <view class=\"right-box\">\r\n            <view class=\"icon iconfont icon-xin\"></view>\r\n            <view class=\"count\">72.2w</view>\r\n        </view>\r\n        <view class=\"right-box\">\r\n            <view class=\"icon iconfont icon-pinglun1\"></view>\r\n            <view class=\"count\">1.8w</view>\r\n        </view>\r\n        <view class=\"right-box\">\r\n            <view class=\"icon iconfont icon-arrow-\"></view>\r\n            <view class=\"count\">6645</view>\r\n        </view>\r\n        <view class=\"music-img\">\r\n            <img class=\"img\" src=\"../static/music.jpg\"/>\r\n        </view>\r\n    </view>\r\n</template>\r\n\r\n<style scoped>\r\n    .list-right {\r\n        width: 60px;\r\n    }\r\n    .author-img {\r\n        width: 60px;\r\n        text-align: center;\r\n    }\r\n    .img {\r\n        width: 50px;\r\n        height: 50px;\r\n        border-radius: 50%;\r\n    }\r\n    .author-img img{\r\n        border: 2px solid #FFFFFF;\r\n    }\r\n    .right-box {\r\n        margin: 20px auto;\r\n        color: white;\r\n        text-align: center;\r\n        font-size: 12px;\r\n    }\r\n    .icon {\r\n        font-size: 40px;\r\n    }\r\n    .music-img {\r\n        width: 60px;\r\n        height: 51px;\r\n        text-align: center;\r\n        margin-top: 20px;\r\n        animation: around 1.5s linear 0.2s infinite; <!--使用动画-->\r\n    }\r\n    @keyframes around { <!--添加360环绕旋转动画-->\r\n        0% {\r\n            transform: rotate(0deg);\r\n        }\r\n        100% {\r\n            transform: rotate(360deg);\r\n        }\r\n    }\r\n</style>四、给右侧图标组件添加上相应的事件当点击头像下部的加号图标，可以对该用户进行关注，即隐藏加号图标，还有就是收藏爱心图标颜色切换，当点击收藏爱心图标，爱心图标变成红色，再次点击收藏爱心图标，爱心图标变回白色，这里先只处理颜色的变化，具体后台交互暂不处理。// 在头像图标下方通过绝对定位添加一个加号图标，并定位到头像底部<view class=\"author-img\">\r\n    <img class=\"img\" src=\"../static/zxh.jpg\"/>\r\n    <view class=\"follow iconfont icon-jiahao\" v-show=\"showFollow\" @click=\"hideFollow\"><!--添加一个加号图标，以及监听hideFollow事件-->\r\n    </view>\r\n</view>\r\n\r\n<view class=\"right-box\">\r\n    <view class=\"icon iconfont icon-xin\" :class=\"{fav: isFav}\" @click=\"changeColor\"></view><!--监听切换收藏爱心图标颜色-->\r\n    <view class=\"count\">72.2w</view>\r\n</view>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                showFollow: true,\r\n                isFav: false\r\n            }\r\n        },\r\n        methods: {\r\n            hideFollow() { // 隐藏关注加号图标\r\n                this.showFollow = false;\r\n            },\r\n            changeColor() {\r\n                this.isFav = !this.isFav; // 切换收藏爱心颜色\r\n            }\r\n        }\r\n    }\r\n</script>\r\n<style scoped>\r\n.follow {\r\n        color: white;\r\n        position: absolute;\r\n        width: 18px;\r\n        height: 18px;\r\n        line-height: 18px;\r\n        background: red;\r\n        border-radius: 50%;\r\n        text-align: center;\r\n        left: 23px;\r\n        bottom: -5px;\r\n        font-weight: bold;\r\n}\r\n.fav {\r\n        color:red;\r\n}\r\n</style>五、实现滑动播放功能所谓滑动播放，即向上滑动的时候，暂停当前播放视频并且播放下一个视频，向下滑动的时候，暂停当前播放视频，播放上一个视频，而这最关键的就是如何判断是向上滑动还是向下滑动。<swiper>组件给我们提供了一个change事件，我们可以监听这个change事件，拿到滑动完成后滑动到了第几页，即<swiper-item>的序号(从0开始)，然后与滑动前的当前page相比较，就可以知道是向上滑还是向下滑了。判断好了是上滑还是下滑后，我们还需要对上滑和下滑作出正确的处理，我们需要能够拿到每个视频播放组件，然后调用视频播放组件上的相关方法对播放进行控制，这就是涉及到了父组件如何调用子组件上方法，父组件要想调用子组件上的方法，关键是父组件要能够拿到子组件对象，我们可以通过ref实现，因为每一个视频播放组件是video-list视频列表组件的一个子组件，所以我们可以在video-list视频列表组件中给每一个video-player视频播放组件添加上一个ref=\"player\"，即可拿到对应的视频播放组件了。// components/video-list.vue<swiper class=\"swiper\" :vertical=\"true\" @change=\"slider\"> <!--监听change事件-->\r\n    <swiper-item v-for=\"(item,index) in videos\" :key=\"index\">\r\n        <view class=\"swiper-item\">\r\n            <video-player\r\n                ref=\"players\" <!--给每一个视频播放组件添加一个ref标识-->\r\n                :video=\"item\"                        \r\n                :index=\"index\">\r\n            </video-player>\r\n        </view>\r\n    </swiper>\r\n</swiper>\r\n<script>\r\nexport default {\r\n    data() {\r\n        return {\r\n            currentPage: 0 // 保存当前page的编号\r\n        }\r\n    },\r\n    methods: {\r\n        slider(e) {\r\n            const targetPage = e.detail.current;\r\n            if (targetPage === this.currentPage + 1) {\r\n                console.log(\"向上滑动\");\r\n                this.$refs.players[this.currentPage + 1].playFromHead(); // 下一个开始播放并且从头开始播放\r\n                this.$refs.players[this.currentPage].pause(); // 当前视频暂停播放\r\n            } else if(targetPage === this.currentPage - 1) {\r\n                console.log(\"向下滑动\");\r\n                this.$refs.players[this.currentPage - 1].playFromHead(); // 上一个开始播放并且从头开始播放\r\n                this.$refs.players[this.currentPage].pause(); // 当前视频暂停播放\r\n            }\r\n                this.currentPage = targetPage;\r\n        }\r\n    }\r\n}\r\n</script>需要注意的是，this.$refs.players返回的是一个数组，即所有播放组件的实例，我们通过不同的索引即可取得对应的视频播放组件，然后进行相应的播放控制了，接下来就是要给每一个视频播放组件添加上播放控制的方法，我们需要给<video>组件添加上一个id，然后通过这个id可以创建出video上下文，即可调用play()、pause()、seek()等相关方法对播放进行控制。// components/video-player.vue<template>\r\n    <view class=\"video-player\">\r\n        <video class=\"video\"\r\n               id=\"myVideo\" <!--给video组件添加一个id，以便获取到video上下文对象-->\r\n               :src= \"video.src\" \r\n               :controls=\"false\"\r\n               :loop=\"true\">\r\n        </video>\r\n    </view>\r\n</template>\r\n<script>\r\nexport default {\r\n    onReady() {\r\n            this.videoContext = uni.createVideoContext(\"myVideo\", this); // 获取video上下文对象\r\n    },\r\n    methods: {\r\n        play() {\r\n            this.videoContext.play();\r\n        },\r\n        pause() {\r\n            this.videoContext.pause();\r\n        },\r\n        playFromHead() { // 跳转到开始位置并播放\r\n            this.videoContext.seek(0);\r\n            this.play();\r\n        }\r\n    }\r\n}\r\n</script>六、实现单击播放暂停切换以及双击关注用户功能要想实现单击视频播放组件，视频可以进行播放和暂停切换，那么我们需要给视频播放组件添加一个isPlay属性表示视频是否处于播放中，如果是播放中，那么点击就暂停，如果不是播放中，那么点击就播放，同时，由于uni-app不支持vue的dblclick事件的，所以我们还需要对单击和双击操作进行判断，我们需要定义一个变量用于记录用户点击次数，如果300ms内用户点击次数大于等于2，那么就是双击，否则就是单击，如:<template>\r\n    <view class=\"video-player\">\r\n        <video class=\"video\"\r\n               id=\"myVideo\"\r\n               :src= \"video.src\" \r\n               :controls=\"false\"\r\n               :loop=\"true\"\r\n               @click=\"doClick\"><!--添加click事件进行视频播放和暂停的切换-->\r\n        </video>\r\n    </view>\r\n</template>\r\n<script>\r\n    let timer = null; // 定义一个定时器\r\n    export default {\r\n        data() {\r\n            return {\r\n                isPlay: false, // 当前视频是否在播放中，默认为false\r\n                clickCount: 0 // 记录当前用户点击次数，默认为0\r\n            }\r\n        },\r\n        methods: {\r\n            play() {\r\n                this.videoContext.play();\r\n                this.isPlay = true; // 进入视频播放状态设置isPlay为true\r\n            },\r\n            pause() {\r\n                this.videoContext.pause();\r\n                this.isPlay = false; // 进入视频暂停状态设置isPlay为false\r\n            },\r\n            playFromHead() {\r\n                this.videoContext.seek(0);\r\n                this.play();\r\n            },\r\n            doClick() { // 进行视频播放和暂停的切换\r\n                if (timer) {\r\n                    clearTimeout(timer);\r\n                }\r\n                this.clickCount++; // 每次单击视频播放组件，点击次数加1\r\n                timer = setTimeout(() => {\r\n                    if (this.clickCount >=2 ) { // 如果300ms内点击次数大于等于2就表示是双击了\r\n                        console.log(\"双击\");\r\n                        this.$emit(\"follow\"); // 双击的话向video-list父组件(视频列表组件)发送一个follow事件\r\n                    } else {\r\n                        console.log(\"单击\");\r\n                        if (this.isPlay) {\r\n                            this.pause();\r\n                        } else {\r\n                            this.play();\r\n                        }\r\n                    }\r\n                    this.clickCount = 0; // 重置点击次数为0\r\n                }, 300);\r\n            }\r\n        }\r\n    }\r\n</script>双击的时候会向video-list父组件(视频列表组件)发送一个follow事件，video-list组件监听到follow事件后再通知<list-right>组件调用其方法让其爱心图标变红即可，如:<template>\r\n    <video-player\r\n        @follow=\"follow\">\r\n    </video-player>\r\n    <view class=\"right-box\">\r\n        <list-right ref=\"listRight\"></list-right> <!--给list-right组件添加ref标识-->\r\n    </view>\r\n</template>\r\n<script>\r\n    export default {\r\n        follow() {\r\n            this.$refs.listRight[0].follow();\r\n        }\r\n    }\r\n</script>七、实现首个视频自动播放功能之前我们的视频播放组件接收了一个index属性，即当前视频对应的索引号，我们可以通过这个索引号判断当前视频是否是第一个，然后将其video组件的autoPlay设置为true即可自动播放。<template>\r\n    <view class=\"video-player\">\r\n        <vide :autoplay=\"auto> <!--绑定autoplay属性控制是否自动播放-->\r\n        </video>\r\n    </view>\r\n</template>\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                auto: false // 是否自动播放\r\n            }\r\n        },\r\n        methods: {\r\n            autoPlay() {\r\n                if (this.index === 0) {\r\n                    this.auto = true;\r\n                }\r\n            }\r\n        },\r\n        created() {\r\n            this.autoPlay();\r\n        }\r\n    }\r\n</script>至此，首页已经完成，效果图如下:"}
{"title": "使用 async await 封装微信小程序HTTP请求 ", "author": "Rolan", "pub_time": "2019-10-9 00:55", "content": "1. 编写将普通回调函数形式的方法转换为promise方法的promisic方法 1 // util.js\r\n 2 const promisic = function (func) {\r\n 3     return function (params = {}) {\r\n 4         return new Promise((resolve, reject) => {\r\n 5             const args = Object.assign(params, {\r\n 6                 success: (res) => {\r\n 7                     resolve(res)\r\n 8                 },\r\n 9                 fail: (error) => {\r\n10                     reject(error)\r\n11                 }\r\n12             })\r\n13             func(args)\r\n14         })\r\n15     }\r\n16 }\r\n17 \r\n18 export {\r\n19     promisic\r\n20 } 2. 编写Http类封装HTTP请求 1 // http.js\r\n 2 import { promisic } from \"./util\"\r\n 3 import { config } from \"../config/config\"\r\n 4 \r\n 5 /**\r\n 6  * 使用 async await 封装HTTP请求\r\n 7  */\r\n 8 class Http {\r\n 9 \r\n10     static async request({ url, method='GET', data }) {\r\n11         // 将wx.request方法转换成promise方法\r\n12         const res = await promisic(wx.request)({\r\n13             url: `${config.apiBaseUrl}${url}`,\r\n14             method,\r\n15             data,\r\n16             header: {\r\n17                 appkey: config.appkey\r\n18             }\r\n19         })\r\n20         return res.data\r\n21     }\r\n22 \r\n23 }\r\n24 \r\n25 export {\r\n26     Http\r\n27 } 3. 编写Theme业务类调用封装好的Http请求// theme.js\r\nimport { Http } from \"../utils/http\"\r\n\r\n/**\r\n * 编写主题请求业务类\r\n */\r\nclass Theme {\r\n\r\n    /**\r\n     * 获取首页主题A\r\n     */\r\n    static async getHomeLocationA() {\r\n        return await Http.request({\r\n            url: 'xx/xx/xxx',\r\n            data: {\r\n                names: 't-1'\r\n            }\r\n        })\r\n    }\r\n\r\n}\r\n\r\nexport {\r\n    Theme\r\n} 4. 在page中调用Theme业务类获取首页主题A方法 1 // home.js\r\n 2 import { Theme } from '../../model/theme'\r\n 3 \r\n 4 Page({\r\n 5 \r\n 6   data: {\r\n 7     topTheme: {}\r\n 8   },\r\n 9 \r\n10   async onLoad (options) {\r\n11     // 获取首页主题A\r\n12     const data = await Theme.getHomeLocationA()\r\n13     this.setData({\r\n14         topTheme: data[0]\r\n15     })\r\n16   }\r\n17 \r\n18 }) 附上目录结构  这样就可以愉快地使用async await形式的Http请求了，彻底摆脱各种callback方法！"}
{"title": "网易云歌单重合率2.0 ", "author": "Rolan", "pub_time": "2019-10-11 00:31", "content": "前言 \r\n之前写过一个小工具输入网易云音乐上的昵称，即可查看两人喜欢的音乐中，有哪些是相同的，重合率有多少。\r\n感兴趣的可以看这里：\r\n网易云歌单重合率1.0\r\n但是之前的版本存在几个问题：\r\n\r\n速度慢，这个其实是最难受的，平均 20 s以上，因为当时水平有限，使用的selenium相当于模拟了人工搜索，找用户，找歌单，筛选歌曲的过程，会获取很多不必要的信息。速度自然比接口慢很多很多。\r\n体验差，样式也很丑，作为一个小工具，一个链接想再用的时候基本找不到了。\r\n服务经常性不可用。\r\n\r\n但是在我 github 搜网易云的时候发现了一个大佬用 Node.js 写的项目 https://github.com/Binaryify/NeteaseCloudMusicApi  提供了一系列网易云相关的接口，这就很巧了，朋友们，我缺的就是接口啊。（ps:感兴趣的读者可以去 github 上围观这个项目，我只是用了很少的几个接口做成了该工具，事实上，你甚至可以利用其做一个个人风格版的网易云音乐。）\r\n其次前段时间正好买了两本微信小程序的书，而小程序的应用场景之一就是小工具，用完即走。加起来可以完美解决上面三个问题。于是就有了这次的网易云歌单重合率2.0。当然我这个小程序只是练手用，我也没想到如此简陋竟然能通过审核。\r\n使用 \r\n感兴趣可以先直接用微信扫描下方的小程序码体验。\r\n\r\n它用起来大概是这样：\r\n\r\n思路 \r\n代码其实很简单，就不贴了，只说思路。\r\n其实与1.0很相似了，只是以前用PhantomJS和selenium改成用接口获取。\r\n\r\n通过搜索接口传入昵称获取到用户id，\r\n用用户id，拿到喜欢的歌单id，\r\n上传歌单id，获取到歌单详情，即所有的歌曲id。\r\n歌曲id进行比对，重合的歌曲id上传到歌曲详情接口，获取到所有重合歌曲的名字歌手所属专辑等等。\r\n\r\n遇到的问题 \r\n\r\nhttp 转 https \r\n微信的后台只支持 https ,而一般默认https都是用 443 接口，然后 80 端口转到 443 端口，实现 http 转 https 。但是这个项目在服务器用另外一个端口，比如是 5000 ，那么我就必须要申请另外一个端口给这个 5000 用SSL。很麻烦，最简单的方法就是另外用一个二级域名，比如之前是 api.xxx.com 则 这个服务就用node.xxx.com ,然后给 node.xxx.com 申请SSL证书。然后添加反向代理，把 node.xxx.com 转到api.xxx.com:3000 。这样就实现了访问 https://node.xxx.com ,但是实际调用到 http://api.xxx.com:3000 服务。可能有些绕口。\r\n需要注意的是现在免费的话基本只能申请单域名，比如 api.xxx.com ，不能免费申请 *.xxx.com 这种泛域名的证书。至于申请证书后的操作，可自行百度，很多教程，我服务器是腾讯的，通过腾讯云申请后，在宝塔面板添加到SSL>其他证书里的，比较简单快捷。\r\n小程序文本透明度渐显动画\r\n把动画赋值给anim数组元素，然后view绑定这个元素动画。目前是这么实现的，可能存在不合理的地方，欢迎探讨。\r\n//detail.js//获取应用实例const app = getApp()Page({ data: {   anim:[{}], },textShow:function(index){   var animation = wx.createAnimation({     duration: 2000,   });   var key = 'anim[' + index + ']';   animation.opacity(1).step({})   this.setData({     [key] : animation.export(),   }) }, //使用的时候 page.textShow(0); page.textShow(1);})<!--pages/detail/detail.wxml--><view animation=\"{{anim[0]}}\" style=\"opacity:0\" class=\"textViewTitle\">你的昵称:</view><view animation=\"{{anim[1]}}\" style=\"opacity:0\" class=\"textViewTitle\">对方昵称:</view>复制代码\r\n转发功能\r\n一开始上线后，惊人的发现不让转发，一番搜索后才发现，转发分享需要自己实现，并且可以带参。\r\n我实现的效果是在主界面转发只会转发该小程序，不会携带昵称。在结果界面转发会携带昵称，对方点击后直接看结果。\r\n只要重写onShareAppMessage方法即可，path可以携带参数，代码大致如下：\r\n//首页jsonShareAppMessage: function (res) {   if (res.from === 'button') {     // 来自页面内转发按钮     console.log(res.target)   }   return {     title: '网易云歌单重合率',     path: 'pages/index/index',     success: function (res) {       // 转发成功       wx.showToast({         title: '转发成功',         icon: 'none'       })     },     fail: function (res) {       // 转发失败       wx.showToast({         title: '转发失败',         icon: 'none'       })     }   } } //结果js onShareAppMessage: function (res) {   if (res.from === 'button') {     // 来自页面内转发按钮     console.log(res.target)   }   return {     title: '网易云歌单重合率',     path: '/pages/detail/detail?myUserName=' + this.data.myUserName + '&otherName=' + this.data.otherName,     success: function (res) {       // 转发成功       wx.showToast({         title: '转发成功',         icon: 'none'       })     },     fail: function (res) {       // 转发失败       wx.showToast({         title: '转发失败',         icon: 'none'       })     }   } }复制代码\r\n\r\n总结 \r\n总的来说，小程序开发是非常容易上手的，如果有什么想法的话，不一定非要在Android ,IOS上做一个成品app的，我觉得完全可以借鉴现有的平台试水，比如小程序就是一个不错的平台，开发上手很快，审核也很快。完全可以先用小程序看看方案和思路是否可行，之后再决定是否要做成品app。"}
{"title": "uni-app相关知识总结 ", "author": "Rolan", "pub_time": "2019-10-12 00:43", "content": "一、默认导航栏uni-app默认会提供一个导航栏，即 小程序的导航栏 ，我们不需要进行任何的配置就会显示， 默认导航栏的配置同微信小程序 ，只不过微信小程序的组件是分为.wxml、.wxss、.js、.json四个文件组成，而 uni-app的组件则只有一个.vue文件 (其中包含了html、css、js)，其中并未包含.json的相关内容，那么.json配置写在哪里呢？.json文件主要是 对页面的 窗口表现及页面相关功能进行配置，所以unip在pages.json文件中注册页面的时候，给每个page页面提供了一个style属性，用于对当前页面的窗口表现( 窗口 样式、 导航栏 样式)及功能( 页面下拉刷新 、 页面能否滚动等)，如:{\r\n    \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\r\n        {\r\n            \"path\": \"pages/index/index\",\r\n            \"style\": { // 对窗口及其页面表现进行配置\r\n                \"navigationBarTitleText\": \"导航标题\", // 设置默认导航栏标题文字内容\r\n                \"navigationBarTextStyle\": \"white\", // 设置默认导航栏标题文字颜色及状态栏上文字颜色，仅支持black和white\r\n                \"navigationBarBackgroundColor\": \"#4CD964\", // 设置默认导航栏背景颜色及状态栏背景颜色，仅支持十六进制颜色值\r\n                \"navigationStyle\": \"default\", // 支持defaul和custom两种，设置custom(自定义)后，默认导航栏将消失，微信小程序上只保持右上角胶囊按钮\r\n                \"backgroundColor\":\"#ADFF2F\", // 设置窗口背景颜色，开启下拉刷新之后，下拉后可见该背景颜色(黄色)，仅小程序端生效\r\n                \"enablePullDownRefresh\": true, // 是否开启页面下拉刷新功能\r\n                // 上拉刷新不需要开启，页面提供了一个触底事件onReachBottom，只要页面存在滚动条，滚动条触底后就可以触发触底事件，从而进行下拉刷新\r\n                \"onReachBottomDistance\": 0, // 当滚动条距离底部的距离为指定值的时候则判定为触底\r\n                \"disableScroll\": false, // 页面能否滚动，如果为true则禁用页面滚动功能，及时页面设置的高度超过了屏幕高度也不会发生滚动，仅小程序端生效\r\n                \"usingComponents\": { // 配置是否使用小程序提供的自定义组件，这里的小程序组件不是.vue组件，而是小程序提供的原生组件，App端也支持\r\n                    \"custom\": \"/wxcomponents/custom/index\"\r\n                },\r\n                // \"backgroundTextStyle\":\"dark\", // 设置下拉 loading 的样式，仅支持dark和light,无明显用处\r\n            }\r\n        }\r\n    ]\r\n}需要注意的就是usingComponents的配置，其配置的是使用 小程序提供的原生组件(如包含.wxml、.wxss、.js、.json的组件) ，而不是.vue组件。同时 状态栏上文字颜色仅支持black和white，即非黑即白，状态栏背景色同导航栏背景颜色二、原生导航栏uni-app运行在app端的时候，还提供了原生导航栏，其在注册页面的时候，style还提供了一个 app-plus 属性用于 配置app端 页面窗口、导航栏样式的配置，导航栏的配置通过titleNView属性，如:{\r\n    \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\r\n        {\r\n            \"path\": \"pages/index/index\",\r\n            \"style\": { // 对窗口及其页面表现进行配置\r\n                \"app-plus\": {\r\n                    // \"titleNView\": false // 禁用原生导航栏，即当前页面不显示原生导航栏\r\n                    \"scrollIndicator\":\"none\", // 设置是否显示页面滚动条，设置为none，滚动时看不到右侧的滚动条\r\n                    \"pullToRefresh\": {\r\n                        \"style\":\"default\" // 设置下拉刷新样式，只支持default和circle\r\n                    },\r\n                    \"bounce\":\"none\", // 设置页面回弹效果，none关闭回弹效果\r\n                    // \"titleNView\": { // 空对象不会对默认导航栏进行替换，必须进行相关配置才会对默认导航栏进行修改\r\n                        \r\n                    // },\r\n                    \"titleNView\": { // 对原生导航栏进行配置\r\n                        \"titleText\": \"原生导航栏标题内容\", // 标题内容与搜索框只能显示一个\r\n                        \"buttons\": [ // 在原生导航栏上添加按钮\r\n                            {\r\n                                // \"type\":\"share\", // 使用 type 值设置按钮的样式时，会忽略 fontSrc 和 text 属性。\r\n                                \"fontSrc\":\"./static/font/icon.ttf\", // 使用字体图标\r\n                                \"text\": \"\\ue609\", // 使用字体图标时 unicode 字符表示必须 '\\u' 开头\r\n                                \"fontSize\":\"22px\",\r\n                                \"color\":\"#FF9619\", \r\n                                \"colorPressed\":\"#BBBBBB\",\r\n                                \"select\": false, // 是否显示右侧向下箭头图标常用于城市选择\r\n                                \"float\":\"left\" // 按钮放在导航栏左侧\r\n                            },\r\n                            {\r\n                                // \"type\":\"favorite\", // 使用 type 值设置按钮的样式时，会忽略 fontSrc 和 text 属性。\r\n                                \"fontSrc\":\"./static/font/icon.ttf\",\r\n                                \"text\": \"\\ue653\", // 使用字体图标时 unicode 字符表示必须 '\\u' 开头\r\n                                \"fontSize\":\"22px\",\r\n                                \"color\":\"#000000\",\r\n                                \"colorPressed\":\"#BBBBBB\",\r\n                                \"select\": false, // 是否显示右侧向下箭头图标常用于城市选择\r\n                                \"float\":\"right\" // 按钮放在导航栏右侧\r\n                            }\r\n                        ],\r\n                        \"searchInput\": { // 是否在原生导航栏上添加搜索框，一旦添加搜索框，那么导航栏标题内容将无法显示，因为搜索框是放在标题的位置，对标题进行了替换\r\n                            \"align\":\"center\",\r\n                            \"backgroundColor\":\"#F7F7F7\",\r\n                            \"borderRadius\":\"4px\",\r\n                            \"placeholder\":\"搜索\",\r\n                            \"disabled\": true\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    ]\r\n}三、自定义导航栏要想自定义导航栏，我们必须先让默认导航栏或者原生导航栏隐藏，在小程序端可以通过 \"navigationStyle\":\"custom\" 隐藏，app端则可以通过 \"titleNView\": false 进行隐藏，如:{\r\n    \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\r\n        {\r\n            \"path\" : \"pages/contact/contact\",\r\n            \"style\" : {\r\n                \"navigationStyle\":\"custom\", // 隐藏小程序端导航栏\r\n                \"app-plus\": {\r\n                    \"titleNView\": false // 隐藏app端原生导航栏\r\n                }\r\n            }\r\n        }\r\n     ]\r\n}使用自定义导航栏导航后，由于默认导航栏和原生导航栏都消失了，所以原先导航栏的位置就被空出来了，我们可以 通过自定义一个导航视图组件占据原先导航栏的位置即可实现 ，但是下拉刷新会有问题，因为页面的下拉刷新是从顶部开始的，之前 有默认导航和原生导航的时候 ， 页面的顶部就是导航栏底部 ，但是默认导航和原生导航隐藏后， 顶部就变成了原先导航栏的顶部了 ，所以 页面下拉刷新的位置向上移了 ，使用自定义导航栏后最好不要在页面中使用下拉刷新功能了。如果非要使用下拉刷新功能的话，我们可以通过<scroll-view>组件来模拟下拉刷新。即 监听<scroll-view>组件的@scrolltoupper事件判断是否到达顶部，然后监听@scroll事件，判断下拉的位置，然后动态改变下拉刷新的样式、动画 从而模拟出下拉刷新效果。<view class=\"pull-down iconfont icon-liulan\" :style=\"{transform: 'rotate(' + detal+ 'deg)'}\"></view>\r\n<scroll-view scroll-y class=\"scroll-box\" @scrolltoupper=\"pullDown\" @scroll=\"scroll\">\r\n</scroll-view>\r\nexport default {\r\n    methods: {\r\n        pullDown(e) {\r\n            // console.log(e);\r\n        },\r\n        scroll(e) { // 根据下拉的距离改变detal的值从而改变下拉刷新图标的选择角度\r\n            this.detal = e.detail.scrollTop + 100;\r\n        }\r\n    }\r\n}四、vue与nvuenvue即 native vue 。uni-app App端内置 weex 渲染引擎，提供了原生渲染能力。 uni-app默认是处于uni-app的渲染模式 ，即小程序渲染模式，如果要启用纯原生渲染模式，即weex渲染模式，那么需要在 manifest.json 源码视图的 \"app-plus\" 下配置 \"renderer\":\"native\" ，开启原生渲染模式后， pages.json注册的vue页面将被忽略 ，启动纯原生渲染，可以减少App端的包体积、加快App启动速度。因为webview渲染模式的相关模块将被移除了。// manifest.json    \r\n{    \r\n    // ...    \r\n     /* App平台特有配置 */    \r\n    \"app-plus\": {    \r\n        \"renderer\": \"native\", //App端纯原生渲染模式\r\n    }    \r\n}在未开启weex原生渲染模式的情况下，即uni-app模式下也是可以直接渲染.nvue文件的， 不管是vue页面还是nvue页面，都需要在pages.json中注册 ，并且如果一个页面下出现了两个同名的vue和nvue文件，那么在 App端 ， 会优先使用nvue页面 ，同名的vue文件将不会被编译到App端。而在 非App端 ， 会优先使用vue页面 。.nve文件的写法同.vue文件一样，只不过，.nvue文件中可以还使用一些weex提供的特有组件，比如<barcode>、<list>、<cell>、<refresh>等。五、subNvuesubNvue ，是 vue 页面的原生子窗体，其会 把weex渲染的原生界面当做 vue 页面的子窗体覆盖在页面上 ，主要解决 运行在App端时 ， 视图无法覆盖在<video>、<map>等组件上 的问题( 非App端可以通过z-index或者cover-view解决 )，subNvue的使用方式非常简单，只需要 新建一个.nvue文件 ，建议放在母页面目录中，但是 subNvue页面不需要注册到pages.json中 ，而是 在母页的\"style\"--> \"app-plus\" --> \"subNVues\"进行配置 ，因为subNvue主要解决App端层级覆盖问题，所以需要在\"app-plus\"下配置，需要注意的是 subNVues是一个数组 ，每个元素为一个原生子窗体，因为一个母页中可以包含多个原生子窗体，每个原生子窗体通过配置中的id进行区分。配置好subNvues后，对应的原生子窗体默认就会显示。{\r\n    \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\r\n        {\r\n        \"path\" : \"pages/video/video\", // 母页面路径\r\n        \"style\" : {\r\n            \"navigationBarTextStyle\":\"white\",\r\n            \"app-plus\": {\r\n                \"titleNView\":false,\r\n                \"subNVues\":[{  \r\n                            \"id\": \"test\", // 唯一标识，母页面中可以通过这个id调用api获取到原生子窗体  \r\n                            \"path\": \"pages/video/subNVue/cover\", // video母页面下原生子窗体页面路径  \r\n                            // \"type\": \"popup\",  //这里不需要\r\n                            \"style\": {  \r\n                                \"position\": \"absolute\",  \r\n                                // \"dock\":\"right\",\r\n                                \"width\": \"750rpx\",  \r\n                                \"height\": \"150upx\", // 需要设置合适的高度，否则可能出现无法点击原生子窗体下面的内容 \r\n                                \"background\":\"transparent\" // 设置为透明，以便能看到原生子窗体下面的内容 ，如果有背景颜色，则全屏可见\r\n                            }  \r\n                 }]\r\n            }\r\n        }\r\n    ]\r\n}pages.json文件中配置好原生子窗体后，不需要向vue组件一样引入到母页中，直接就会出现在母页面上，具体位置根据subNVues中的配置而定。六、优化自定义导航栏下拉刷新功能前面说过，使用自定义导航栏需要隐藏掉默认导航栏和原生导航栏，但是会存在一个问题，就是页面下拉刷新会跟着上移到了最顶部，导致页面下拉刷新位置不正确，之前的方法是使用<scroll-view>方法进行模拟， 但是官方并不推荐该方法 ，我们可以通过原生子窗口实现，其实现方法非常简单，就是用原生子窗口占据原生导航栏的位置，其中关键的一步就是，在配置原生子窗体的时候， 需要将其type设置为navigationBar类型 ，该原生子窗体就会站住原生导航栏的位置，并且下拉刷新图标不会向上移，如:{\r\n    \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\r\n        {\r\n        \"path\" : \"pages/nav/nav\",\r\n        \"style\" : {\r\n            \"navigationBarTextStyle\":\"white\",\r\n            \"navigationBarBackgroundColor\":\"#007AFF\",\r\n            \"enablePullDownRefresh\": true,\r\n            \"app-plus\": {\r\n                \"titleNView\": false,\r\n                \"subNVues\": [\r\n                    {\r\n                        \"id\":\"nav\",\r\n                        \"path\":\"pages/nav/subNvue/nav\",\r\n                        \"type\":\"navigationBar\" // 设置为navigationBar类型才能让原生子窗体站住原生导航栏的位置\r\n                    }\r\n                ]\r\n            }\r\n        }\r\n    },\r\n    ]\r\n}pages/nav/subNvue/nav.nvue<template>\r\n    <div class=\"nav\">\r\n        <div class=\"status-bar\"></div>\r\n        <div class=\"nav-title\">\r\n            <div>我是导航栏</div>\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        \r\n    }\r\n</script>\r\n\r\n<style scoped>\r\n.nav { /*.nvue页面中的所有元素都是flex布局,不需要进行显示设定*/\r\n    flex: 1; /*占满整个导航栏高度,当该原生子窗体页面被设置为navigationBar类型后,会自动给予该页面一个导航高度,占满即可*/\r\n    background-color: #007AFF;\r\n}\r\n.status-bar { /*状态栏占位区,下面导航标题栏已经设置了44px高度，让状态栏占满剩余高度*/\r\n    flex: 1; \r\n}\r\n.nav-title {\r\n    flex: 0;\r\n    height: 44px; /*导航栏固定高度为44px*/\r\n    background-color: #007AFF;\r\n    justify-content: center;\r\n    align-items: center;/*导航栏标题区垂直居中显示*/\r\n}\r\n</style>七、实现抽屉效果所谓抽屉效果就是，就是页面上触发某种事件后，页面上方有一个页面从屏幕的一侧开始滑出覆盖到原来页面的上方，然后点击空白处，该页面又可以收回去的效果。要实现这种效果，我们也是需要利用原生子窗体，将抽屉页面做成一个原生子窗体覆盖在页面上方，其中关键的一步，就是 需要将其type设置为popup类型 ， 设置为popup类型之后 ， 该页面默认不会出现在母页面上 ，需要通过调用api才能让该抽屉页面显示出来。如:{\r\n    \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages\r\n        {\r\n        \"path\" : \"pages/nav/nav\",\r\n        \"style\" : {\r\n            \"navigationBarTextStyle\":\"white\",\r\n            \"navigationBarBackgroundColor\":\"#007AFF\",\r\n            \"enablePullDownRefresh\": true,\r\n            \"app-plus\": {\r\n                \"titleNView\": false,\r\n                \"subNVues\": [\r\n                    {\r\n                        \"id\":\"drawer\",\r\n                        \"path\":\"pages/nav/subNvue/drawer\",\r\n                        \"type\":\"popup\",\r\n                        \"style\": {\r\n                            \"width\":\"50%\" // 只显示整个屏幕宽度的50%,高度默认为屏幕100%\r\n                        }\r\n                    }\r\n                ]\r\n            }\r\n        }\r\n    },\r\n    ]\r\n}pages/nav/subNvue/nav.nvue 母页通过api控制原生子窗体的显示和隐藏<template>\r\n    <view>\r\n        母页面\r\n        <button @click=\"showDrawer\">显示抽屉</button>\r\n    </view>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                \r\n            }\r\n        },\r\n        methods: {\r\n            showDrawer() {\r\n                uni.getSubNVueById('drawer').show(\"slide-in-left\", 200); // 从屏幕左侧向右边滑入，耗时200ms\r\n            }\r\n        }\r\n    }\r\n</script>同样的方式也可以实现页面中间显示弹出框效果，只需要改变原生子窗体的位置即可，即将其定位到正中间，如:{\r\n    \"id\":\"drawer\",\r\n    \"path\":\"pages/nav/subNvue/drawer\",\r\n    \"type\":\"popup\",\r\n    \"style\": {\r\n        \"margin\":\"auto\", // 居中显示\r\n        \"height\":\"50%\",\r\n        \"width\":\"80%\"\r\n    }\r\n}"}
{"title": "小程序下找地点、查路线、搜地铁，用这3个插件就够了！ ", "author": "Rolan", "pub_time": "2019-10-14 00:19", "content": "自从2017年微信上线小程序以来，小程序已经迅速成长为一个巨大的生态，吸引各行各业的开发者或服务商参与其中。而由于小程序与线下场景的结合日益紧密，地图类功能已经成为越来越多小程序的“标配”，背后也大部分直接或间接的依赖腾讯位置服务提供的地图能力：如出行利器小程序「摩拜单车」，吃喝玩乐的小程序「美团外卖」，圈粉无数的小程序「玩转故宫」，校园导览类小程序「清华校园导览」，领略大美云南的「游云南」等等。一般来说，如果只是开发一些简单的地图功能，小程序开发者还可以轻松应对；但随着地图应用场景的增多，开发者就可能需要用到比如路线规划、地图选点等比较高级的地图能力，这就需要开发者掌握比较复杂的地图接口，开发难度提升，成本较高。为了帮助开发者“减负”，腾讯位置服务推出了「路线规划」「地图选点」「地铁图」三款小程序插件，帮助开发者5分钟内快速搭建属于你的地图能力！​路线规划插件路线规划插件提供路线规划等功能，根据起终点，多种出行方式智能规划最佳出行路线及详情。开发者可以将路线规划插件嵌入到自建小程序的页面里，实现路线规划功能。1、大数据加持，智能推荐多种出行方案给出用户合理路线规划是最基本功能，而能否通过大数据及实时路况智能呈现更合适的方案，甚至比用户多想一步超出其预期，才是提升产品体验、提高用户粘度的关键。目前路线规划插件可以为用户提供驾车、公交、步行三种出行方式，其中驾车出行方式基于全面的路网信息，结合实时路况，为用户智能提供多种出行方案；公交出行方式也提供了多种公交换乘方案，用户可以根据偏好选择最佳方案。​2、海量公交运营数据，贴心提醒用户合适路线公共交通是出行的主要方式之一，城市里丰富的公共交通资源让我们从A点到B点有太多的选择。路线规划插件的公交方案不仅可以提供多种出行偏好如少步行、时间短、换乘少等供用户选择，而且我们还整合了大量的公交实时运营数据，包括交通管制、运营时间、线路临时更改等等，可以准确告知用户在某个出行的时间内是否有合适的车辆，避免错过公交的尴尬。​地图选点插件地图选点插件可以让用户快速、准确地选择并确认自己的当前位置，并将相关位置信息回传给开发者。同时我们还提供位置检索、关键词分类、POI主子点等辅助功能。1、分类筛选，地点信息精准呈现选点是地图应用中使用频率最高的功能之一。购物时标注收货地址、游玩时寻找附近的餐馆、甚至找银行找医院等等，生活中的方方面面，都需要地图能帮助我们找到一个点或一类点。而我们熟悉的微信发送位置时，经常碰见尴尬的场景是地址列表提供的位置太多，掺杂了我们不需要的地点信息。如何提高用户在地图上选点的体验？告别无效地点信息，地点信息的快速精准呈现才是硬道理！选点插件提供了美食、购物、生活购物、娱乐休闲等多达19个一级分类、452个分类筛选！（详情请了解­­：腾讯地图POI分类关键词）开发者可以根据小程序的使用场景，对地点分类进行设置，同时提供分类筛选，引导用户快速精准选择地点信息。例如，在餐饮类的小程序当中，开发者可以在搜索结果中只展示川菜、湘菜、鲁菜、粤菜等餐馆的分类，而其他类型地点数据则不予展示；同时，用户也可以通过分类筛选快速找到自己想要的地点。​2、地点信息结构化呈现，“主子”关系一目了然想象一下如下场景：“喂喂，我们哪里碰面？”“西直门地铁站”“哪个口？”“我……”对于一个大型的地点信息，往往会包含若干个“子点”。例如上面提到的西直门地铁站，下面会包含若干个出口，相对于西直门地铁站这个“主点”来说，他们就是所谓的“子点”。​选点插件在搜索时提供了目标地点和其相关联的地点信息，用户只需要搜索地点部分内容如“西直门”时，在列表中会展示其相关联的地点信息 “C口（东南口）”“D口（西南口）”等，通过这种结构化呈现的方式，帮助用户快速找到附着在“主点”下的“子点”。地铁图插件当今地铁线路图俨然成为一座城市的符号，如果能在小程序中快速浏览地铁图、查找地铁路线，无疑可以给用户带来极大的便利。地铁图插件可以展示静态的城市地铁线路以及站点信息，同时还提供地铁线路检索、查找最近定位站点信息、站点详情查看等功能。开发者可以将城市地铁图嵌入到自建小程序的页面里，轻松实现地铁图功能。​如何接入​腾讯位置服务提供的小程序插件致力于降低小程序开发者开发地图功能的成本，并且打造完善的小程序地图闭环体验。目前我们已经提供了路线规划、地图选点、地铁图插件产品，其他插件也在陆续的开发中。我们将不断完善扩展插件能力，优化插件使用体验，满足开发者更多的需求，覆盖不同场景下的地图使用需求。现在就来体验「地铁图」「路线规划」「地图选点」微信小程序插件，感受简单快捷的地图服务，只需5分钟，搭建你的小程序地图！同时也欢迎开发者给与我们更多的反馈（QQ群：659847796），如果有好的建议和需求，一定要告诉我们，让我们为开发者提供更多更好的地图插件！"}
{"title": "借助小程序·云开发制作校园导览小程序丨实战 ", "author": "Rolan", "pub_time": "2019-10-14 00:21", "content": "背景当你刚上大学的时候，要想不迷失校园，除了依靠不怎么可靠的路边标识外，总会收到那么一张卡通绘制的校园地图：这种静态图片可以让我们快速地了解到所需的地理位置信息，但使用和思考过后，会发现以下问题：地理位置信息粒度高，而同一个地点通常具有多个服务功能和别名。地理位置信息变更导致地图信息过时。一旦服务网点迁移或更名，需要重绘地图，带来一定的延迟和信息滞后。入口较深。存储在手机上的地图并不是那么好找，尤其是随着时间的推移。无法准确的定位当前所处位置，需要寻找参照物，这是静态地图致命的缺点。缺乏更为详细的地点介绍，只能在有限的画面里堆积内容。为此，我设计了一款校园导览应用，用当下流行的微信小程序结合云开发能力，低成本高效能地解决了以上问题。此外，我还根据对市面上的同类应用进行设计上的研究，在界面和交互设计上做功夫。下面我会进行简短的介绍。南苑导览南苑导览是一款由学生独立开发的以地图为载体，提供 中山大学南方学院 （南苑）具体地点的位置信息、导航、校园历史及文化介绍的小程序。旨在解决校园导航标识不到位、地图形式低效单一、信息设计不够好等问题，为来南苑新人和游客提供更加完美的出行体验。<div align=center>仅需修改地图配置文件，即可适配任意场景（校园、景区）的小程序个性化地图定制。技术栈：原生小程序 + TypeScript + gulp + vantUI + 云开发能力2019 微信小程序高校大赛 · 华南赛区二等奖</div>南苑导览 · 开发config 配置├─ src\r\n├─── config\r\n├───── index.ts // 入口\r\n├───── cloud.ts // 云开发相关配置\r\n├───── info.ts // 应用介绍信息\r\n├───── markerStyle.ts // 地图marker样式\r\n├───── panorama.ts // 第三方全景地图配置（个人类型无webview权限，默认关闭）\r\n└───── secret.ts // 腾讯地图key等敏感信息（可选）使用云数据库// markers表 数据格式\r\n{\r\n  _id: \"5ce8fe1c29c7a8581bc1e989\",  // id，云数据库录入upsert更新用\r\n  type: \"生活服务\",   // 场景名称\r\n  icon: \"shfw\",     // marker默认图标，为场景名称拼音缩写\r\n  scale: 15.0,   // 场景在地图上的缩放值，可选。已废弃，用includePoints代替\r\n  position: 0, // 指定在各个场景中的排列顺序\r\n  data: [   // 该场景下的地点markers\r\n    {\r\n      name: \"孙中山铜像\",   // 地点名称\r\n      short_name: \"铜像\", // 名称缩写\r\n      desc: \"中山铜像...\", // 描述信息\r\n      logo: \"tx\",   // 地点logo，缩写拼音, 如作各院系logo展示\r\n      icon: \"tx@2\",   // 自定义marker图标，“@”后数字为图标相较于默认图标的缩放值\r\n      images: 3,  // 图片数量，作云存储拼接路径用（cloud://cloudRoot/1教/n.jpg）\r\n      panorama: 0,  // 全景场景id\r\n      latitude: \"23.635875\",  // 经度\r\n      longitude: \"113.678965\",  // 纬度\r\n      contact: { phone: \"020-123456\", address: \"出门左转\" }   // 联系方式\r\n    }\r\n  ]\r\n}使用 excel 进行数据维护，通过 python pandas 进行数据清洗，使用 jsonlines 库输出符合云数据库的 JSON Lines 格式文件，以 upsert 形式导入数据库。数据更新流程如下：[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9Kzq570X-1570761839095)( https://656e-enanyuan-6db383-... ]加载并清洗数据使用 request 或云数据库进行异步数据请求时。由于 app.js 中的 onLaunch 和首页 index 的 onLoad 的执行顺序不是固定的，所以如果首页有基于 app.js 请求的数据时要注意生命周期的问题。// index\r\nasync loadMarkers() {\r\n  let markers;\r\n  if (app.globalData.config.debug) {\r\n    // 本地\r\n    markers = mockMarkers;\r\n  } else {\r\n    // 云\r\n    await wx.cloud\r\n      .callFunction({\r\n        name: \"loadMarkers\"\r\n      })\r\n      .then((res: any) => {\r\n        markers = res.result.data;\r\n      });\r\n  }\r\n  app.globalData.markers = markers;\r\n}\r\n\r\nclearMarkers(markers: any[]) {\r\n  let num = 0;  // 每个marker都要有一个id\r\n  for (const i of markers) {\r\n    for (const j of i.data) {\r\n      j.id = num;\r\n      num += 1;\r\n      j.iconPath = `/assets/images/markers/${j.icon ? j.icon : i.icon}.png`;\r\n\r\n      ...\r\n\r\n      // 自定义气泡样式\r\n      j.callout = Object.assign(\r\n        { content: j.short_name ? j.short_name : j.name },\r\n        app.globalData.config.markerStyle.calloutStyle\r\n      );\r\n    }\r\n  }\r\n  return markers;\r\n}巧用 MapContext你不需要去手动地为每个场景设置 scale，用 includePoints 即可让地图视野自动覆盖到当前所有 POI。你也不需要去手动地去获取权限设置用户位置，用 moveToLocation 即可轻松定位。// index\r\nonReady() {\r\n  this.setData!({\r\n    mapContext: wx.createMapContext(\"map\")\r\n  });\r\n}\r\n\r\nincludePoints(padding: number) {\r\n  this.data.mapContext.includePoints({\r\n    padding: [padding, padding, padding, padding],\r\n    points: this.data.markers\r\n  });\r\n}\r\n\r\nlocate() {\r\n  this.data.mapContext.moveToLocation();\r\n}使用云存储管理图片添加新图片时，直接修改 images 字段即可，文件夹目录为地点名称。<!-- 地点详情页 轮播图 -->\r\n<swiper\r\n  indicator-dots=\"{{imgUrls.length > 1}}\"\r\n  autoplay=\"{{true}}\"\r\n  interval=\"3000\"\r\n  duration=\"1000\"\r\n>\r\n  <block wx:for=\"{{imgUrls}}\" wx:key=\"{{index}}\">\r\n    <swiper-item>\r\n      <image\r\n        src=\"{{item}}\"\r\n        class=\"slide\"\r\n        data-id=\"{{index}}\"\r\n        bindtap=\"previewImage\"\r\n      />\r\n    </swiper-item>\r\n  </block>\r\n</swiper>for (let i = 0; i < marker.images; i++) {\r\n  imgUrls.push(\r\n    this.data.cloudRoot +\r\n      \"images/\" +\r\n      (marker.short_name || marker.name) +\r\n      \"/\" +\r\n      i +\r\n      \".jpg\"\r\n  );\r\n}南苑导览 · 设计如果你在微信上搜索「导览」二字，看到的小程序大多都是一个模板，页面层级深，界面拥挤，列表式的信息展示并不符合我们日常使用地图 APP 的经验。为此，我做出了多项改良：[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-j76bV81T-1570761839095)( https://656e-enanyuan-6db383-... ]更好的视野 - 自定义导航栏与侧边栏因为只有特定的页面需要使用自定义导航栏，所以只需要设置页面级的 config：\"navigationStyle\": \"custom\"接下来获取胶囊按钮位置信息：bounding: wx.getMenuButtonBoundingClientRect();[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XoDA3u2I-1570761839096)( https://656e-enanyuan-6db383-... ]动态地设置样式：<!-- SIDE MENU -->\r\n<view\r\n  class=\"sidebar\"\r\n  hidden=\"{{toggleRoutes}}\"\r\n  style=\"top:{{bounding.height + bounding.top + 10}}px\"\r\n>\r\n  ...\r\n</view>FAB 与侧边栏设计把最主要的定位、搜索和路线推荐功能在视觉上成为整体，通过点击 FAB 弹出菜单选项。侧边栏的地点场景菜单设计为下拉滚动，注意使用半遮设计来提醒用户滚动。同时，为了让界面更加精简，侧边菜单会在点击 FAB（Float Action Button）和母按钮时 toggle 显示与隐藏。[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SP3GrjOr-1570761839096)( https://656e-enanyuan-6db383-... ]用点击代替滚动 - scroll-into-view在路线面板和搜索页中，使用到了 scroll-view 组件，利用其 scroll-into-view 特性，实现点击代替滚动的操作，同时也能起到提醒后置选项的作用。[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-o18t46ea-1570761839097)( https://656e-enanyuan-6db383-... ]windowWidth: wx.getSystemInfoSync().screenWidth;<scroll-view class=\"route\" scroll-x scroll-into-view=\"{{focusPointId}}\">\r\n  <view\r\n    class=\"points\"\r\n    style=\"width:{{routes[routeIndex].count * 140 < windowWidth ? windowWidth : routes[routeIndex].count * 140}}rpx;\"\r\n  >\r\n    ...\r\n  </view>\r\n</scroll-view>更好的视角 - 全景功能结合 web-view 和全景服务平台，可以为一款地图导览应用增色不少。总结云开发让小程序开发者无需搭建服务器，使用平台提供的 API 即可快速地进行业务开发、上线和迭代，免费的基础版完全可以满足中小应用的需求。「南苑导览」借助腾讯云开发能力，上线以来，帮助到了许许多多的新生和来客，实现了产品价值。最后，期望官方早日开放自定义地图底图能力，让开发者能够个性化地图，探索出更多的应用场景！源码地址https://github.com/TencentCloudBase/Good-practice-tutorial-recommended"}
{"title": "百度小程序与微信小程序全面对比 ", "author": "Rolan", "pub_time": "2019-10-14 00:38", "content": "百度小程序已出来一段时间了，本文分享我在开发过程中遇到的一些百度小程序与微信小程序的差别。帮助你快速转换微信小程序到百度小程序。文档地址：https://smartprogram.baidu.com/docs/develop/tutorial/codedir/，有遇到问题的可以去百度小程序社区提问：https://smartprogram.baidu.com/forum/（需要登录并且有appid）。本文分享一些百度小程序与微信小程序的差别。百度小程序组件hidden属性区别虽然百度小程序没提到这个属性，但我测试发现它在本地上和真机上都是支持的。但跟微信还是有一点区别：js:\r\n\r\ndata: {\r\n\tflag:'123'\r\n}\r\n\r\nxml:\r\n<view hidden=\"true\">1</view>\r\n<view hidden=\"false\">2</view>\r\n<view hidden=\"!false\">3</view>\r\n<view hidden=\"{{false}}\">4</view>\r\n<view hidden=\"!flag\">5</view>\r\n<view hidden=\"flag\">6</view>\r\n<view hidden=\"{{flag}}\">7</view>\r\n<view hidden=\"{{!flag}}\">8</view>\r\n<view hidden=\"{{!!flag}}\">9</view>\r\n<view hidden=\"\">10</view>百度小程序输出：248微信输出：4810百度：当hidden的值为flase，或者插值{{false}}为flase时，百度组件不会隐藏。其它情况，不管是true或者是空，或者其它值，不为false，或者计算出来的值不为flase，都会被隐藏。微信：当这个hidden属性为空或者插值{{false}}为false，才不会隐藏。有一种特殊情况就是直接赋值它为hidden=\"false\"，这里的false不被当做布尔值，所以它也被隐藏。结论：从上面这两个之中我们可以看到 4 和 8 两者都有，那我们做的时候只需要保证 hidden 的值为插值形式，并且插值的结果是布尔值，那两者就能得到一致的表现。js文件命名空间wx.替换为swan.wx.request() -> swan.request()\r\nwx.showModal() -> swan.showModal()\r\nwx.canIuse() -> swan.canIuse()\r\n……\r\nswan文件整体替换wx:到s-主要有两个地方：1.条件判断wx:if -> s-if\r\n2.列表循环wx:for -> s-for\r\nwx:for-item -> s-for-item\r\nwx:key -> s-key\r\n这里还有3点跟微信使用起来有点区别1.for循环里面，百度是不支持跟if放在同一条语句里面。我们可以通过增加一个block来判断条件2.条件判断百度是没有使用插值计算。这是微信的：<view wx:if=\"{{condition}}\"> True </view>\r\n这是百度的：<view s-if=\"condition\"> True </view>\r\n3.组件中的3元运算符，不支持 <= 判断，猜测可能是bug，可能是里面使用了正则判断。<view>{{ 1 <= 2 ? 'yes' : 'no' }}</view>\r\n解析出来的内容为：<view>true<=\"\" view=\"\"></=></view>\r\n解决方法是改成 >=，或者<<view>{{ 2 >= 1 ? 'yes' : 'no' }}</view>\r\n模板1.声明需要使用的模板，data 是所需要传入到模板的值，当它是对象时，对象字面量是三个大括号包裹，微信是{{}}。<!-- template-demo.swan-->\r\n<template name=\"person-card\">\r\n    <view>\r\n        <text>位置: {{pos}}</text>\r\n        <text>姓名: {{name}}</text>\r\n    </view>\r\n</template>\r\n\r\n<!-- template-demo.swan-->\r\n<template is=\"person-card\" data=\"{{{person}}}\" />\r\n\r\n// template-demo.js\r\nPage({\r\n    data: {\r\n        person: {name: 'Lebron James', pos: 'SF', age: 33}\r\n    }\r\n});\r\n2.不支持动态调用<template name=\"tid-1\">\r\n    <view>1</view>\r\n    <view>{{index}}:{{msg}}</view>\r\n</template>\r\n<template name=\"tid-2\">\r\n    <view>2</view>\r\n    <view>{{index}}:{{msg}}</view>\r\n</template>\r\n当我需要根据tid值来调用某个模板时，例如tid=1时，使用下面的方法调用<template is=\"tid-{{tid}}\" data=\"{{{...item}}}\"/>\r\n\r\nPage({\r\n    data: {\r\n        tid:1\r\n    }\r\n});\r\n上面这种获取不了template tid-1的内容。我们可以通过条件判断来调用模板：<block s-if=\"{{ tid == 1}}\"><template is=\"template-1\" data=\"{{{...item}}}\" /></block>\r\nPage函数不要使用getData()由于我之前的页面中获取请求时用的是这个函数，然后我发现百度小程序里面这个函数在onload中无法执行到。另外就是如果直接点击执行这个函数，会报错。页面传递参数option，最好加上enCodeURIComponent()我之前的一个微信小程序传递url时，参数没有格式化，直接传递后，在百度小程序中会发现接收不完整，例如：http://xsps.pchouse.com.cn/ 转化为 http:/xsps.pchouse.com.cn。swan.createSelectorQuery()这个API要在页面DOM 加载完毕后执行，才能获取到具体的值，如果你直接在onload或者request 的success 里面setData后获取值，同样获取不到内容，可以在onReady里面获取到。有一种做法就是加一个定时器，在2秒后获取，或者改为当需要的时候才开始获取。不要使用HTML标签在百度小程序中，使用了div/ul/li等HTML标签，调试swan tab时，标签会被过滤掉。<div class=\"list\">\r\n\t<ul>\r\n\t\t<li bindtap=\"test\">测试</li>\r\n\t\t<li>测试</li>\r\n\t\t<li>测试</li>\r\n\t</ul>\r\n</div>\r\n\r\n.list ul{font-size:18px;}\r\n\r\ntest:function(){\r\n\tconsole.log('test');\r\n}会发现样式不起作用。另外就是绑定事件也无法起作用,如上面的test,点击后无效，跟刚才说的li标签被过滤同样的道理。tabBar配置决定了首页在app.JSON中，我改了一下pages首页的位置，发现并不起作用，反而tabBar改了第一个标签的地址后，首页也跟着改变，而微信是支持tabBar可以不是首页进来的页面。wxs 改为 filter微信的：WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。<!--wxml-->\r\n<wxs module=\"m1\">\r\nvar msg = \"hello world\";\r\n\r\nmodule.exports.message = msg;\r\n</wxs>\r\n\r\n<view> {{m1.message}} </view>\r\n\r\n页面输出：\r\n\r\nhello world\r\n百度的：Filter 是小程序的过滤器，结合 SWAN 模版，可以构建出页面的结构。// page.js\r\nPage({\r\n  data: {\r\n    array: [1, 3, 6, 8, 2, 0]\r\n  }\r\n});\r\n\r\n// test.filter.js\r\nexport default {\r\n    maxin: (arr) => {\r\n        var max = undefined;\r\n        for (var i = 0; i < arr.length; ++i) {\r\n            max = max === undefined ?\r\n            arr[i] :\r\n            (max >= arr[i] ? max : arr[i]);\r\n        }\r\n        return max;\r\n    }\r\n};\r\n\r\n<!-- swan模版 -->\r\n<view>{{swan.maxin(array)}}</view>\r\n<filter src=\"./test.filter.js\" module=\"swan\"></filter>\r\n\r\n页面输出：\r\n\r\n8\r\n自定义组件模板里面没法嵌套模板建议使用slot图片路径要补全协议如下面这两种情况，如果没有补全协议，会无法访问，默认代码为静态解析<image src=\"//www1.pchouse.com.cn/2018/weixinminipro/loading.png\"></image>\r\n\r\n//css \r\nimage{background:url(//www1.pchouse.com.cn/2018/weixinminipro/loading.png)}\r\nimport 和 includeimport 注意微信中引入的是.wxml的文件，百度这里引入的是.swan的文件，所以要替换掉在 index.swan 中引用了 item.swan，就可以使用item模板：<import src=\"item.swan\"/>\r\n<template is=\"item\" data=\"{{{preson}}}\"/>\r\n同理 include也是改文件后缀<!-- index.swan -->\r\n<include src=\"header.swan\"/>\r\n<view> body </view>\r\n<include src=\"footer.swan\"/>\r\n百度小程序分享到微信，无法打开百度虽然提供了分享到微信朋友圈和微信好友的功能，但打开微信分享的内容会先提示跳到App Store上，并无法打开百度小程序的页面，分享体验不好，只能分享到百度APP自身的动态，打开后才能访问。微信转换为百度小程序1.登录百度小程序开发工具，在工具菜单，有一个一键转换微信的小程序为百度小程序。（前提：有审核通过的appid，并且登录开发者工具）用了官方的工具还是挺好的，对照我上面提到的点，小小的调整应该就差不多了。2.下载NPM上的一个工具：wx2swan。https://github.com/yican008/wx2swan，跟百度这个转换好像差不多。安装： npm i -g wx2swan转换：wx2swan 微信小程序的目录 (生成swan的目录)wx2swan ./test/demo ./test/swanDemo3.使用 Taro 开发2018.11.20日更新：bindscrolltolower 执行多次scroll-view 组件的bindscrolltolower 会执行多次，需要加上防抖处理，预防接口重复加载，导致数据更新混乱，出现错误。<scroll-view bindscrolltolower=\"loadMoreList\"></scroll-view>\r\n\r\nPage({\r\n\ttimer:null,\r\n\tloadMoreList:function(){\r\n\t\tvar self = this;\r\n\t\tif(this.timer){\r\n\t\t\tclearTimeout(this.timer);\r\n\t\t}\r\n\t\tthis.timer = setTimeout(function(){\r\n\t\t\tconsole.log('your data');\r\n\t\t\tself.timer = null;\r\n\t\t},300);\r\n\t}\r\n})\r\n双向绑定1.scroll-view组件里面有三个属性是属性双向绑定<scroll-view scrollTop=\"{= scrollTop =}\" scrollLeft=\"{= scrollLeft =}\" scroll-into-view=\"{= scrollIntoView =}\"></scroll-view>2.input组件<input value=\"{= value =}\"/>真机的屏幕高度没有去掉tabBar高度2019.1.17号更新：在DOM加载完毕是正确的，屏幕高度会去掉tabBar,所以应该在onReady生命周期里面处理。由于scroll-view组件需要确定高度，在电脑上计算出来的高度是已经对的，但到了真机上，发现高度并没有减掉tabBar的高度，导致有些地方被隐藏在tabBar下面。没办法，我只能用了另外一种办法，因为我怕到时候它修复了这个错误，我一hack它这个高度，那时候我又得改了。我给scroll-view的父类加了一个绝对定位属性。然后定义它的高度为100%，接着在scroll-view的组件里面减去头部的导航高度。<view class=\"fix-menu\"></view>\r\n<view class=\"tab-content\">\r\n<scroll-view class=\"content\">\r\n<view class=\"list\">\r\n</view>\r\n</scroll-view>\r\n</view>\r\n\r\n.fix-menu{height:100rpx; position:fixed; top:0; left:0; width:100%;}\r\n.tab-content{position:absolute; left:0; top:0; height:100%; width:100%;}\r\n.content{height:100%;}\r\n.content .list{padding-top:100rpx;}\r\n这样子就不需要去计算scroll-view的高度了。直接用css兼容，也不用管百度这个bug了。不过微信的还是直接计算这个高度比较好，这样子这个scroll-view刚开始时的滚动条就不会被隐藏掉100rpx。百度小程序分享安卓中分享到百度动态，点击消息进入时，无法进入具体页面，只能进入当前页或者首页。2019.1.24更新API微信小程序有的API，而百度小程序没有的一个表，不对下面这些微信小程序API进行转换wx: {\r\n        startRecord,\r\n        stopRecord,\r\n        playVoice,\r\n        pauseVoice,\r\n        stopVoice,\r\n        getBackgroundAudioPlayerState,\r\n        playBackgroundAudio,\r\n        pauseBackgroundAudio,\r\n        seekBackgroundAudio,\r\n        stopBackgroundAudio,\r\n        onBackgroundAudioPlay,\r\n        onBackgroundAudioPause,\r\n        onBackgroundAudioStop,\r\n        openBluetoothAdapter,\r\n        closeBluetoothAdapter,\r\n        getBluetoothAdapterState,\r\n        onBluetoothAdapterStateChange,\r\n        startBluetoothDevicesDiscovery,\r\n        stopBluetoothDevicesDiscovery,\r\n        getBluetoothDevices,\r\n        getConnectedBluetoothDevices,\r\n        onBluetoothDeviceFound,\r\n        createBLEConnection,\r\n        closeBLEConnection,\r\n        getBLEDeviceServices,\r\n        getBLEDeviceCharacteristics,\r\n        readBLECharacteristicValue,\r\n        writeBLECharacteristicValue,\r\n        notifyBLECharacteristicValueChange,\r\n        onBLEConnectionStateChange,\r\n        startBeaconDiscovery,\r\n        stopBeaconDiscovery,\r\n        getBeacons,\r\n        onBeaconUpdate,\r\n        onBeaconServiceChange,\r\n        getHCEState,\r\n        startHCE,\r\n        stopHCE,\r\n        onHCEMessage,\r\n        sendHCEMessage,\r\n        startWifi,\r\n        stopWifi,\r\n        connectWifi,\r\n        getWifiList,\r\n        onGetWifiList,\r\n        setWifiList,\r\n        onWifiConnected,\r\n        getConnectedWifi,\r\n        setTopBarText,\r\n        showShareMenu,\r\n        hideShareMenu,\r\n        updateShareMenu,\r\n        getShareInfo,\r\n        addCard,\r\n        openCard,\r\n        getWeRunData,\r\n        checkIsSupportSoterAuthentication,\r\n        startSoterAuthentication,\r\n        checkIsSoterEnrolledInDevice,\r\n        faceVerifyForPay,\r\n\r\n    }微信小程序被废弃的接口，建议用后面的接口替换createContext：被废弃的函数，建议使用createCanvasContext替代\r\ndrawCanvas：被废弃的函数，建议使用createCanvasContext替代\r\ncreateAudioContext：建议用createInnerAudioContext两者有些不同的，前面是微信，百度的用后面的替换navigateToMiniProgram--->navigateToSmartProgram微信二级API，目前百度不支持的createLivePusherContext自定义组件// Component构造器中不支持的属性\r\n    Component: {\r\n        moved: null,\r\n        relations: null\r\n    },\r\n    Behavior: {\r\n        // Behavior 中不支持自定义组件的扩展\r\n        // definitionFilter: null\r\n    },\r\n    // 自定义组件中this上不支持的属性和方法\r\n    this: {\r\n        getRelationNodes: null,\r\n        selectComponent: {\r\n            // 方法不允许被调用的作用域\r\n            notAllowParents: ['onLaunch', 'onShow', 'onLoad']\r\n        },\r\n        selectAllComponents: {\r\n            // 方法不允许被调用的作用域\r\n            notAllowParents: ['onLaunch', 'onShow', 'onLoad']\r\n        }\r\n    },\r\n    // 设置内置behaviors映射关系\r\n    behaviors: {\r\n        'wx://form-field': {\r\n            mapping: 'swan://form-field'\r\n        },\r\n        'wx://component-export': {\r\n            mapping: 'swan://component-export'\r\n        }\r\n    },\r\n    json: {\r\n        // 不支持抽象节点\r\n        componentGenerics: null\r\n    }左边是微信，右边是百度template组件data属性转换问题: {{item}} => {{{item}}}<template is=\"person-card\" data=\"{{person}}\" />\r\nwx:for不同，百度可以浓缩到一个属性里面。s-for=\"item,p in obj\"---> wx:for=\"{{obj}}\" wx:for-item=\"item\" wx:for-index=\"p\"\r\n转换wx.__route__成员表达式调用为wx.route参考链接搬家工具转换支持的Feature List百度小程序开发问题汇总"}
{"title": "小程序组件开发之时间轴组件及组件关系 ", "author": "Rolan", "pub_time": "2019-10-15 00:16", "content": "本文是面向初学者的，大牛可以忽略，以时间轴组件为例简单聊一下小程序的组件开发。先简单介绍一下公司业务和前端项目情况吧。公司是做金融行业财富管理的业务，涉及主要是做基金、保险这一块。前端项目目前涉及B端后台管理系统、C端小程序、Node服务端，其中业务重点在小程序端，我们只有微信小程序端，没有做其他小程序，也没有使用市面上流行的各种多端框架，我们使用原生开发方式，UI组件我们也选择了自研，目前我们开发了一套金融风格的小程序端UI组件库，有过开源的打算，但目前我们还在内部沉淀使用中，目前积累了 34+ 个组件了，支持主题和国际化，基本上满足了目前开发的需要。所以，本文要说的是我们组件库最近添加的一个新组件，时间轴组件，也是笔者开发的，笔者由于在公司主要负责小程序端的开发，基于业务的需要贡献了开发了不少组件，那么多组件之所以讲这个组件，是因为其他大部分组件的开发都很普通，体现不了小程序特有的东西，要么是组件太复杂代码太多不适合用文字表达，而时间轴（Timeline）组件我觉得刚刚好，不肥不瘦不偏不倚20不足18有余，比较好拿来作为素材聊聊。另外，为了写本文我把此组件做成了 小程序代码片段 ，代码片段是一种可分享的小项目，可用于分享小程序和小游戏的开发经验、展示组件和 API 的使用、复现开发问题等等，代码片段详细信息可以去官方文档看看。时间轴组件（源代码）代码片段 ，点击链接可以直接通过小程序开发工具直接打开查看，可以边看源代码边看文章。注意：请确保你的开发者工具版本 >= 1.02.1904280组件分析设计在着手写代码之前，还是先做一翻分析设计。分析什么？我们需要分析业务方对组件的详细需求、交互以及设计稿效果，弄清楚有没有什么特别的地方，需求是否适合使用时间轴组件来呈现等，对于不合理的需求，作为开发我们有责任提出问题和建议来。设计什么？我们需要设计组件的目录结构、API以及对使用者友好的示例文档，通常除了API外，目录结构、命名和文档我们都会现有一个规范，按给定的规范做即可，但是如何设计一组好的API就需要开发者具有一定的经验。当然，对于常用的组件，我们也许用不着这么认真，直接参考市面上已有的组件库找着样子抄就行了，事实上我们除了少数几个组件别具特色外别家没有外，其他组件我们也是直接参考别的组件库是怎么做的，但我这里抛砖引玉吧，不仅仅是开发组件，任何需求的迭代开发都是一样的，特别是复杂的需求，我们更需要设计。对于组件开发来说，最好的设计文档就是示例文档，文档先行。看一下 Timeline 组件的文档吧：Timeline 组件的文档什么不支持自定义 slot，什么地方支持自定义，这就很清晰了，事件轴点可以自定义样式，时间轴的内容体可以自定义，以及一些外部样式 class。当然这是最终完善的文档，我们首先应该定义好组件的 Attributes（Props）、Slot ，命名、类型这些都事先定义好，这是最基础的，分析出来我们的组件应该提供什么样的能力，定义什么样的接口。其次，我们应该写好代码示例，先想好我们的组件是如何使用的，然后我们再支持这样的实现。这里可以看出，组件使用了父子嵌套组件模式：<pps-timelinereverse=\"{{false}}\">\r\n  <pps-timeline-item\r\n    wx:for=\"{{activity}}\" \r\n    wx:key=\"{{index}}\"\r\n    timestamp=\"{{item.timestamp}}\"\r\n    dotStyle=\"border-color: #33cd5f; color: #33cd5f\">\r\n      {{item.content}}\r\n  </pps-timeline-item>\r\n</pps-timeline>\r\n为什么这里要使用父子组件模式呢，其实不这样也是可以很好的完整组件。做好了这些工作后我们开始写代码吧。组件实现timeline因为我们是使用父子组件嵌套模式，所以在创建目录时就可以这样体现：timeline\r\n--index.wxml\r\n----timeline-item\r\n------index.wxml\r\n当然，在小程序中要实现父子组件关联关系并不是非要这样，事实上没有层级规定限制，父子组件平级放置也是可以的，但我推荐这样，阅读起来更清晰名了。父组件内部其实很简单，就是一个 slot，以便能够放入子组件<!-- timeline/index.wxml -->\r\n<viewclass=\"pps-timeline custom-class {{reverse?'desc':'asc'}}\">\r\n  <slot/>\r\n</view>\r\ncustom-class 是定义组件的根外部样式，以便在外部传入样式，为什么要这样呢，小程序的组件技术采用的 WebCompontent 技术，不了解的同学可以搜索一下，这里我写了 demo 。 reverse 是个 prop ，控制时间轴是顺序展示还是倒序展示，这个在父组件来控制是最好不过的（当然，你也可以把传入的数组排序好也是一样的）。timeline-item核心都在这个里面，我们先来分析一下DOM结构，以便确定怎么构建HTML结构具体代码就不贴了，可以打开代码片段查看。排序：父子组件间关系组件间关系这是这个组件最关键的地方，不同于 Vue.js 组件方案，只有实现这个才能实现在 timeline 上实现 reverse。关于组件的关联关系详细可以看 文档 。在 timeline/index.js 和 timeline-item/index.js 中分别定义 timeline 是 timeline-item 的父级，timeline-item 是 timeline 的子级，由 relations 选项来定义。关键是确定最后一个节点，因为最后一个节点是没有连接线的，这个需要处理（其实数据不复杂的情况下更建议对传入的数组进行排序，这样就不需要处理DOM结构了）。timeline/index.jsrelations: {\r\n    './timeline-item/index': {\r\n      type: 'child',\r\n      linked: function (target){\r\n        // 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后\r\n        this._getAllChildren()\r\n      },\r\n      unlinked: function (target){\r\n        this._getAllChildren()\r\n      }\r\n    }\r\n  },\r\ntimeline-item/index.jsrelations: {\r\n    '../../timeline/index': {\r\n      type: 'parent'\r\n    }\r\n  },\r\n有了关联关系，我们可以调用 this.getRelationNodes 方法获取所有的子节点，这个写在 timeline-item/index.js 中methods: {\r\n    _getAllChildren() {\r\n      const nodes = this.getRelationNodes('./timeline-item/index')\r\n      if (nodes.length) {\r\n        const lastIndex = nodes.length - 1\r\n        const { reverse } = this.data\r\n        nodes.forEach((element, index) => {\r\n          const isLast = index === lastIndex\r\n          element.updateIsLastElement({\r\n            index,\r\n            isLast,\r\n            reverse\r\n          })\r\n        })\r\n      }\r\n    }\r\n}\r\n然后遍历每一个子节点，调用子节点 methods 中的 updateIsLastElement 处理方法。这里需要特别注意的是 在 unlinked 中也要再次调用 _getAllChildren ，因为当使用 setData 删除一个子项时需要重新计算子节点个数。所谓的排序，就是 Flex CSS 操作而已.pps-timeline.desc{\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n.pps-timeline.asc{\r\n  display: flex;\r\n  flex-direction: column-reverse;\r\n}\r\n这个组件还有很多可以改进的地方，这里作为一种思路吧。注意在引用小程序端的时候，父子组件都需要在json中引入，如果你的项目是用 npm 进行管理的，那么不要在全局的 app.json 中引入，要在使用的页面中引入，否则引用不到。推荐几个优秀的组件库iView Weapp 。出自著名的Vue组件库 iView 之家，跟 iView 一脉相承。Vant Weapp 。“大名鼎鼎”的大厂有赞出品，Vue 组件库 Vant 的小程序版本，两者基于相同的视觉规范，提供一致的 API 接口。Color UI 。最“风骚”的组件库，多彩靓丽，组件丰富，色彩华丽，动画酷炫。wux-weapp 。最大而全的组件库，各种组件应有尽有，组件宝库。后记笔者小程序开发经验也不是很丰富，如有错误请指出，小程序的自定义组件涉及的东西比 Vue.js 多多了，比如模板和样式怎么处理、组件间通信、组件间关系、组件生命周期等都具有小程序特色。纯原生开发一个复杂的小程序，不借助轮子个人感觉还是很麻烦的，尤其现在这么多小程序，哪天需要支持其他小程序呢，我想不会有人一个个对接原生开发吧，由于我们业务时toB的，所以目前还不需要考虑其他平台小程序。"}
{"title": "微信小程序开发早知道 ", "author": "Rolan", "pub_time": "2019-4-4 00:24", "content": "小程序没有跳转公众号、跳转公众号图文素材的能力。除非用户通过扫描二维码进入小程序的情景，可以显示关注公众号组件。公众号菜单、公众号图文素材可以打开小程序，网页无法直接打开小程序。小程序内嵌网页、内嵌网页中跳转链接、iframe 嵌套的页面，都必须在安全域名内，否则无法访问。如果想在小程序内加入第三方广告，要注意这点，因为安全域名修改是有次数限制的，并要求验证服务器。还要注意网页中嵌套 iframe 的情况，例如，网页内嵌了腾讯视频 iframe，由于腾讯视频不在安全域名内，会造成页面无法访问。用户信息授权、手机号码授权需要用户通过点击操作。小程序间跳转需要用户点击操作，跳转前需要用户确认，可跳转小程序数量不超过10个。小程序分为开发版、体验版、审核版、线上版：开发版是开发工具编辑过的最新版本；开发工具上传后成为体验版，具备体验权限的用户都可以查看；将开发版提交给官方审核后，成为审核版；审核成功后，才可以发布成为线上版本。官方「小程序助手」小程序可以很方便打开各版本小程序。每次发布新版本，用户都需要重新下载新版本。小程序仍在不断更新和完善，旧代码可能会因不符合新政策，在下次发布的时候无法正常运行。为避免这种情况的发生，应多关注官方公告。版本回退功能可以将线上版本回退成上一个版本小程序使用 CommonJS 规范，对 ES6 有很好的支持小程序没有官方状态管理工具，页面间通讯靠 query string 传递参数。如果有复杂状态管理的需求的话，建议引入一些设计模式或使用第三方框架。用户微信支付后，需要后台推送消息到服务器，才能确认支付成功。小程序的 DOM 操作只能查询属性，无法设置属性。小程序基础库版本与微信版本有关， 基础库版本与客户端版本对应关系 。小程序也存在兼容性问题，对待不愿更新微信的用户，要像对待忠实的IE6用户一样， 小程序基础库版本分布 。小程序页面只有 onLoad、onShow、onReady、onHide、onUnload 生命周期，没有更新视图相关的生命周期小程序不能直接渲染 HTML string，要用 rich-text 组件，但组件使用 HTML string 性能会有所下降。小程序有很多原生组件，如 Vedio、Map。原生组件位于最上层，会遮挡所有非原生组件，还存在诸多限制，如无法改变大小、无法添加动画效果等等。不过，有些组件在最新版本已经可以同层渲染了。小程序不支持摇一摇功能，但可以通过监听加速度传感器来实现。小程序有官方的广告组件，广告收入官方会抽走一部分。想到再更，欢迎补充."}
{"title": "微信小程序开发——点击按钮退出小程序的实现 ", "author": "Rolan", "pub_time": "2019-4-23 00:43", "content": "微信小程序官方是没有提供退出的API的，但是在navigator这个组件中，是有退出这个功能的：详情参考官方文档：navigator。示例代码：1 <navigator open-type=\"exit\" target=\"miniProgram\">关闭小程序navigator>不过这个功能最低支持版本时 2.1.0 ，如果一定要使用这个功能，那么最好在小程序管理后台中设置最低基础库版本不低于2.1.0，如果对小程序支持的最低基础库低于2.1.0，那么可以对小程序基础库版本进行判断，支持小程序退出的就使用退出组件，如果不支持，那么就做好跳转到其他指定页面的兼容处理。1         wx.getSystemInfo({2           success: function(res) {3             if(res.SDKVersion>=\"2.1.0\"){4               self.setData({5                 exitApp:true//data中的初始化变量6               })7             }8           }9         })1 <navigator wx:if=\"{{exitApp}}\" open-type=\"exit\" target=\"miniProgram\">关闭按钮navigator>2 <navigator wx:else open-type=\"navigate\" target=\"navigate\" url='../../index/index'>返回首页navigator>如果是首页，那么就直接不处理这个返回退出了。注：由于不是API，所以不能使用wx.canIUse(string)的方式进行判断了，所以只能通过获取系统信息的方式获取小程序基础库版本，以此来判断。对于小程序基础库版本分布可以查看官方统计说明：基础库版本分布。"}
{"title": "微信小程序开发需要注意的一些规范 ", "author": "Rolan", "pub_time": "2019-5-5 00:42", "content": "出现 JavaScript 异常可能导致小程序的交互无法进行下去，我们应当追求零异常，保证小程序的高鲁棒性和高可用性，相信这一点一般情况下都不会出现，需要注意的是代码测试中多场景的试错。2.合理控制图片的大小图片太大会增加下载时间和内存的消耗，应根据显示区域大小合理控制图片大小。 一般情况下图片较大的，我们应该都会选择直接放在服务器上，直接拿到地址，但是官方说这样读取的图片： 存在网络图片资源未开启 HTTP 缓存控制 ,这是个什么意思，我也未完全弄懂。3.小程序所有请求应响应正常请求失败可能导致小程序的交互无法进行下去，应当保证所有请求都能成功。然而，请求成功只是第一步，还可能存在的问题就是请求的耗时太长、存在短时间内发起太多的请求这样的情况，一方面是后台人员的接口写的烂，一方面就是需求使然（技术半吊子，还想安全的产品经理会有这种让你去指定地方请求的情况），比如在阿里云OSS存储的一些json数据。。。。4.避免setData的数据过大且避免setData的调用过于频繁。由于小程序运行逻辑线程与渲染线程之上，setData的调用会把数据从逻辑层传到渲染层，数据太大会增加通信时间. setData接口的调用涉及逻辑层与渲染层间的线程通过，通信过于频繁可能导致处理队列阻塞，界面渲染不及时而导致卡顿，应避免无用的频繁调用.5.避免将未绑定在 WXML 的变量传入 setDatasetData操作会引起框架处理一些渲染界面相关的工作，一个未绑定的变量意味着与界面渲染无关，传入setData会造成不必要的性能消耗。 这一条我想是很多开发人员在初次接触小程序开发的时候都会犯的一个错误吧。因为刚开始的时候由于这种setData的语法，让我们忘了还有全局变量的使用，于是会经常出现使用Page中定义的data做中间过渡。6.wxss 覆盖率较高，较少或没有引入未被使用的样式我们应该按需引入 wxss 资源，如果小程序中存在大量未使用的样式，会增加小程序包体积大小，从而在一定程度上影响加载速度。 这个也是比较常见的一种不规范，写了很多CSS样式，很多不用的就留来了代码里面，越来越多，所以在编写代码过程中，尽量去对每一行代码（特别是自己写的）了如指掌。7.避免首屏时间太长的情况首屏时间是指用户开始看到第一屏的内容的时间，首屏时间太长会导致用户长时间看到的都是白屏，会一直等待有意义的内容展示出来。出现这一情况，应仔细检查这个过程都有哪个操作，一般来说，可能是请求数据的时间太长，或者是一次渲染的数据太大导致渲染时间太长。这些东西是我感觉比较常见且容易修改的，其它还存在一些规范，不妨打开微信开发者工具，点击 Audits ,对你写的代码进行一个测试，测试结果会让你很好的处理自己的代码。That's really cool!"}
{"title": "微信小程序开发注意指南和优化实践 ", "author": "Rolan", "pub_time": "2019-6-19 00:40", "content": "前言转眼间已经参与过我厂好几个小程序的开发了，下面本妹子将开发中的那些注意点和各位小伙伴们分享下，妥妥的干货一枚。一、WXML不要换行写，有空格不行微信开发者工具不会对代码进行trim操作，如果代码中换行，页面也直接换行。wx:if vs hidden一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好。图片处理1.大图片也会造成页面切换的卡顿有一部分小程序会在页面中引用大图片，在页面后退切换中会出现掉帧卡顿的情况。 2.图片占容量 代码包限制是2MB，图片占用空间较大，建议都上传到 CDN 上，代码里直接引用链接。 3.大图片小点击位 小程序主要在手机端运行，手机屏幕大小有限，所以尽量点击位大点。 4.图片截取 存在图片没有按原图宽高比例显示，可以设置 image 组件的 mode 属性，来保持原图宽高比。 5.CSSSprites 所有零星图片都包含到一张大图中，减少请求数WXS 模块每个 wxs 模块均有一个内置的 module 对象。 直接在wxml中引入，可以将写需要转化数据的写进去，防止给setData加负担使用了过大的 WXML 节点数目一个太大的WXML节点树会增加内存的使用，样式重排时间也会更长，建议一个页面使用少于 1000 个WXML的节点，节点树深度少于 30 层，子节点数不大于 60 个二、WXSSCss伪类看不到在微信开发者工具中， Styles 不会显示 Css 伪类，喜欢写::before或:first-child的小伙伴们请注意了，你的伪类在控制台是看不到的,所以本妹子不建议在小程序里用 Css 伪类，以防找不到问题点不好修复bug。小程序 button 自带给 after 伪类添加了边框，通过开发者工具是看不到 after ,我们需要自行去掉边框。button::after {\r\n  border: none;\r\n}hover 伪类则可以用小程序自带的属性 hover-class 代替。部分CSS3属性不能用如transform:rotate(180deg)，不能用。自定义颜色限制不是所以颜色配置都能随心所欲，比如导航栏标题颜色，仅支持 black / white；下拉 loading 的样式，仅支持 dark / light。所以出视觉图关注下。滚动区域没有开启惯性滚动当加了overflow: scroll时， IOS 下需要额外设置： -webkit-overflow-scrolling: touch，来开启惯性滚动。三、JSJavaScript 支持情况如果需要支持到 IOS8 话，建议下面 js 方法都不使用。分享事件不支持异步如果你想自定义分享图片，则在生命周期onShareAppMessage中编写如下所示：Page({\r\n  onShareAppMessage: function (res) {\r\n    return {\r\n      title: '自定义转发标题',\r\n      imageUrl: 'https://raoenhui.github.io/images/logo.png'\r\n    }\r\n  }\r\n})但是 onShareAppMessage 不能支持异步，如果你想从接口里获取分享图片URL，必须在 onLoad 提前读取并放入Data中小程序有并发限制wx.request、wx.uploadFile、wx.downloadFile 的最大并发限制是 10 个。所有为了保险起见，需要写个请求队列，如果并发量大于10，则等待请求。采用公共方法和组件编写公共方法和组件，可以避免重复造轮子。 1.公共埋点方法 2.各种处理js的方法（转https，throttle，formatTime等） 3.公共组件（iphonex兼容组件，倒计时组件等）catch绑定事件比如 catchtouchmove 弹框禁止滑动 bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。循环中添加key对于经常要更新的列表需要加上 key 值，key值相当于索引，但是 key 值不要用 index ,因为 index 在增加删除的时候可能不变产生混乱，推荐用唯一标示 id ，对数据改变之后的diff更新比较有很大的性能提升。 PS：如果是单纯只显示的列表，不需要操作更新，那不需要加 key 。巧用nextTick小程序和vue写法比较相似，也有 nextTick ,在当前同步流程结束后，下一个时间片执行 。 比如有些取视图层的数据，可以等页面上流程结束后再取比较准确wx.nextTick(() => {\r\n      query.select('.percent-line-toast').boundingClientRect() \r\n    })处理后台运行的jssetTimeout一定伴随着clearTimeout setInterval一定伴随着clearInterval 这些我们经常会滚动算高度，倒计时，动画中用到。当我跳到了另外一个页面还在运行，小心后台页面的jswx.hide的坑两个都是基于同一个原生toast实例实现的，wx.showLoading()与wx.showToast(), 同时只能显示一个， wx.hideLoading()也会隐藏Toast ; wx.hideToast()也会隐藏Loading， 失败的提示toast会一闪而过的问题，可能时因为调用了wx.hideLoading()。http需变httpsHTTP是明文传输有篡改内容的风险，而且有些安卓机会不兼容。所以我们需要使用https。 所以开需求评审的时候，要注意后端要写成https，如果是运营配的数据，后端最好有个转https方法，输入了url自动转成https链接。在微信开发者工具中，可勾选”不校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书”规则即可用http，但是在实体里并没有这个选项，所以建议开发时就用https路径。埋点的坑埋点用公共方法，页面曝光 pv 埋点放入 onshow 生命周期中更加准确。预加载1.数据预加载 上个页面就将接口请求好，存到对象中，下个页面直接从对象中拿，有利有弊，从业务角度出发看是否需要预加载数据 storage也可以存储数据，同一个微信用户，同一个小程序 storage 上限为 10MB。分包预加载preloadRule preloadRule预下载分包行为在进入某个页面时触发，享有共同的预下载大小限额 2M。\"preloadRule\": {\r\n \"sub1/index\": {\r\n   \"packages\": [\"important\"]\r\n }\r\n}3.图片预加载 对视觉效果要求越来越高，多张图片如果想动画显示流畅，可以先加载图片，直接用request先请求图片下来。setData注意点1. 频繁的去 setData存在将未绑定在 WXML 的变量都不需要传入 setData。 2. 每次 setData 都传递大量新数据，可局部更新this.setData({\r\n    list[index] = newList[index]\r\n})3. 后台态页面进行 setData当页面进入后台态（用户不可见），不应该继续去进行 setData ，后台态页面的渲染用户是无法感受的，另外后台态页面去 setData 也会抢占前台页面的执行。也就是上文提到的不要忘了 clearTimeout 、 clearInterval 。四、其他使用分包由于小程序包大小有限制，整个小程序所有分包(包括独立分包和普通分包)大小不超过 8M，单个分包/主包大小不能超过 2M，建议把首屏不需要展示的都放入分包中，分包就像H5打出的chunk包一样，可以按需加载。及时清理没有使用到的代码和资源在日常开发的时候，我们可能引入了一些新的库文件，而过了一段时间后，由于各种原因又不再使用这个库了，我们常常会只是去掉了代码里的引用，而忘记删掉这类库文件了。目前小程序打包是会将工程下所有文件都打入代码包内，也就是说，这些没有被实际使用到的库文件和资源也会被打入到代码包里，从而影响到整体代码包的大小。sitemap 配置小程序根目录下的 sitemap.json 文件用于配置小程序及其页面是否允许被微信索引，文件内容为一个 JSON 对象，如果没有 sitemap.json ，则默认为所有页面都允许被索引.单元测试miniprogram-simulate模拟 touch 事件、自定义事件触发 选取子节点 更新自定义组件数据 触发生命周期检测工具开发者工具自带检测评分页面，可以分析页面存在的问题。wxss 覆盖率较低，有些动画样式比如 @keyframes 是检测不到的。以及可以通过性能面板查看页面性能。小伙伴们有其他建议欢迎留言评论^ ^"}
{"title": "5个套路看懂微信小程序开发 ", "author": "Rolan", "pub_time": "2019-6-21 00:17", "content": "你或许听说过，快速入门就是要学最小必要知识。而我最近在看微信小程序的官方教程时发现，这个教程虽然简单，但对于微信小程序开发来说，80%的套路都能从这里学习到，你的小程序从0到1可以从这里实现突破。在开始之前，先做100字的铺垫。一个页面 = 4个文件小程序的每个页面都是由4个文件组成的 ，前两个最重要，是我们的重头戏。先给这几个文件一个简短的解释：js 文件——数据来源；wxml 文件——页面的骨架；wxss 文件——页面的装饰效果；json 文件——可选，配置页面上的零件。另外，本文的目标读者是真心想要尝试小程序的无经验开发者，英语水平要求中学及格水平以上。另外，为了你可以动手跟着做，请下载微信开发工具并注册微信小程序。部分语言过于通俗是为了更好的理解。绑定数据现在就开始我们的第一个套路。小程序简易教程 -> 编写代码 -> 创建页面 -> 第二个代码块依照小程序的定义，小程序中的每个页面都包含一个js文件。在一个 js 文件中，你需要列出这个页面上需要的数据（上图红框中的内容）。也就是说，data下面规定的数据（请努力去上图中找到 data），就是页面上需要用到的数据。这就叫做数据绑定。「数据绑定」对你来说可能是个新词汇。这里先不急着理解，我们的目标是会用，会用了就能理解一大半了。怎么应用「数据绑定」呢？只需要两步：1，声明；2，使用。声明的格式是这样的（类似上图中的内容）：Page({data: {greeting: 'Hello World'}//...})在微信开发工具中是这样的：注意看红框中的内容，和上面的代码块是一样的注意看 data 那个部分，我声明了名字为greeting的数据。（所谓数据，学名应该叫变量，但在我们的教程里可以近似理解。）第二步是使用。使用的意思是，我们到页面上把这个数据显示出来。方法是这样的：{{greeting}}注意看{{ }}之间的部分，我们只需要把刚刚定义好的数据名称写在两个大括号里就行了。顺带一提，这种使用数据的方法，叫做八字胡方法（英文Mustache），因为加上的两个大括号可以想象成嘴上的胡子。或许记住了胡子，你就记住了这种使用方法。这就完成了我们的第一个套路——数据绑定。简单吧！但是这里有一个疑问，我们在哪里使用绑定好的数据呢？也就是问，在哪里使用{{greeting}}这句程序呢？答案是我们的页面上，也就是 wxml 这个文件中。这就是我们的下一个套路——显示数据。显示数据上一个套路的讲解中，我们出现了这样一句程序{{greeting}}。这是在使用数据。但这行代码的完整版其实是这样的：<text class=\"your-class\">{{greeting}}</text>在微信开发工具中的样子是这样的：还是看红框内的内容，也请注意这是在 wxml 文件中我们对{{greeting}}这一部分已经熟悉，但对于它前面和后面的代码还不熟悉。所以我们现在进行讲解。显示数据时，我们其实希望显示出来的内容是很好看的。但如果你只写成{{greeting}}，显示出来的效果并不好：最左边红框中的文字一点装饰效果都没有为了让显示数据有更好看的效果，我们需要对{{greeting}}进行装饰。怎么装饰数据呢。我们要用2个东西：标签样式表什么是标签，我们从例子中来理解：{{greeting}}两边的<text class=\"your-class\">和</text>就是标签，而且分别叫开始标签和结束标签。（你能发现开始标签和结束标签的区别么？）开始标签可以定义一些属性，以便调整显示的结果。这就像是你画一幅画可以选择用毛笔，来画出国画的效果。在上面的例子中，class=\"your-class\"就是<text>这个标签的一个属性，<text>标签会表现出class=\"your-class\"的规定的样子。那么class=\"your-class\"这个属性的完整意思是什么呢？他的意思是<text>的 class 对应样式表中的your-class。对，你可以把等号理解为对应。而后面的\"your-class\"就是我们在样式表中规定好的一种装饰效果。这里出现了我们的第2个工具：样式表。样式表是写在 wxss 文件中的，我们来看看怎么写：.your-class {display: flex;flex-direction: column;align-items: center;color: blue;}在开发者工具中的样子是这样的：你通过理解代码中英文的字面意思就可以了解到，我把字的 color 定义为蓝色，把位置定义为 center。最重要的，是这个样式的名字，叫做.your-class，而<text>标签中的 class 属性，正好指向这个样式，所以<text>中的数据会变成中间位置的蓝色字。（在.your-class的最前面有一个点，那是对应<text>中 class 属性的特有标记，还有类似的标记[1]，可以在以后更多的实践中去理解)到这里，我们的前两个套路就已经简单的介绍完了。总结一下：绑定数据：在 js 文件中的 Page 模块下面定义 data 的名字，并用八字胡方法({{ }})来使用数据。显示数据：在 wxml 中给数据加上标签（比如 text 标签），并且给标签加上属性（比如 class 属性）。class 对应的样式在 wxss 文件中写好。不过，我们这里好像缺了什么。我好像没教大家怎么写最后一步的 wxss。微信文档说，wxss 和 css 大体上都是一样的[2]。大家可以去找找css的书，或者期待我后续的实践教程，带你一步一步写一个能上线的小程序。现在，如果你把这两个套路循环用起来，已经能解决很多问题了。想要多显示一个数据，就先在 js文件中绑定这个数据，然后去 wxml 文件中装饰数据。下面是绑定两个数据的示例代码：Page({data: {greeting: 'Hello World',farewell: 'Goodbye!'}//其他内容})而对应显示这两个数据的示例代码是这样的：<!--index.wxml--><text class=\"your-class\">{{greeting}}</text><view class=\"your-class\">{{farewell}}</view>在开发者工具中显示的样子是这样的：我在写教程的过程中升级了一次开发者工具，所以界面有变化大家可以看到，我在最右侧的红箭头处加入了一行新代码， 然后显示出了新数据。但是，这次不一样的是，我用了一个叫做<view>的标签，而不是之前的<text>标签。其实 wxml 文件中可以使用很多种标签来显示数据，有负责显示图片的，有可以负责滚动效果的的，他们都被写在微信文档中，你在实践的过程中可以查看。比如，我使用了一个叫做<icon>的标签，然后显示出了一个圆形的图标：有了「绑定数据」和「显示数据」这两个套路，我们已经能够写出一个简单的页面了。能够做到展示，但没有交互，所以我们进入第三个套路：绑定交互。绑定交互绑定交互这个名字听起来有没有和之前的「绑定数据」很像？他们的操作方法也很相似。绑定交互分为两步：声明：在 js 文件中声明交互的名称。使用：在 wxml 文件中使用这个交互。先来看「声明」。怎么声明一个交互呢？（或者用微信文档的说法，怎么来声明一个事件呢？）请在 js 文件中写下这样几行代码，就在我们之前绑定数据的 data 模块下面：changeWord: function() {this.setData({farewell: 'Never Say Goodbye!'})}在开发者工具中的样子是：这样，我们就声明了一个叫做changeWord的交互。这个交互的具体内容是，改变 farewell 这个数据的内容。原来是Goodbye!，现在我们要改成Never Say Goodbye!。而这个声明中function，this，setDate都是什么意思，我们在后面实践中再讲，大家关注的重点是这个声明中最前面的部分，也就是这个交互的名字：changeWord。我们已经声明完了这个交互，现在就该进入第2步——使用交互。请在 wxml 中插入这样的代码片段：<button bindtap=\"changeWord\" type='primary' class=\"your-button\" size='default'>改变文字</button>在开发者工具中的的样子是这样的：这里的重点是bindtap=\"changeWord\"，大家可以看到我们刚刚声明的交互changeWord出现了，那前面的bingtap=是什么呢？他的意思是：把点击事件的交互对应到changeWord。当你点一下图中的那个绿色按钮，我们的页面就会把Goodbye!换为 Never Say Goodbye!除了利用标签的bindtap属性来绑定交互，还可以用bindlongtap（绑定长按事件），bindtouchmove（绑定触摸后移动事件）等等，他们都有各自的效果。具体内容都被写在事件相关的文档中，你可以亲自试一下。你会发现他们的开头都是 bind，就好像单词的前缀一样，加上tap，longtap等后缀，就能帮你绑定一个交互。（绑定事件的前缀还有另外一种，叫catch，比如catchtap，catchtouchmove等等，你可以结合文档，试验一下他们的效果）[3]到这里，我们已经能够简单的绑定交互了。但绑定交互的核心目的是要改变页面上的显示，从而给用户一个反馈。下面就让我们来看看第4个套路：修改显示。执行交互就像绑定数据之后，要去显示数据。我们绑定交互之后，也要让交互被执行，这样才有意义。而交互的执行内容，就写在被声明的交互的下面：changeWord: function() {// 这里写交互的实际内容}我们这里介绍两种交互内容的写法，足够解决很多问题了：修改页面数据弹窗第一种，修改页面数据。我们在上一个套路的实例代码中已经见过：changeWord: function() {this.setData({farewell: 'Never Say Goodbye!'})}这几行代码中间的部分，就是要执行的交互内容：this.setData({farewell: 'Never Say Goodbye!'})即使你不懂得javaScript编程语言，也完全可以从英语的字面意思去理解这几行代码。这3行代码是在说，我这个页面(this)要修改数据(setData)中的farewell为 Never Say Goodbye!。如果你想修改其他数据，比如greeting，你可以如法炮制：changeAnotherWord: function() {this.setData({greeting: 'Hello, again!'})}你会发现这里面有很多结构是固定的。变化的部分只有交互的名称（变成了changeAnotherWord）和要修改的数据（变成了greeting: 'Hello, again!'）。如果你也想修改页面上的数据，请如法炮制。我们要介绍的第二种交互方法是弹窗，而且是微信内建的弹窗。首先，还是要做一下绑定交互这个套路：1，在 js 文件中声明一个交互；2，在 wxml 中使用这个交互。声明交互的代码如下（在 js 文件中），我们用showConfirmation作为名称： showConfirmation: function() {\r\n var that = this\r\n wx.showModal({\r\n title: '提示',\r\n content: '你确定要更改文字吗？',\r\n showCancel: true,\r\n cancelText: '取消',\r\n confirmText: '确定',\r\n success: function (response) { \r\n that.changeWord()\r\n }\r\n })\r\n }\r\n在微信开发者工具中是这样的：先不要在乎这里面陌生的代码，我们继续看使用交互的部分：<button bindtap=\"showConfirmation\" type='primary' class=\"your-button\" size='default'>改变文字</button>我把上一个套路中出现的 button 改写成了绑定到这个showConfirmation，在微信开发者工具中的样子是这样的：写完之后，我再去点「改变文字」的按钮，就会出现对话框：箭头连接的两部分是一样的，你发现了吗你会发现，所有的不一样，都只是在 js 文件中showConfirmation的下面，其他的部分都符合我们以前的套路。那我们就看看那段陌生的代码： var that = this\r\n wx.showModal({\r\n title: '提示',\r\n content: '你确定要更改文字吗？',\r\n showCancel: true,\r\n cancelText: '取消',\r\n confirmText: '确定',\r\n success: function (response) { \r\n that.changeWord()\r\n }\r\n })\r\n我们从wx.showModal看起，这是一个微信内建的代码表达方式，从英文的字面就能理解他是什么意思：请微信（wx）显示一下对话框（showModal）。那怎么用这个工具呢，微信的文档里面已经写好了：我们只需要像填空一样，把制作对话框需要的 title, content, showCancel 等需要填充的地方填好就可以了。这样，微信会帮助我们制作出一个对话框。但在这段代码中，有一个比较难解释的地方，就是var that = this和that.changeWord()。你能猜到他们是联动的，因为他们都有一个that。具体的意思是：把这个页面存储在那个地方（var that = this），让那个地方的数据中的文字改变（that.changeWord()）。为了避免混乱，我们暂时解释到这里。而且这两行也不影响我们制作一个对话框。因为制作对话框只需要做一件事[4]：使用wx.showModal跳转到这里，我们已经能在一个页面上使用4个套路了：绑定数据，显示数据，绑定交互，修改数据。如果你的小程序比较复杂，那么，是时候跳转到下一个页面来开辟一片新战场。要跳转到下一个页面，我们只需要最后一个套路：跳转。跳转本质上也是一种交互，我们完全可以用上面提到的「绑定交互」和「执行交互」来实现。再重复一遍这两步：1，在 js 文件中声明一个交互；2，在 wxml 中使用这个交互。我们先在 js 文件中声明一个名为navigateToLogs的交互：navigateToLogs: function() {wx.navigateTo({url: '/pages/logs/logs'})}在开发者工具中的样子是这样的：这里面有我们不太熟悉的代码，比如wx.navigateTo，根据上一个套路的经验，你已经能够大致猜到他的意思了，对么？不过我们还是把下一步走完再说。在 wxml 中使用这个交互：<button bindtap=\"navigateToLogs\" type='default' class=\"your-button\" size='default'>跳转</button>在开发者工具中的样子是这样的：好了，现在，如果我们点一下「跳转」按钮，他就会跳到下一页。已经看完了效果，我们回来看那段不熟悉的代码：wx.navigateTo({url: '/pages/logs/logs'})这一次，我们依然可以从字面理解：请微信（wx）导航到（navigateTo）logs 路径下的页面（url: '/pages/logs/logs'）。其中 url 这个数据是微信要求的，在文档中可以找到他的说明，我们依然是照着文档来填空就可以了[5]。这里面有一点需要说明，新页面的地址叫做'/pages/logs/logs'，他是从哪里来的呢？大家看下图红框中的文件结构，会发现 logs 这个页面的地址就是 pages 文件夹下面的 logs 文件夹下面的 logs 文件（有4个文件，但都叫 logs），用标准的格式表示，就成了我们刚刚提到的/pages/logs/logs。更进一步，按照微信的规定，我们还需要把他写在一个叫做app.json的配置文件中，这样微信才允许我们跳转到那个路径。总结一下好了，到这里，我们把5个套路都学完了。如果你能把他们组合起来，不断使用，你就能制作一个用很多功能的小程序：绑定数据——在 js 文件中声明数据名称显示数据——在 wxml 中写出数据显示的位置，并在 wxss 中写出装饰效果绑定交互——在 js 文件中声明交互的名称执行交互——在 js 文件中支出要修改的数据或者显示弹窗跳转——跳转到下一页，开辟新的战场番外篇——调取微信数据微信小程序其实还有一个隐含套路，叫做调用微信提供的接口。用微信官方的话讲，就是使用微信的能力。如果没有这些能力，微信小程序只能叫小程序，而不能叫「微信」小程序。其实，我们已经在上面见过一些微信小程序的能力了，比如显示弹窗的wx.showModal，比如跳转下一页的wx.navigateTo你已经发现，他们的特点都是wx.开头。更多的能力还有，还有获取用户头像，打开扫一扫这样的能力。他们怎么用呢？其实都是查文档，看看这个方法需要你提供哪些数据，提供给他就好了。用两个字总结就是：填空。最后的最后，轻轻说一句，对于刚刚入门的开发者，最大的坑可能是——忘记保存。因为我曾经也是个新手，在很多领域依然是新手，甚至还没有入门。希望这份教程能帮到你。共勉。这种标记叫做选择器，可以在这个小程序 wxss 文档的选择器那一节找到而且是个简版的css，不会用到复杂一点的级联样式另外，还有两类特殊的交互，为了避免大家混乱，我没有讲，但在我们后续的教程中会用到，感兴趣的朋友可以先了解一下：一类是某些标签特有的绑定方法，比如<checkbox-group>便签有一个特有属性 bindchange，可以用来绑定交互。另一类是用户关闭和打开页面时绑定的交互，比如onLoad，这类交互都是以 on 开头的，代表这个页面的事件，直接在 js 文件中声明，不用再 wxml 中绑定到标签。微信还有2个可用弹窗类交互，大家可以对照文档进行实验。微信出了提供wx.navigateTo这个跳转方法，还提供了其他4个导航相关的方法，你可以在实践中体会他们的区别。另外，微信还提供了<navigator>标签来实现跳转，跟wx.navigateTo等方法实现同样效果，为避免混乱，这里只留下文档地址，不详细举例。"}
{"title": "微信小程序开发之页面分享 onShareAppMessage 分享参数用处 ", "author": "Rolan", "pub_time": "2019-8-19 00:08", "content": "今天下午突然听到群里有人说微信小程序工具更新了,文档也更新了不少内容.顾不上吃冬至的饺子.我就冲进来了.先说分享功能,目前真机尚不能调试.开发工具上可以看看效果.后续还会更新.Page()中加上如下代码后在右上角就会出现三个小白点title:分享的标题.desc:分享一段描述.path:这个参数有点意思.以前在微信中的分享一般都是url.这里是当前页面这里应该是pages/index?id=123这里的id目前还不知道是什么.也就是说以后你可以在微信中像分享一个网页一样分享一个页面了.onShareAppMessage: function () {\r\n    return {\r\n      title: '垃圾分类黑板报',\r\n      desc: '垃圾分类就选垃圾分类黑板报!',\r\n      path: '/page/user?id=123'\r\n    }\r\n  }分享参数用处:我这里没有用到路径后的参数,说个场景:参数是用户昵称,A分享了XXX小程序到微信群里,B点开小程序,弹个toast,”来自A的分享”."}
{"title": "微信小程序开发中各种跳转方式的区别 ", "author": "Rolan", "pub_time": "2019-10-21 00:48", "content": "wx.navigateTo、wx.redirectTo、wx.reLaunch、wx.switchTab和wx.navigateBack有什么区别呢？wx.navigateTo：用于保留当前页面、跳转到应用内的某个页面，使用 wx.navigateBack可以返回到原页面。对于页面不是特别多的小程序，通常推荐使用 wx.navigateTo进行跳转， 以便返回原页面，以提高加载速度。当页面特别多时，则不推荐使用。wx.redirectTo：当页面过多时，被保留页面会挤占微信分配给小程序的内存，或是达到微信所限制的 5 层页面栈。这时应该考虑选择 wx.redirectTo。wx.redirectTo()用于关闭当前页面，跳转到应用内的某个页面。这样的跳转，可以避免跳转前页面占据运行内存，但返回时页面需要重新加载，增加了返回页面的显示时间。wx.reLaunch：wx.reLaunch()与 wx.redirectTo()的用途基本相同， 只是 wx.reLaunch()先关闭了内存中所有保留的页面，再跳转到目标页面。wx.switchTab：对于跳转到 tab bar 的页面，最好选择 wx.switchTab()，它会先关闭所有非 tab bar 的页面。其次，也可以选择 wx.reLaunch()，它也能实现从非 tab bar 跳转到 tab bar，或在 tab bar 间跳转，效果等同 wx.switchTab()。使用其他跳转 API 来跳转到 tab bar，则会跳转失败。wx.navigateBack：用于关闭当前页面，并返回上一页面或多级页面。开发者可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层。这个 API 需要填写的参数只有 delta，表示要返回的页面数。若 delta 的取值大于现有可返回页面数时，则返回到用户进入小程序的第一个页面。当不填写 delta 的值时，就默认其为 1（注意，默认并非取 0），即返回上一页面。本文来自木庄网络博客> wx.navigateTo、wx.redirectTo、wx.reLaunch、wx.switchTab和wx.navigateBack的区别"}
{"title": "微信小程序开发者自助解绑小程序 ", "author": "Rolan", "pub_time": "2019-11-14 00:52", "content": "最近在帮朋友开发小程序时，朋友突然告诉我，不能绑定开发者了。但是就比较纳闷，问了下，才知道，一个微信号只能绑定为50个小程序的开发者。当时就比较懵了，之前我帮过好多人开发过小程序，这些小程序都绑定过我为开发者，可是具体是那些人，真的有点忘记了。就去官方文档搜，还真给搜到了。官方给出的解决办法如下由于忘记都有谁绑定过我为开发者了，所以只能有第二种方式了。 这不看不知道，一看吓一跳啊。我居然被好多根本就没接触过的小程序绑定为开发者了。因为小程序绑定开者太容易了，知道你的微信号，就可以绑定你为开发者。至于这些人为啥要把我添加为开发者呢，想来想去也就这个原因了。一个极速审核奖励。。。。。。大刀阔斧的解绑开发者权限1，搜索微信公众号：公众平台安全助手 ，关注公众号，必须要关注公众号。这个我就不多说了2，进入公众号对话的主界面，左下角找到 <绑定查询> 可以根据手机号、身份证号以及微信号的方式查询，这里要用根据 微信号绑定账号 的方式查询。3，点击进入后，会看到：公众号、小程序、开放平台。因为我们的目的是微信开发者/体验者自主发起解绑小程序账号，所以选择的是小程序，可以看到你目前作为管理员和作为项目成员分别下面有那些小程序账号，在这个页面可以看到每个小程序的头像、名称4，以这个大米色选机为例，点击会弹出上图的解绑按钮，然后点击解绑5，解绑以后会有个以下通知这样就解绑成功了，后面自己慢慢的把自己用不到的，或者自己根本不知道的都给解绑了，后面就剩下这几个自己常用的了。这样以后又可以愉快的帮别人改小程序的代码了。是不是清爽很多了，今天就到这里了。"}
{"title": "微信小程序开发技巧 ", "author": "Rolan", "pub_time": "2019-11-18 00:43", "content": "开发小程序这么久了，整理了一些技巧清单，分享出来。\r\n1、backgroundColor 配置无效\r\n页面配置中 backgroundColor 可以设置窗口颜色：\r\n{\r\n  \"backgroundColor\": \"#f2f2f2\"\r\n}\r\n复制代码这么设置完之后发现一点效果都没有，仔细研究一番，原来窗口颜色指的是最底层。（真想说句：卧槽~）\r\n\r\n解决这个问题很简单，使用 page 选择器即可：\r\npage {\r\n  background: #f2f2f2;\r\n}\r\n复制代码page 是页面的根节点，也就是h5里的 html，所以可以用来设置一些样式。\r\n2、改变自定义组件根节点样式\r\nheader组件代码如下：\r\n<view class=\"header\">\r\n  header\r\n</view>\r\n复制代码可以看到渲染出来后发现多出 header 节点。\r\n\r\n在大部分开发中跟组件节点并没有什么用， 但是 某些情况下是会影响样式的， 比如说弹性布局，这里不贴demo了，反之此技巧必定用到，回头瞧瞧就行。\r\n我们可以在自定义组件样式文件使用 :host 选择器修改跟组件节点：\r\n:host {\r\n  padding: 50px;\r\n}\r\n复制代码可以对比上图盒子模型\r\n\r\n3、block标签是什么\r\nblock 标签其实就类似于 react 中的 Fragment, Vue中的 template。\r\n如果没接触过 react/vue 没关系，看下面例子：\r\n<block>\r\n  <view>say</view>\r\n  <view>hello</view>\r\n</block>\r\n复制代码渲染后结果, block 节点消失\r\n<view>say</view>\r\n<view>hello</view>\r\n复制代码如果没有block节点，需要这么做:\r\n<!-- 多渲染了跟节点标签 -->\r\n<view>\r\n  <view>say</view>\r\n  <view>hello</view>\r\n</view>\r\n复制代码比较常用的用来配合 wx:if\r\n<block wx:if=\"{{ show }}\">\r\n  <view wx:for=\"{{ arr }}\" wx:key=\"index\">{{ item }}</view>\r\n</block>\r\n复制代码4、如何设置背景图片\r\n搞个背景图片都费劲 [发火]\r\n\r\n平常在h5中设置背景图片直接引入地址就行\r\nbackground: url(\"/example.png\");\r\n复制代码但是在小程序中竟然不可以。。。\r\n为啥？？？\r\n小程序： 你只能乖乖引入网络图片\r\nxx: mmp, 设置个图片都搞那么多花样？ 我觉得...\r\n小程序：我不要你觉得， 我要我觉得。\r\n复制代码xx了。 只能走后门了。\r\n1、可以将图片转成 base64 即可：\r\nbackground-image: url(\"data:image/svg+xml;base64,PHN2ZyBjbGFzcz0ibGRzLXNwaW5uZXIiIHdpZHRoPSIxMDlweCIgIGhlaWdodD0iMTA5cHgiICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQiIHN0eWxlPSJiYWNrZ3JvdW5kOiBub25lOyI+PGcgdHJhbnNmb3JtPSJyb3RhdGUoMCA1MCA1MCkiPgogIDxyZWN0IHg9IjQ3IiB5PSIyNCIgcng9IjkuNCIgcnk9IjQuOCIgd2lkdGg9IjYiIGhlaWdodD0iMTIiIGZpbGw9IiMwMDAiPgogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ib3BhY2l0eSIgdmFsdWVzPSIxOzAiIHRpbWVzPSIwOzEiIGR1cj0iMXMiIGJlZ2luPSItMC45MTY2NjY2NjY2NjY2NjY2cyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZT4KICA8L3JlY3Q+CjwvZz48ZyB0cmFuc2Zvcm09InJvdGF0ZSgzMCA1MCA1MCkiPgogIDxyZWN0IHg9IjQ3IiB5PSIyNCIgcng9IjkuNCIgcnk9IjQuOCIgd2lkdGg9IjYiIGhlaWdodD0iMTIiIGZpbGw9IiMwMDAiPgogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ib3BhY2l0eSIgdmFsdWVzPSIxOzAiIHRpbWVzPSIwOzEiIGR1cj0iMXMiIGJlZ2luPSItMC44MzMzMzMzMzMzMzMzMzM0cyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZT4KICA8L3JlY3Q+CjwvZz48ZyB0cmFuc2Zvcm09InJvdGF0ZSg2MCA1MCA1MCkiPgogIDxyZWN0IHg9IjQ3IiB5PSIyNCIgcng9IjkuNCIgcnk9IjQuOCIgd2lkdGg9IjYiIGhlaWdodD0iMTIiIGZpbGw9IiMwMDAiPgogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ib3BhY2l0eSIgdmFsdWVzPSIxOzAiIHRpbWVzPSIwOzEiIGR1cj0iMXMiIGJlZ2luPSItMC43NXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIj48L2FuaW1hdGU+CiAgPC9yZWN0Pgo8L2c+PGcgdHJhbnNmb3JtPSJyb3RhdGUoOTAgNTAgNTApIj4KICA8cmVjdCB4PSI0NyIgeT0iMjQiIHJ4PSI5LjQiIHJ5PSI0LjgiIHdpZHRoPSI2IiBoZWlnaHQ9IjEyIiBmaWxsPSIjMDAwIj4KICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9Im9wYWNpdHkiIHZhbHVlcz0iMTswIiB0aW1lcz0iMDsxIiBkdXI9IjFzIiBiZWdpbj0iLTAuNjY2NjY2NjY2NjY2NjY2NnMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIj48L2FuaW1hdGU+CiAgPC9yZWN0Pgo8L2c+PGcgdHJhbnNmb3JtPSJyb3RhdGUoMTIwIDUwIDUwKSI+CiAgPHJlY3QgeD0iNDciIHk9IjI0IiByeD0iOS40IiByeT0iNC44IiB3aWR0aD0iNiIgaGVpZ2h0PSIxMiIgZmlsbD0iIzAwMCI+CiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJvcGFjaXR5IiB2YWx1ZXM9IjE7MCIgdGltZXM9IjA7MSIgZHVyPSIxcyIgYmVnaW49Ii0wLjU4MzMzMzMzMzMzMzMzMzRzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlPgogIDwvcmVjdD4KPC9nPjxnIHRyYW5zZm9ybT0icm90YXRlKDE1MCA1MCA1MCkiPgogIDxyZWN0IHg9IjQ3IiB5PSIyNCIgcng9IjkuNCIgcnk9IjQuOCIgd2lkdGg9IjYiIGhlaWdodD0iMTIiIGZpbGw9IiMwMDAiPgogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ib3BhY2l0eSIgdmFsdWVzPSIxOzAiIHRpbWVzPSIwOzEiIGR1cj0iMXMiIGJlZ2luPSItMC41cyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZT4KICA8L3JlY3Q+CjwvZz48ZyB0cmFuc2Zvcm09InJvdGF0ZSgxODAgNTAgNTApIj4KICA8cmVjdCB4PSI0NyIgeT0iMjQiIHJ4PSI5LjQiIHJ5PSI0LjgiIHdpZHRoPSI2IiBoZWlnaHQ9IjEyIiBmaWxsPSIjMDAwIj4KICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9Im9wYWNpdHkiIHZhbHVlcz0iMTswIiB0aW1lcz0iMDsxIiBkdXI9IjFzIiBiZWdpbj0iLTAuNDE2NjY2NjY2NjY2NjY2N3MiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIj48L2FuaW1hdGU+CiAgPC9yZWN0Pgo8L2c+PGcgdHJhbnNmb3JtPSJyb3RhdGUoMjEwIDUwIDUwKSI+CiAgPHJlY3QgeD0iNDciIHk9IjI0IiByeD0iOS40IiByeT0iNC44IiB3aWR0aD0iNiIgaGVpZ2h0PSIxMiIgZmlsbD0iIzAwMCI+CiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJvcGFjaXR5IiB2YWx1ZXM9IjE7MCIgdGltZXM9IjA7MSIgZHVyPSIxcyIgYmVnaW49Ii0wLjMzMzMzMzMzMzMzMzMzMzNzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlPgogIDwvcmVjdD4KPC9nPjxnIHRyYW5zZm9ybT0icm90YXRlKDI0MCA1MCA1MCkiPgogIDxyZWN0IHg9IjQ3IiB5PSIyNCIgcng9IjkuNCIgcnk9IjQuOCIgd2lkdGg9IjYiIGhlaWdodD0iMTIiIGZpbGw9IiMwMDAiPgogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ib3BhY2l0eSIgdmFsdWVzPSIxOzAiIHRpbWVzPSIwOzEiIGR1cj0iMXMiIGJlZ2luPSItMC4yNXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIj48L2FuaW1hdGU+CiAgPC9yZWN0Pgo8L2c+PGcgdHJhbnNmb3JtPSJyb3RhdGUoMjcwIDUwIDUwKSI+CiAgPHJlY3QgeD0iNDciIHk9IjI0IiByeD0iOS40IiByeT0iNC44IiB3aWR0aD0iNiIgaGVpZ2h0PSIxMiIgZmlsbD0iIzAwMCI+CiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJvcGFjaXR5IiB2YWx1ZXM9IjE7MCIgdGltZXM9IjA7MSIgZHVyPSIxcyIgYmVnaW49Ii0wLjE2NjY2NjY2NjY2NjY2NjY2cyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZT4KICA8L3JlY3Q+CjwvZz48ZyB0cmFuc2Zvcm09InJvdGF0ZSgzMDAgNTAgNTApIj4KICA8cmVjdCB4PSI0NyIgeT0iMjQiIHJ4PSI5LjQiIHJ5PSI0LjgiIHdpZHRoPSI2IiBoZWlnaHQ9IjEyIiBmaWxsPSIjMDAwIj4KICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9Im9wYWNpdHkiIHZhbHVlcz0iMTswIiB0aW1lcz0iMDsxIiBkdXI9IjFzIiBiZWdpbj0iLTAuMDgzMzMzMzMzMzMzMzMzMzNzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlPgogIDwvcmVjdD4KPC9nPjxnIHRyYW5zZm9ybT0icm90YXRlKDMzMCA1MCA1MCkiPgogIDxyZWN0IHg9IjQ3IiB5PSIyNCIgcng9IjkuNCIgcnk9IjQuOCIgd2lkdGg9IjYiIGhlaWdodD0iMTIiIGZpbGw9IiMwMDAiPgogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ib3BhY2l0eSIgdmFsdWVzPSIxOzAiIHRpbWVzPSIwOzEiIGR1cj0iMXMiIGJlZ2luPSIwcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZT4KICA8L3JlY3Q+CjwvZz48L3N2Zz4=\");\r\n复制代码2、内联节点中使用 backgorund-image\r\n<view style=\"background-image: url(example.png)\">\r\n</view>\r\n复制代码这个方法我就不该说出来~ 因为在真机是无效的。。。（欲哭无泪）\r\n3、使用 image\r\n这个方法我也懒得详细贴demo了， 总之就是使用 image 改改样式设置到底部即可。\r\n<view>\r\n  <image src=\"example.png\" />\r\n</view>\r\n复制代码最后：现在的项目本地图片使用是非常少的，反正我见过的项目最多也就几张。 所以设置背景图片最简单的方法就是使用base64。\r\n5、object-fit无效\r\n在h5中使用 object-fit 特性是非常多的，它可以对图片保持一定的比例，而不会发生变形， 如果想了解其具体内容到 MDN\r\n在小程序中对图片使用此特性是没有效果的\r\n.image {\r\n  object-fit: cover;\r\n}\r\n复制代码解决这个问题也很简单，使用小程序自带的属性即可\r\n<image src=\"example.png\" mode=\"aspectFill\"></image>\r\n复制代码具体属性可到官方查看 mode属性一览\r\n6、小程序mock数据\r\n在WEB开发中我们会使用 mockjs 进行拦截请求从而模拟数据。\r\n在小程序中也可以使用吗？  那当然了， 只不过要对小程序 wx.request 处理。\r\n1、安装 mockjs\r\nnpm i mockjs\r\n复制代码2、新建 wxMock.js\r\n// 有点水平的应该能看得懂\r\n// 微信底层API都是不能重写的，所以用到 defineProperty 将其设置可写\r\n// 之后重写了底层 wx.request 方法，然后做些处理即可\r\n\r\nconst __request = wx.request;\r\nconst Mock = require('mockjs');\r\n\r\nObject.defineProperty(wx, 'request', { writable: true });\r\n\r\nwx.request = function (config) {\r\n  if (typeof Mock._mocked[config.url] === 'undefined') {\r\n    __request(config);\r\n    return;\r\n  }\r\n\r\n  const resTemplate = Mock._mocked[config.url].template;\r\n  const response = Mock.mock(resTemplate);\r\n\r\n  if (typeof config.success === 'function') {\r\n    config.success(response)\r\n  }\r\n  \r\n  if (typeof config.complete === 'function') {\r\n    config.complete(response)\r\n  }\r\n};\r\n\r\nmodule.exports = Mock;\r\n复制代码3、使用 wxMock.js\r\nconst Mock = require('wxMock.js')\r\n\r\n// 平常怎么用的就怎么用\r\nMock.mock('/api/example', {\r\n  data: { ... }\r\n})\r\n复制代码4、在app.js入口文件中引入mock\r\nimport \"./mock/index.js\";\r\n复制代码7、图片宽度100%，高度无法自适应\r\n在WEB开发中当把图片设置 100% 时，高度会自适应。\r\n小程序就是不行，不行你看：\r\n\r\n因为小程序底层已经对 image 添加了宽高了，所以默认就是 240px。\r\n解决方法是给 image 元素添加 mode 属性\r\n<image src=\"example.png\" mode=\"widthFix\"></image>\r\n复制代码当添加此模式并给图片设置 100% 宽度后，小程序自动计算其高度，就可以让图片自适应了。\r\n\r\n8、properties 能定义多个类型吗？\r\n我只能先说可以。\r\n此特性是小程序基础库2.6.5新增的，可能有些小伙伴不知道。\r\noptionalTypes 字段是个数组，指定属性类型，可以多个。\r\nComponent({\r\n  properties: {\r\n    lastLeaf: {\r\n      // 这个属性可以是 Number 、 String 、 Object 三种类型中的一种\r\n      type: Number,\r\n      optionalTypes: [String, Object],\r\n      value: 0\r\n    }\r\n  }\r\n})\r\n复制代码9、跳转到tabbar无法返回上一层\r\n这个问题我估计每一个开发者都经历过。\r\n常规页面跳转到 tabbar 页面只能使用 wx.switchTab ，此API有个问题是：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面\r\n所以当跳转到 tabbar 页面左上角返回键自然就没了，所以是无法返回上一层的。\r\n用得比较多的场景就是购物车了， 某个页面跳转到购物车不可以返回上一层那体验不是很差么。\r\n这个问题我就不贴demo了，说下其方案。\r\n\r\n自定义导航头部，新增一个返回键\r\n自定义 tabbar 组件， 这个时候就不存在什么 switchTab 跳转了\r\n将购物车页面封装成一个组件，然后新建2个页面，一个作为tabbar，一个作为常规页面，目前jd使用这种方案。\r\n\r\n总结\r\n微信小程序开发和 web 还是有一些区别的， 小程序的开发灵活度虽然现在没有那么高，但随着不断的迭代更新，会慢慢得到改善，并受到众多开发者的喜爱。\r\n这篇文章不会断更，只要有些好的技巧会总结下来并分享。"}
{"title": "微信小程序支持 webP 的 WebAssembly 方案 ", "author": "Rolan", "pub_time": "2019-8-20 00:24", "content": "相信不少人听说过 WebAssembly，它是由 Google、Microsoft、Mozilla、Apple 等几家大公司合作发起的一个关于面向 Web 的通用二进制和文本格式的项目。本文我们将跟随作者一步步揭开 WebAssembly 的神秘面纱，并了解 WebAssembly 是如何应用在实际业务中的。引言实践检验真理，让我们一起动手将 WebAssembly 应用在微信小程序场景中，让微信小程序环境支持解码 webP 格式（不了解或没听过 webP 的各位同仁，请先移步到 “探究 WebP 的一些事儿” ）。WebAssembly 工作流程动手之前，让我们先来了解下如何加载和运行 WebAssembly 的代码：C / C++ / Rust / Java 等高级语言开发的代码或功能库 -> Emscripten 编译 -> wasm 文件 -> 结合 WebAssembly JS API -> 浏览器环境中运行，如下图所示：简单来说，编译前端 LLVM / Emscripten 流程可以获得 wasm 文件和胶水 js。然后，通过胶水 js 来加载 wasm 并转为 arrayBuffer 格式。紧接着进行编译和实例化后，即可用 JavaScript 与 WebAssembly 通信。详细过程以及每个过程调用的 API 如下图所示：浏览器环境支持 webP了解完 WebAssembly 的工作流程后，是不是还不清楚要从哪开始搞起？你可以去 github 官网上看一下 libwebp 开源项目 ，Google 已经完全支持把 libwebp 源码编译为 wasm 和 asm.js 两个版本了。针对不支持 WebAssembly 的系统或不兼容 WebAssembly 的浏览器，可以在损失一点性能的情况下降级为使用 asm.js。具体编译步骤如下图所示：待编译完之后，我们便可获得 wasm 文件和胶水 JS。然后，我们可以用“python -m SimpleHTTPServer 8080”启动一个本地服务，在浏览器地址栏输入 http://localhost:8080 后就能看到 webP 解码后的图片。最后，让我们来总结下整个流程。（1）用 LLVM / Emscripten / CMake 工具对 libwebp 解码库进行编译，获得 wasm 文件和胶水 JS。（2）胶水 JS 申请内存，对 wasm 文件进行编译、加载和实例化后，导出 Module 对象。（3）利用 Module 对象上的 WebpToSDL 方法对 webP 进行解码，并转成 Canvas 在浏览器渲染显示出来，呈现最终的图片。微信小程序环境支持 webP微信小程序在 Android / iOS 上用于执行脚本以及渲染组件的环境都不尽相同。在 Android 上，微信小程序逻辑层的 JavaScript 代码运行在 V8 中，视图层是由自研 XWeb 引擎基于 Mobile Chrome 67 内核来渲染，天然支持 webP 格式；在 iOS 上，微信小程序逻辑层的 JavaScript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染，宿主 Safari 浏览器内核不支持 webP 格式。通过第 3 节内容，我们知道浏览器环境已经能够支持 webP 了，那直接把之前编译好的 wasm 文件和胶水 JS 扔进微信小程序的运行环境，然后跑起来不就搞定了？Too young too simple!浏览器环境支持 webP 的思路是 libwebp 解码 webP -> jpg / png / gif 的 canvas 图片渲染显示，这已经改变了原来 image 组件的结构。而微信小程序提供给开发者的组件不允许去改变它原来的结构，因此换种思路是 libwebp 解码 webP -> jpg / png / gif 的 rgb data -> jpg / png / gif base64 -> 回传给 JS 并赋值给 image src 进行渲染显示。下面我罗列下从 libwebp 编译 wasm 文件和胶水 JS 开始，直到在微信小程序环境跑通为止，整个过程中遇到的一些坑点和优化点：（1）编译 CMakeLists.txt 时需加上“-O3”选项，大大提升编译速度。（2）编译 CMakeLists.txt 时需加上“-s USE_PTHREADS=0”选项，因为 iOS Safari 浏览器不兼容 ShareArrayBuffer 共享缓冲区。（3）编译 CMakeLists.txt 时需加上“-s ALLOW_MEMORY_GROWTH=1”选项，目的是为了解决解码超大分辨率的 webP 图片时出现的 OOM 问题。（4）由于微信小程序环境的兼容性问题，去除胶水 JS 代码中 libwebp 编译时加上的 SDL 相关代码，能节省 100KB 左右的空间。（5）去除胶水 JS 中 ENVIRONMENT_IS_NODE / ENVIRONMENT_IS_SHELL 相关的代码，因为微信小程序环境并未使用到。（6）由于 iOS Safari 浏览器的兼容性问题，将胶水 JS 中流式编译和实例化的方法去掉，替换成非流式编译和实例化的方法。（7）由于 WebAssembly 还没有和 <script type='module'> 或 ES6 的 import 语句集成，因此将 wasm 文件先转成 base64 字符串。等胶水 JS 运行加载逻辑时，再将 base64 转成 ArrayBuffer 并编译和实例化后导出 Module 对象，节省从服务器下载 wasm 文件的时间。（8）编译 CMakeLists.txt 时需加上“-s USE_LIBPNG=1”选项编译 libpng.a 库，然后将 webP 解码获得的 rgb 数据，通过 png 解码库转成 png 内存数据，紧接着转成 base64 回传给 JS，最后赋值给 image src 进行渲染显示。难点是 rgb 转成 png 内存数据这一步出了点问题，但是 wasm 无法调试代码，只能通过搭建 libpng 的 VS 工程进行断点调试，最终定位到是 rgb 转 png data 时传入的 data_size 为 0 导致。（9）胶水 JS 里的 new WebAssembly.Memory 代码在微信小程序环境运行时，会报“refused to create a webassembly object without ‘unsafe-eval’”的错误，必须在 page-frame.html 里的 CSP 设置里加上 unsafe-eval 才能解决。踩了这么多坑之后，终于能在微信小程序环境里支持 webP 了。实测 WebAssembly 在解码不同格式不同分辨率的 webP 时，性能都完胜 JavaScript。写在最后虽然 WebAssembly 的解码性能比 JavaScript 快不少，但遇到超大分辨率（如 1920 x 1080 等）的 webP 时，却远远落后于客户端的解码性能。综合对比各种方案的性能和兼容性之后，我们还是采用了基于 iOS 客户端自定义协议 webphttps 的方案，大致步骤如下：（1）首先，微信小程序基础库判断开发者在 image 组件使用的是 webP 格式时，则在 image src 里加上 webp 头部如 webphttps://example.png。（2）然后，客户端通过 NSURLProtocol 协议挟持 webphttps 的请求，并下载相应的 webP 数据进行解码。（3）最后，再把解码后的 image 数据回吐给浏览器进行渲染显示。到最后，我们完成了微信小程序环境支持 webP 的方案落地。"}
{"title": "仿微信小程序下拉组件 ", "author": "Rolan", "pub_time": "2019-8-29 00:26", "content": "code小生,一个专注 Android 领域的技术平台公众号回复 Android 加入我的安卓技术群作者： colinWong链接： https://www.jianshu.com/p/739bb01eee80声明： 本文已获 colinWong授权发表，转发等请联系原作者授权1563442819594.gif设计思路1.自定义个组件类似RelativeLayout2.可以内部放子View，然后就是滑动主体在前，小程序View在后3.重写dispatchTouchEvent 控制这两个子View的位置4.加上临界点回弹动画5.手势判断（惯性效果）1.继承RelativeLayout如果要从新写一个GroupView组件需要measure → layout → draw 很多细节要处理也不一定处理的好。所以直接用系统提供的RelativeLayout        public class MoreHeadLayout extends RelativeLayout {\r\n        ...\r\n}\r\n2.内部子View 结构就两个，如下图image.png    private View mHeadView;\r\n    private NewNestedScrollView mBodyView;\r\n   void init(){\r\n        mHeadView = findViewById(R.id.head_layout);//view为head\r\n        mBodyView = findViewById(R.id.body_layout);\r\n    }\r\nxml中的代码image.png3.重写dispatchTouchEvent这一步主要是做控制手指滑动跟随，就是bodyView跟随你的手指滑动先写一个方法，就是控制bodyView纵坐标的位置   private void setMarginTop(int offY) {\r\n        RelativeLayout.LayoutParams paramsBody = (LayoutParams) mBodyView.getLayoutParams();\r\n        int marginTop = paramsBody.topMargin - offY;\r\n        if (marginTop < 0) {\r\n            marginTop = 0;\r\n        } else if (marginTop > mHeadView.getHeight()) {\r\n            marginTop = mHeadView.getHeight();\r\n        }\r\n        paramsBody.topMargin = marginTop;\r\n        mBodyView.setLayoutParams(paramsBody);\r\n    }\r\n再计算滑动距离，然后调用setMarginTop 方法 @Override\r\n    public boolean dispatchTouchEvent(MotionEvent ev) {\r\n        int y = (int) ev.getRawY();\r\n        int offY = lastY - y;\r\n        lastY = y;\r\n        switch (ev.getAction()) {\r\n             ...\r\n            case MotionEvent.ACTION_MOVE:\r\n              if (isBodyTop && headViewVisible()) {\r\n                    setMarginTop((int) (offY * damp));\r\n                    return true;\r\n                }\r\n\r\n                if (isBodyTop && offY < 0) {\r\n                    setMarginTop((int) (offY * damp));\r\n                    return true;\r\n                }\r\n                break;\r\n              ...\r\n    }\r\n这样bodyView 就可以跟随手指动了，若需要一些阻尼效果可以添加系数damp，就是bodyView移动的距离等于手指滑动的距离乘以系数damp。4.临界点与回弹先写一个动画方法，该动画方法就是bodyView 从开始的高度移动到结束的高度。private ValueAnimator mAnim;\r\n   /**\r\n     * 收起或打开动画\r\n     *\r\n     * @param start 开始高度\r\n     * @param end   结束高度\r\n     * @param time  动画时间\r\n     */\r\n    public void startAnimator(int start, int end, long time) {\r\n\r\n        if (mAnim != null && mAnim.isRunning()) {\r\n            mAnim.cancel();\r\n        }\r\n        mAnim = ValueAnimator.ofInt(start, end);\r\n        mAnim.setDuration(time);\r\n        mAnim.setTarget(mBodyView);\r\n        mAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r\n            @Override\r\n            public void onAnimationUpdate(ValueAnimator animation) {\r\n                int currentValue = (Integer) animation.getAnimatedValue();\r\n                RelativeLayout.LayoutParams params = (LayoutParams) mBodyView.getLayoutParams();\r\n                params.topMargin = currentValue;\r\n                mBodyView.setLayoutParams(params);\r\n            }\r\n        });\r\n        mAnim.start();\r\n\r\n    }\r\n然后设置一个触发的临界点    private float closeOrOpen = 0.4f;//动画关闭还是打开的点（相对于头部高度的比例）\r\n触发时机例如手指抬起事件            case MotionEvent.ACTION_UP:\r\n            ...\r\n             if (mBodyView.getTop() < mHeadView.getHeight() * closeOrOpen) {\r\n                        startAnimator(mBodyView.getTop(), 0);//收起动画\r\n                    } else {\r\n                        startAnimator(mBodyView.getTop(), mHeadView.getMeasuredHeight());//打开动画\r\n\r\n                    }\r\n5.手势判断（惯性效果）添加手势判断会有更好的使用体验效果，方法如下    private GestureDetector mGestureDetector;\r\n\r\n    mGestureDetector = new GestureDetector(getContext(), new MoreGestureListener());\r\n\r\n class MoreGestureListener implements GestureDetector.OnGestureListener {\r\n\r\n        @Override\r\n        public boolean onDown(MotionEvent e) {\r\n            mIsHaveScrolled = false;\r\n            return false;\r\n        }\r\n\r\n        @Override\r\n        public void onShowPress(MotionEvent e) {\r\n\r\n        }\r\n\r\n        @Override\r\n        public boolean onSingleTapUp(MotionEvent e) {\r\n            return false;\r\n        }\r\n\r\n        @Override\r\n        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {\r\n            mIsHaveScrolled = true;\r\n            return false;\r\n        }\r\n\r\n        @Override\r\n        public void onLongPress(MotionEvent e) {\r\n\r\n        }\r\n\r\n        @Override\r\n        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {\r\n            //当头部显示并且向上fling时候关闭头部（惯性视觉）\r\n            if (mBodyView.getTop() > 0 && velocityY < 0) {\r\n                startAnimator(mBodyView.getTop(), 0);\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n在dispatchTouchEvent 方法里每个事件下面把事件传进去                mGestureDetector.onTouchEvent(ev);//为什么不放在最前面，因为会比关闭/打开动画先触发\r\n其他大概的雏形就是这样可以扩展其他功能如，三个小点或者震动、headView跟随bodyView 移动等附上用例地址https://github.com/collinWong/wx_drawer"}
{"title": "微信小程序自定义头部返回按钮及回到首页样式 ", "author": "Rolan", "pub_time": "2019-9-11 00:35", "content": "原文地址： www.ctoku.com/post/XqArOn…在进行小程序开发的过程中，经常遇到的一个问题就是，通过好友分享打开的小程序，去首页的入口太深，导致有部分用户流失，还有对返回按钮和返回地址进行特殊化处理，需要返回到指定位置，则可以通过自定义的方式进行处理。配置：通过配置 navigationStyle 对页面或者全局页面进行自定义头部思路首先我们指定自定义头部肯定是以组件的形式存在的； 我们自定义的同时需要保持右边胶囊位置一致，同时也需要保留页面标题 我们实现的效果如下图所示：实现首先我们通过wx.getMenuButtonBoundingClientRect() 获取右边胶囊的位置 使用wx.getSystemInfo 获取系统信息 这两组数据不是经常改变的所以我们在进入小程序的时候执行放到全局变量里面。this.globalData.headerBtnPosi = wx.getMenuButtonBoundingClientRect()\r\nwx.getSystemInfo({ // iphonex底部适配\r\n\tsuccess: res => {\r\n\t\tthat.globalData.systeminfo = res\r\n\t}\r\n})\r\n复制代码根据下图分析我们自定义的图标和右边胶囊位置一致 因此我们通过右边胶囊的位置定位左边自定义图标的位置 我们最初获取到的右边胶囊位置headerPosi：{\r\n\tbottom: 82\r\n\theight: 32\r\n\tleft: 278\r\n\tright: 365\r\n\ttop: 50\r\n\twidth: 87\r\n}\r\n复制代码获取到的状态栏高度为statusH = 44所以自定义胶囊距离最顶部的高度为 胶囊距离状态栏高度 - 状态栏高度customNav.top = headerPosi.top - statusH wxml部分<view class=\"custom_nav\" style=\"height:{{navbarHeight}}px;\">\r\n  <view class=\"custom_nav_box\" style=\"height:{{navbarHeight}}px;\">\r\n    <view class=\"custom_nav_bar\" style=\"top:{{statusBarHeight}}px; height:{{cusnavH}}px;\">\r\n      <view class=\"custom_nav_icon\"  wx:if=\"{{!navbarData.has_search}}\" style=\"height:{{navbarBtn.height - 2}}px; top:{{navbarBtn.top}}px; left:{{navbarBtn.right}}px; border-radius: {{navbarBtn.height / 2}}px\">\r\n        <view class=\"gobank\" style=\"height:{{navbarBtn.height - 10}}px;width:{{navbarBtn.height - 10}}px;\"></view>\r\n        <view class=\"home\" style=\"height:{{navbarBtn.height -10 }}px;width:{{navbarBtn.height - 10}}px;\"></view>\r\n      </view>\r\n      <view class=\"nav_title\" wx:if=\"{{!navbarData.has_search}}\" style=\"height:{{cusnavH}}px; line-height:{{cusnavH}}px;\">组件目录</view>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码wxss部分.custom_nav {\r\n  width: 100%;\r\n  background: #fff;\r\n}\r\n\r\n.custom_nav_box {\r\n  position: fixed;\r\n  width: 100%;\r\n  background: #fff;\r\n}\r\n.custom_nav_bar{\r\n  position: relative;\r\n}\r\n.custom_nav_box .nav_title {\r\n  font-size: 34rpx;\r\n  color: #000;\r\n  text-align: center;\r\n  position: absolute;\r\n  max-width: 360rpx;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  font-weight: 600;\r\n}\r\n\r\n.custom_nav_box .custom_nav_icon {\r\n  position: absolute;\r\n  border: .5rpx solid rgba(0, 0, 0, .1);\r\n  border-radius: 50%;\r\n  display: flex;\r\n  padding: 0 10rpx\r\n}\r\n.custom_nav_icon .gobank {\r\n  background: url('https://www.easyicon.net/api/resizeApi.php?id=1225467&size=128') no-repeat center center;\r\n  background-size: 60%;\r\n  padding:0 5px;\r\n  margin: 4px 0;\r\n}\r\n.custom_nav_icon .home {\r\n  background: url('https://www.easyicon.net/api/resizeApi.php?id=1223065&size=128') no-repeat center center;\r\n  background-size: 60%;\r\n  padding:0 5px;\r\n  margin: 4px 0;\r\n  border-left: 1px solid rgba(0, 0, 0, .1)\r\n}\r\n复制代码js部分const app = getApp();\r\nComponent({\r\n  properties: {\r\n    navbarData: { // navbarData 由父页面传递的数据\r\n      type: Object,\r\n      value: {\r\n        gobank: true,\r\n        gohome: true,\r\n        has_search: false,\r\n      },\r\n      observer: function (newVal, oldVal) { \r\n      }\r\n    }\r\n  },\r\n  data: {\r\n    haveBack: true, // 是否有返回按钮，true 有 false 没有 若从分享页进入则没有返回按钮\r\n    statusBarHeight: 0, // 状态栏高度\r\n    navbarHeight: 0, // 顶部导航栏高度\r\n    navbarBtn: { // 胶囊位置信息\r\n      height: 0,\r\n      width: 0,\r\n      top: 0,\r\n      bottom: 0,\r\n      right: 0\r\n    },\r\n    cusnavH: 0,\r\n    searchW: 0, //搜索框宽度\r\n  },\r\n  // 微信7.0.0支持wx.getMenuButtonBoundingClientRect()获得胶囊按钮高度\r\n  attached: function () {\r\n    let statusBarHeight = app.globalData.systeminfo.statusBarHeight // 状态栏高度\r\n    let headerPosi = app.globalData.headerBtnPosi // 胶囊位置信息\r\n    console.log(statusBarHeight)\r\n    console.log(headerPosi)\r\n    let btnPosi = { // 胶囊实际位置，坐标信息不是左上角原点\r\n      height: headerPosi.height,\r\n      width: headerPosi.width,\r\n      top: headerPosi.top - statusBarHeight, // 胶囊top - 状态栏高度\r\n      bottom: headerPosi.bottom - headerPosi.height - statusBarHeight, // 胶囊bottom - 胶囊height - 状态栏height （胶囊实际bottom 为距离导航栏底部的长度）\r\n      right: app.globalData.systeminfo.screenWidth - headerPosi.right // 屏幕宽度 - 胶囊right\r\n    }\r\n    let haveBack;\r\n    if (getCurrentPages().length === 1) { // 当只有一个页面时，并且是从分享页进入\r\n      haveBack = false;\r\n    } else {\r\n      haveBack = true;\r\n    }\r\n    var cusnavH = btnPosi.height + btnPosi.top + btnPosi.bottom // 导航高度\r\n    var searchW = app.globalData.systeminfo.screenWidth - headerPosi.width - btnPosi.right * 2 - 30\r\n    console.log(searchW, app.globalData.systeminfo.screenWidth, headerPosi.width)\r\n    this.setData({\r\n      haveBack: haveBack, // 获取是否是通过分享进入的小程序\r\n      statusBarHeight: statusBarHeight,\r\n      navbarHeight: headerPosi.bottom + btnPosi.bottom, // 胶囊bottom + 胶囊实际bottom\r\n      navbarBtn: btnPosi,\r\n      cusnavH: cusnavH,\r\n      searchW: searchW\r\n    })\r\n  },\r\n  methods: {\r\n    _goBack: function () {\r\n      wx.navigateBack({\r\n        delta: 1\r\n      });\r\n    },\r\n    _goHome: function () {\r\n      wx.navigateTo({\r\n        url: '/pages/index/index',\r\n      });\r\n    }\r\n  }\r\n})\r\n复制代码"}
{"title": "小程序Ticker倒计时最佳实践 ", "author": "Rolan", "pub_time": "2019-9-20 00:22", "content": "Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址\r\n一. 什么是ticker？\r\ntick本来的意思是钟表的滴答声。Ticker类为游戏开发提供了一个主要的定时类。它主要的目的就是把stage渲染的工作集中起来，也就是说定时调用stage.update()这个方法。Ticker设置的频率也就是游戏的帧数了。\r\n我们把Ticker应用到小程序开发中，频率设置为1s。\r\nTicker的使用如下，初始化Ticker对象，添加侦听tick事件，启动ticker。\r\nconst ticker = new Ticker()\r\n// 参数为Object类型，必须有tick方法\r\nticker.addTick({\r\n    tick: (delta) => {\r\n    \t...\r\n    }\r\n})\r\nticker.start()\r\n复制代码这里不细说Ticker的实现，详情请看Ticker.js源码。\r\n二. 小程序倒计时的烦恼\r\n假如我们都在页面onShow设置setTimeout。\r\n1、onHide取消clearTimeout。假如首页有个倒计时在倒数100S，进入二级页面后，触发onHide，取消clearTimeout。过了10S返回首页，又重新启动setTimeout，那么应该是从100S还是90S开始倒数呢？\r\n那肯定是90S开始呀，可是setTimeout都停了，怎么记录到过去了10S呢？\r\n2、onUnload 取消clearTimeout。onHide之后，其实倒计时还在后台执行，setData也在重新渲染。如果有多级页面，无疑是非常浪费性能。\r\n三. Ticker实现countdown解决方案\r\n在Page的生命周期函数中，添加tick处理。\r\nimport ticker from './utils/ticker'\r\n\r\nPage({\r\n\tcountdown: 100,\r\n\t// 添加当前页面对象到ticker队列\r\n\tonLoad () {\r\n\t\tticker.addTick(this)\r\n\t},\r\n\t// 恢复当前页面对象tick\r\n\tonShow () {\r\n\t\tticker.resume(this)\r\n\t},\r\n\t// 暂停当前页面对象tick\r\n\tonHide () {\r\n\t\tticker.pause(this)\r\n\t},\r\n\t// 移除当前页面对象tick从ticker队列\r\n\tonUnload () {\r\n\t\tticker.removeTick(this)\r\n\t},\r\n\t// 需要计时的页面添加tick方法\r\n\ttick (delta) {\r\n\t\tcountdown -= delta\r\n\t\tthis.setData({\r\n\t\t\tcountdown\r\n\t\t})\r\n\t}\r\n})\r\n复制代码统一处理Page的tick\r\n每个需要用ticker的页面，都需要在各自的生命周期函数里面添加对应的操作。重复的工作交给代码，来重写Page构造函数。interceptor.js\r\n// 生命周期函数集合\r\nconst Interceptor = {\r\n    onLoad: [], onShow: [], onHide: [], onUnload: []\r\n}\r\n\r\n/**\r\n * 组合函数，依次执行\r\n * @param  {...Function} args 被组合的函数\r\n */\r\nfunction compose(interceptorList, sourceMethod){\r\n    return function () {\r\n        [...interceptorList, sourceMethod].forEach( fn => {\r\n            typeof fn === 'function' && fn.call(this, arguments)\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * 小程序Page方法的替代实现\r\n */\r\nconst wxPage = Page\r\n\r\n/**\r\n * 重写Page构造函数\r\n * @param pageObject - 传入的页面对象\r\n */\r\nPage = function (pageObject) {\r\n    Object.keys(Interceptor).forEach((keyName) => {\r\n        const sourceMethod = pageObject[keyName]\r\n        pageObject[keyName] = compose(Interceptor[keyName], sourceMethod)\r\n    })\r\n    return wxPage(pageObject)\r\n}\r\n\r\n/**\r\n * 增加对Page生命周期方法的拦截器\r\n * @param methodName\r\n * @param handler\r\n */\r\nexport function addInterceptor (methodName, handler) {\r\n    Interceptor[methodName] && Interceptor[methodName].push(handler)\r\n}\r\n复制代码小程序入口文件app.js，给页面生命周期函数全局注入ticker对应的方法。\r\nimport * as Interceptor from './utils/interceptor'\r\nimport ticker from './utils/ticker'\r\n\r\nInterceptor.addInterceptor('onLoad', function () {\r\n    ticker.addTick(this)\r\n})\r\n\r\nInterceptor.addInterceptor('onShow', function () {\r\n    ticker.resume(this)\r\n})\r\n\r\nInterceptor.addInterceptor('onHide', function () {\r\n    ticker.pause(this)\r\n})\r\n\r\nInterceptor.addInterceptor('onUnload', function () {\r\n    ticker.removeTick(this)\r\n})\r\n\r\nApp({\r\n    onLaunch () {\r\n        \r\n    }\r\n})\r\n复制代码页面只需要添加tick方法，利用delta计算倒数时间，无需操作ticker逻辑。page.js：\r\nimport formatTime from '../../utils/formatTime'\r\nPage({\r\n    countdown: 1000,\r\n    data: {\r\n        countdownStr: ''\r\n    },\r\n    tick (delta) {\r\n        console.log('index tick')\r\n        let countdownStr = formatTime(this.countdown -= delta)\r\n        this.setData({\r\n            countdownStr\r\n        })\r\n    }\r\n});\r\n复制代码done\r\n\r\nGithub: github.com/songdy/todo…"}
{"title": "两天撸两个天气小程序 ", "author": "Rolan", "pub_time": "2019-9-20 00:25", "content": "经过最近两年多的发展，小程序的地位也逐渐越来越高了，各个平台前赴后继做了自家的小程序平台，随着市场的需求越来愈多，我们开发各平台的小程序的激情也随（被）之（逼）高（无）涨（奈）。选择uniapp来开发。uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。即使不跨端，uni-app同时也是更好的小程序开发框架。来自官方。喜欢taro， wepy，mpvue的朋友也莫喷我，大家各有所好，大家开心就好。【智行天气】小程序效果图1、获取位置信息在定位功能中，本程序用到腾讯地图的api 以及 腾讯天气的api接口，需要到官网中注册开发者账号，通过注册后得到的appKey来请求我们需要的数据，详细注册步骤请自行度娘由于需要用到定位功能，uniapp的getLocation方法获取到的是当前位置的坐标，然后对应腾讯地图具体城市uni.getLocation({\r\n    // #ifdef MP-WEIXIN\r\n    type: 'wgs84',\r\n    // #endif\r\n    async success (res) {\r\n        const {latitude, longitude} = res\r\n        const result = await that.ajax({url: 'https://apis.map.qq.com/ws/geocoder/v1', data: {\r\n            location: `${latitude},${longitude}`,\r\n            key: ''\r\n        }})\r\n        let {province, city, district} = result.result.address_component\r\n        that.getData(province, city, district)\r\n    },\r\n    fail(){\r\n        uni.showModal({\r\n          content: '检测到您没打开定位权限，是否去设置打开？',\r\n          confirmText: \"确认\",\r\n          cancelText: \"取消\",\r\n          success: function (res) {\r\n            if (res.confirm) {\r\n              // #ifdef MP-WEIXIN\r\n              wx.openSetting({\r\n                success: (res) => {\r\n                    that.getIn()\r\n                }\r\n              })\r\n              // #endif\r\n              // #ifdef MP-ALIPAY\r\n              my.openSetting({\r\n                 success: (res) => {\r\n                    that.getIn()\r\n                 }\r\n              })\r\n              // #endif\r\n            }\r\n          }\r\n        });\r\n    }\r\n})2、查询天气得到城市名后，再用城市名查询天气的接口，得到未来几天的天气预报。天气接口使用腾讯天气接口api。在小程序中使用前，要在小程序设置界面，开发设置中添加request合法域名。methods: {\r\n    async getData(province, city, district){\r\n        const that = this\r\n        const data = await that.ajax({url: 'https://wis.qq.com/weather/common', data: {\r\n            source: 'xw',\r\n            weather_type: 'observe|alarm|air|forecast_1h|forecast_24h|index|limit|tips|rise',\r\n            province: province,\r\n            city: city,\r\n            county: district\r\n        }})\r\n        that.region = [province, city, district]\r\n        if(data.status != 200){\r\n            uni.showToast({\r\n                title: result.message,\r\n                icon: 'none'\r\n            });\r\n            return false;\r\n        }\r\n        if(!data.data.air.aqi_name){\r\n            uni.showToast({\r\n                title: '暂无该地区的天气信息',\r\n                icon: 'none'\r\n            });\r\n            return false;\r\n        }\r\n        that.data = data.data\r\n    }\r\n}3、小程序界面由于没有什么审美，缺乏想象力，参考腾讯天气的界面来做的。功能十分简单，查看当前地区的天气和切换其他地区的天气，查看最近24小时的天气情况以及最近6天的天气情况，展示今天的农历时间。4、插件使用想快速完成小程序的搭建，里面的折线图采用的 uchart.js ,因为可以兼容支付宝小程序和微信小程序，农历查询也是采用的插件 calendar.js折线图在支付宝小程序中会有模糊的问题，需要做兼容处理<template>\r\n<!-- #ifdef MP-ALIPAY -->\r\n<canvas canvas-id=\"canvas\" id=\"canvas\" width=\"750\" height=\"240\" style=\"width:750rpx;height:240rpx;\" class=\"canvas\">\r\n</canvas>\r\n<!-- #endif -->\r\n<!-- #ifdef MP-WEIXIN -->\r\n<canvas canvas-id=\"canvas\" id=\"canvas\" class=\"canvas\">\r\n</canvas>\r\n<!-- #endif -->\r\n</template>\r\n\r\n<script>\r\nvar wxCharts = require('../../utils/chart.js');\r\nlineChart = new wxCharts({\r\n    $this: this,\r\n    canvasId: 'canvas',\r\n    type: 'line',\r\n    categories: ['', '', '', '', '' ,''],\r\n    colors: ['#ffad35', '#4fc3f7'],\r\n    background: '#fff',\r\n    animation: true,\r\n    series: [{\r\n        name: '',\r\n        data: that.max,\r\n        format: function (val, name) {\r\n            return val + '°';\r\n        }\r\n    }, {\r\n        name: '',\r\n        data: that.min,\r\n        format: function (val, name) {\r\n            return val + '°';\r\n        }\r\n    }],\r\n    xAxis: {\r\n        disableGrid: true,\r\n        disabled: true,\r\n        axisLine: false\r\n    },\r\n    yAxis: {\r\n        max: Math.max.apply(Math, that.max) * 1 + 0.1,\r\n        disabled: true,\r\n        disableGrid: true,\r\n    },\r\n    legend:{ \r\n        show: false \r\n    },\r\n    // #ifdef MP-ALIPAY\r\n    pixelRatio: that.pixelRatio, // 解决支付宝模糊问题\r\n    // #endif\r\n    width: that.cWidth,\r\n    height: that.cHeight\r\n});\r\n</script>微信小程序有城市选择组件，支付宝的没有可以直接使用的城市组件，uniapp官方介绍:支持安装 mpvue 组件，但npm方式不支持小程序自定义组件（如 wxml格式的vant-weapp）,找到一款支付宝可以使用的城市插件： mpvue-citypicker ,城市选择组件<template>\r\n    <view class=\"txt-location\" @tap=\"showCityPicker\">\r\n        <view class=\"icon\"></view>\r\n        <block v-if=\"region.length\">{{region[0]}}{{region[1]}}{{region[2]}}</block>\r\n        <block v-else>选择城市</block>\r\n        <!-- #ifdef MP-WEIXIN -->\r\n        <picker class=\"city\" mode=\"region\" @change=\"handleChange\" :value=\"region\">\r\n            <view class=\"picker\">\r\n                当前选择：{{region[0]}}，{{region[1]}}，{{region[2]}}\r\n            </view>\r\n         </picker>\r\n        <!-- #endif -->\r\n    </view>\r\n    <mpvue-city-picker ref=\"mpvueCityPicker\" :pickerValueDefault=\"pickerValueDefault\" @onConfirm=\"onConfirm\"></mpvue-city-picker>\r\n</template>\r\n\r\n<script>\r\nimport mpvueCityPicker from 'mpvue-citypicker';\r\nexport default {\r\n  data() {\r\n    return {\r\n      region: [],\r\n      pickerValueDefault: [0, 0, 1]\r\n    };\r\n  },\r\n  components: {\r\n    mpvueCityPicker\r\n  },\r\n  methods: {\r\n    showCityPicker() {\r\n        // #ifdef MP-ALIPAY\r\n        this.$refs.mpvueCityPicker.show()\r\n        // #endif\r\n    },\r\n    onConfirm(e) {\r\n        if(e.label){\r\n            this.region = e.label.split('-')\r\n            this.getData(this.region[0], this.region[1], this.region[2])\r\n        }\r\n    },\r\n    handleChange(e) {\r\n        this.region = e.detail.value\r\n        this.getData(this.region[0], this.region[1], this.region[2])\r\n    }\r\n  }\r\n};\r\n</script>总结界面很快就搭建完成，提供了较为完整的组件以及各种API2天气接口查询的腾讯天气的，需要做过滤处理才能使用，某些地区查询天气没有返回需要友情提示处理第一次做支付宝小程序遇到的坑不少，例如图表模糊，城市选择组件需要自己做，消息提示框uni.showToast使用时需要兼容，支付宝不能使用duration字段，获取位置uni.getLocation使用时也需要兼容，支付宝不能使用type字段等。程序的提交审核比较快，我的大概是用了一天的时间就申请好了。但是支付宝审核比较慢后续将代码放到 https://github.com/galan99"}
{"title": "微信小程序wxparse解析iframe中视频办法 ", "author": "Rolan", "pub_time": "2019-9-23 00:08", "content": "微信小程序里面，对于富文本标签，我们通常使用wxparse这个插件来进行解析，可以说非常的方便。但是今天在使用的时候，遇到了iframe中是视频地址的问题。如果是标准的视频标签。wxparse是可以正常解析的，但是如果是下面这样的形式的话，小程序是无法显示视频的。<iframe class=\"ql-video\" frameborder=\"0\" allowfullscreen=\"true\" src=\"\t” _src=”https://lj-1251274653.cos.ap-chengdu.myqcloud.com/ljfl.mp4\">”>https://lj-1251274653.cos.ap-chengdu.myqcloud.com/ljfl.mp4\">问题的原因就是wxparse没有对iframe标签进行解析匹配，我们需要自己修改wxparse来使它可以解析iframe标签。解决过程如下：修改wxparse中的html2json.js文件，添加对iframe标签的解析。function html2json(html, bindName) {\r\n   \r\n    HTMLParser(html, {\r\n        start: function (tag, attrs, unary) {\r\n           ...\r\n            //对img添加额外数据\r\n            if (node.tag === 'img') {\r\n                node.imgIndex = results.images.length;\r\n                var imgUrl = node.attr.src;\r\n                if(!imgUrl) {\r\n                  return\r\n                }\r\n                if (imgUrl[0] == '') {\r\n                    imgUrl.splice(0, 1);\r\n                }\r\n                imgUrl = wxDiscode.urlToHttpUrl(imgUrl, __placeImgeUrlHttps);\r\n                node.attr.src = imgUrl;\r\n                node.from = bindName;\r\n                results.images.push(node);\r\n                results.imageUrls.push(imgUrl);\r\n            }\r\n           \r\n            // 处理iframe的地址\r\n            if(node.tag === 'iframe') {\r\n                \r\n                node.src= node.attr.src;\r\n            }\r\n        .....};2.\t在wxParse.wxml添加iframe视频模板<template name=\"wxPraseIframe\">\r\n<video id=\"myVideo\" src=\"{{item.src}}\"  enable-danmu danmu-btn controls></video>\r\n</template>3.在wxParse.wxml中，对循环模板添加处理。<!--循环模版-->\r\n<template name=\"wxParse0\">\r\n<!--<template is=\"wxParse1\" data=\"{{item}}\" />-->\r\n<!--判断是否是标签节点-->\r\n<block wx:if=\"{{item.node == 'element'}}\">\r\n<block wx:if=\"{{item.tag == 'button'}}\">\r\n<button type=\"default\" size=\"mini\">\r\n<block wx:for=\"{{item.nodes}}\" wx:for-item=\"item\" wx:key=\"\">\r\n<template is=\"wxParse1\" data=\"{{item}}\" />\r\n</block>\r\n</button>\r\n</block>\r\n<!--li类型-->\r\n<block wx:elif=\"{{item.tag == 'li'}}\">\r\n<view class=\"{{item.classStr}} wxParse-li\" style=\"{{item.styleStr}}\">\r\n<view class=\"{{item.classStr}} wxParse-li-inner\">\r\n<view class=\"{{item.classStr}} wxParse-li-text\">\r\n<view class=\"{{item.classStr}} wxParse-li-circle\"></view>\r\n</view>\r\n<view class=\"{{item.classStr}} wxParse-li-text\">\r\n<block wx:for=\"{{item.nodes}}\" wx:for-item=\"item\" wx:key=\"\">\r\n<template is=\"wxParse1\" data=\"{{item}}\" />\r\n</block>\r\n</view>\r\n</view>\r\n</view>\r\n</block>\r\n<!--video类型-->\r\n<block wx:elif=\"{{item.tag == 'video'}}\">\r\n<template is=\"wxParseVideo\" data=\"{{item}}\" />\r\n</block>\r\n<!--iframe插件（这个是我们添加的）-->\r\n<block wx:elif=\"{{item.tag == 'iframe'}}\">\r\n<template is=\"wxPraseIframe\" data=\"{{item}}\" />\r\n</block>需要注意的是，循环模板可能会有很多个，比如<template name=\"wxParse1\"><template name=\"wxParse2\">我们最好都添加上iframe的模板解析"}
{"title": "叮点跑腿小程序部署教程 ", "author": "Rolan", "pub_time": "2019-9-23 00:13", "content": "|--server //服务端目录\r\n|--client //后台客户端目录\r\n|--wxapp //微信小程序项目目录\r\n|--ddrun.sql //数据库文件\r\n复制代码准备工作1.微信小程序账号 (需要企业版+微信认证)2.微信商户号 需要支付证书 用做退款功能3.如需公众号提醒功能 需要认证过的服务号4.阿里云短信相关的东西5.腾讯地图API key拥有以上全部内容，即可进行安装部署操作。一、安装环境方案一、自行手动安装git、nodejs、mysql、pm2管理器方案二、安装“宝塔面板”，然后进入\"软件管理\"安装nginx、pm2管理器(自带nodejs)、mysql。若安装过程中出现报错问题，请检查软件版本问题。请参考作者的服务器环境：mysql5.5 | node v8.9.1二、部署服务端请先将数据库文件导入到数据库。数据库编码为“utf8mb4”1、修改pm2.json文件文件目录：server/pm2.jsonname为项目名，cwd为项目再服务器的根目录，其他无需更改。{\r\n  \"apps\": [{\r\n    \"name\": \"runing_demo\",   //项目名称\r\n    \"script\": \"production.js\",\r\n    \"cwd\": \"/www/wwwroot/nodeproject/runing_demo\",   //服务器项目根目录\r\n    \"exec_mode\": \"fork\",\r\n    \"max_memory_restart\": \"1G\",\r\n    \"autorestart\": true,\r\n    \"node_args\": [],\r\n    \"args\": [],\r\n    \"env\": {\r\n    }\r\n  }]\r\n}\r\n复制代码2、修改配置文件adapter.js文件目录：server/src/config/adapter.js...省略以上配置...\r\n/**\r\n * model adapter config\r\n * @type {Object}\r\n */\r\nexports.model = {\r\n  type: 'mysql',\r\n  common: {\r\n    logConnect: isDev,\r\n    logSql: isDev,\r\n    logger: msg => think.logger.info(msg)\r\n  },\r\n  mysql: {\r\n    handle: mysql,\r\n    database: 'ddrun_demo',  //数据库名称\r\n    prefix: 'erd_',  \r\n    encoding: 'utf8',  \r\n    host: '127.0.0.1',  //地址\r\n    port: '',    //默认3306\r\n    user: 'root', //用户名\r\n    password: 'root', //密码\r\n    dateStrings: true\r\n  }\r\n};\r\n...省略以下配置...\r\n复制代码3、安装依赖#1.进入项目目录\r\n$ cd server \r\n#2.安装依赖\r\n$ npm install\r\n复制代码4、运行项目#线上运行\r\n$ npm run compile\r\n$ pm2 start pm2.json\r\n\r\n#本地运行\r\n$ node development.js\r\n复制代码项目默认端扣为8360。服务端默认访问地址为：http://x.x.x.x:8360/建议使用nginx做域名反向代理三、部署后台客户端1、修改apiurl.js文件文件目录：client/public/js/apiurl.jsexport default 'http://x.x.x.x:8360/' //改为服务端访问地址\r\n复制代码2、安装依赖#1.进入项目目录\r\n$ cd client\r\n#2.安装依赖\r\n$ npm install\r\n复制代码3、运行项目#线上运行\r\n$ pm2 start npm -- run serve\r\n\r\n#本地运行\r\n$ npm run serve\r\n复制代码项目默认端扣为8361。服务端默认访问地址为：http://x.x.x.x:8361/默认登录账号：admin 密码：qwe147258建议使用nginx做域名反向代理开源地址：https://gitee.com/yaozy717/ddrun"}
{"title": "微信小程序常用的3种提示弹窗 ", "author": "Rolan", "pub_time": "2019-9-23 00:45", "content": "1. 表示操作成功，文字上方会显示一个表示操作成功的图标。wx.showToast({\r\n    title: '操作成功！',  // 标题\r\n    icon: 'success',   // 图标类型，默认success\r\n    duration: 1500   // 提示窗停留时间，默认1500ms\r\n})\r\n2.表示加载中，显示为加载中图标。wx.showToast({\r\n    title: '加载中...',\r\n    icon: 'loading',\r\n    duration: 1500\r\n})\r\n3.不显示图标，一般用作提示。wx.showToast({\r\n    title: '该功能未上线！',\r\n    icon: 'none',\r\n    duration: 1500\r\n})\r\n以上3种弹窗均使用wx.showToast接口，调用后会根据设定的duration停留一定时间。此外，表示加载中的弹窗还可以使用wx.showLoading接口，但调用该接口时弹窗并不会自动消失，而是需要手动调用wx.hideLoading接口使弹窗消失。// 开始加载数据\r\nwx.showLoading({\r\n  title: '加载中',\r\n})\r\n\r\n\r\n// 数据加载中... \r\n// 数据加载中...\r\n\r\n\r\n// 数据加载完成，隐藏弹窗\r\nwx.hideLoading()\r\n完。"}
{"title": "让你的小程序支持多环境打包 ", "author": "Rolan", "pub_time": "2019-9-24 00:13", "content": "开发小程序时，最麻烦的事情莫过于在上线前需要反复切换测试和正式环境接口地址。本文介绍一种小程序工程化改造的思路，基于这个我们能够实现小程序自动根据多环境打包。参考项目https://github.com/mecoepcoo/miniprogram-boilerplate准备工作阅读本文，你需要有对以下内容的基本认知：gulp环境变量工程化改造原生的小程序只有一个简单的启动脚手架，不支持less、sass等样式预处理器，对npm的支持也不是太好，我们自己做一个简单的构建工具，来增强小程序的功能。本节起一个抛砖引玉的作用，基于这个思路，可以改造出更多更强大的功能。目录结构dist 输出/发布目录，在微信开发者工具中打开这个目录project.config.json 配置文件，这个文件与src中的配置无关srcminiprogramassets 静态资源目录，放图片之类的东西components 组件目录pages 小程序页面目录app.js 小程序入口app.json 小程序全局配置app.lesssitemap.jsonproject.config.json 配置文件样板，这个文件不会被编译到dist中安装gulp本文写作时，gulp的版本是\tv4 ，api与之前的版本有一些变化。创建一个空目录后，先安装依赖：$ npm init\r\n$ npm i -D gulp gulp-plumber gulp-rename del在根目录新建\tgulpfile.js 文件，引入依赖：const gulp = require('gulp');\r\nconst plumber = require('gulp-plumber'); // 发生错误时阻止gulp退出并输出日志\r\nconst rename = require('gulp-rename'); // 输出时重命名文件\r\nconst del = require('del');支持less用less等预处理器书写样式，可能会更方便，安装依赖：$ npm i -D gulp-less gulp-cssnano假设我们的源码放在\t/src/miniprogram 目录下，输出到\t/dist 目录下。现在让gulp支持less编译：const less = require('gulp-less'); // 处理less\r\nconst cssnano = require('gulp-cssnano'); // 压缩代码\r\n// 编译样式\r\ngulp.task('build:style', () => {\r\n  return gulp.src([ // 千万不要漏掉return，否则gulp不知道这个任务何时完成\r\n    'src/miniprogram/pages/**/*.less', \r\n    'src/miniprogram/components/**/*.less',\r\n    'src/miniprogram/spreadpack/**/*.less',\r\n    'src/miniprogram/app.less'\r\n  ], {base: 'src/miniprogram'})\r\n    .pipe(plumber())\r\n    .pipe(less())\r\n    .pipe(\r\n      cssnano({\r\n        zindex: false,\r\n        autoprefixer: false,\r\n        discardComments: { removeAll: true }\r\n      })\r\n    )\r\n    .pipe(\r\n      rename(path => {\r\n        path.extname = '.wxss'; // 我们用less做后缀名，但小程序只支持wxss，所以需要修改输出的后缀\r\n      })\r\n    )\r\n    .pipe(gulp.dest('dist')); // 写入到dist文件夹中\r\n});处理脚本、模板和配置文件本文只做简单的思路介绍，所以我们还是按照原来的方法编写小程序的js和模板。这里只是把js，wxml和json复制到输出目录：// 编译示例\r\ngulp.task('build:main', gulp.series('build:style', () => {\r\n  return gulp.src([\r\n    'src/miniprogram/**/*',\r\n    '!src/miniprogram/**/*.less', // 排除less后缀文件\r\n    '!src/project.config.json', // 配置文件不写入到dist文件夹，开发时需手动拷贝到dist文件夹中 !!!\r\n  ], {base: 'src/miniprogram', allowEmpty: true})\r\n    .pipe(plumber())\r\n    .pipe(gulp.dest('dist'));\r\n}));清理输出目录在发布前，我们需要删除掉多余的文件，这里新增一个工作流用来清理输出目录：gulp.task('clean', cb => {\r\n  return del([\r\n    'dist/**/*',\r\n    '!dist/project.config.json'\r\n  ], cb);\r\n});配置开发环境启动命令和构建命令最后我们补全功能，首先增加一个开发环境启动配置：gulp.task('build', gulp.series('build:main'));\r\n// 监听文件(若文件修改则执行相关的任务)\r\nfunction watch() {\r\n  let watcher = gulp.watch('src/**', cb => cb());\r\n  watcher.on('all', (event, path, stats) => {\r\n    console.log('File ' + path + ' was ' + event + ', running tasks...');\r\n  });\r\n  return watcher;\r\n}\r\n\r\ngulp.task('default', gulp.series(watch));在\tpackage.json 中增加脚本：\"scripts\": {\r\n  \"start\": \"npm run clean && npm run build\",\r\n  \"dev\": \"gulp\",\r\n  \"build\": \"gulp build\",\r\n  \"watch\": \"gulp watch\",\r\n  \"clean\": \"gulp clean\",\r\n}现在执行\tnpm start 或者\tnpm run dev ，用小程序开发工具打开dist目录，就能看到效果了。注入环境变量有了gulp，一切关于构建的问题都简单了。使用\tgulp-preprocess 来支持环境变量。gulp-preprocess的用法见\t官方文档 。安装依赖：$ npm i -D cross-env gulp-preprocess修改构建配置由于操作系统之间设置环境变量命令的差异，引入\tcross-env 来解决，先修改\tpackage.json：\"scripts\": {\r\n  \"start\": \"cross-env NODE_ENV=prod npm run clean && npm run build\",\r\n  \"dev\": \"cross-env NODE_ENV=dev gulp\",\r\n  \"build\": \"cross-env NODE_ENV=prod gulp build\",\r\n  \"watch\": \"cross-env NODE_ENV=dev gulp watch\",\r\n  \"clean\": \"gulp clean\",\r\n}这里增加了一个名为\tNODE_ENV 的环境变量，并设置了\tdev 和\tprod 两个值，这样开发时会取dev变量，打包发布时会取prod变量。然后增加gulp配置：const preprocess = require('gulp-preprocess'); // 注入环境变量\r\n\r\ngulp.task('build:main', gulp.series('build:style', () => {\r\n  return gulp.src([\r\n    'src/miniprogram/**/*',\r\n    '!src/miniprogram/assets/**/*', // 新增配置在这里\r\n    '!src/miniprogram/**/*.less',\r\n    '!src/project.config.json',\r\n  ], {base: 'src/miniprogram', allowEmpty: true})\r\n    .pipe(plumber())\r\n    .pipe(preprocess()) // 新增配置在这里\r\n    .pipe(gulp.dest('dist'));\r\n}));\r\n\r\n// 由于preprocess这个插件会影响静态资源，所以需要把静态资源的打包拿出去\r\n/* 处理静态资源 */\r\ngulp.task('build:assets', () => {\r\n  return gulp.src([\r\n    \"src/miniprogram/assets/**/*\"\r\n  ], { base: 'src/miniprogram', allowEmpty: true })\r\n    .pipe(plumber())\r\n    .pipe(gulp.dest('dist'));\r\n});\r\n\r\n// 修改构建配置\r\ngulp.task('build', gulp.parallel('build:main', 'build:assets'));\r\nfunction watch() {\r\n  let watcher = gulp.watch('src/**', gulp.parallel('build:main', 'build:assets'), cb => cb());\r\n  watcher.on('all', (event, path, stats) => {\r\n    console.log('File ' + path + ' was ' + event + ', running tasks...');\r\n  });\r\n  return watcher;\r\n}代码示例用这种方法注入环境变量：let env = '/* @echo NODE_ENV */';\r\nlet apiRoot = '';\r\nswitch (env) {\r\n  case 'dev':\r\n    apiRoot = 'http://dev-api.tianzhen.tech';\r\n    break;\r\n  case 'prod':\r\n    apiRoot = 'http://api.tianzhen.tech';\r\n    break;\r\n}写一个demo，运行\tnpm start 试试吧！"}
{"title": "微信小程序--GET请求案例&文件上传和相册API&配置https ", "author": "Rolan", "pub_time": "2019-9-24 00:19", "content": "一、信息流小程序-GET请求案例1.1服务端接口开发一定要养成接口的意识，前端单打独斗出不来任何效果，必须有接口配合，写一个带有分页、关键词查询的接口：分页接口：http://127.0.0.1:3000/info?page=1查询接口：http://127.0.0.1:3000/search?word=李详情接口：http://127.0.0.1:3000/xiangqing?id=2const express = require(\"express\");\r\nconst app = express();\r\nconst url = require(\"url\");\r\nconst info = require(\"./info.js\");\r\napp.use(express.static(\"www\"));\r\n\r\n//显示分页的明星信息\r\napp.get(\"/info\" , (req,res) => {\r\n    const page = url.parse(req.url , true).query.page; //得到GET请求的page参数\r\n\r\n    //提供分页的接口\r\n    res.json({\r\n        \"arr\" : info.slice((page-1) * 4 , page * 4)\r\n    });\r\n});\r\n\r\n//关键字筛选查询\r\napp.get(\"/search\" , (req,res) => {\r\n    //得到用户的查询词\r\n    var word = url.parse(req.url , true).query.word;\r\n    //将字符串word变为正则表达式\r\n    var wordExp = new RegExp(word);\r\n    //遍历，筛选\r\n    res.json({\r\n        \"arr\" : info.filter(item => wordExp.test(item.name))\r\n    });\r\n});\r\n\r\n//某明星详情\r\napp.get(\"/xiangqing\" , (req,res) => {\r\n    //得到用户的查询的明星id\r\n    var id = url.parse(req.url , true).query.id;\r\n    //遍历，筛选\r\n    res.json({\r\n        \"xiangqing\" : info.filter(item => item.id == id)[0]\r\n    });\r\n})\r\napp.listen(3000);1.2小程序开发学习scrioll-view容器（可滚动视图区域）和发起请求。<scroll-view style=\"height:{{wH}}px;\" scroll-y bindscrolltolower=\"tolower\">\r\n    <view>乱起八早</view>\r\n    <view>乱起八早</view>\r\n    <view>乱起八早</view>\r\n.....\r\n</scroll-view>bindscrolltolower表示滚动到底部的事件，但这个盒子必须有高度。如果希望这个盒子的高度和窗口的高度一样，此时调用微信API，读取设备窗口高度。 app.js使用微信小程序的API得到屏幕的高度：//app.js\r\nApp({\r\n//用户首次打开小程序，触发 onLaunch函数（全局只触发一次）\r\n    onLaunch(){\r\n        var self = this;\r\n        //读取设备信息的API\r\n        wx.getSystemInfo({\r\n            success: function(res){\r\n                self.globalData.gWH = res.windowHeight; //获取窗口高度赋值给全局gWH对象\r\n            }\r\n        });\r\n    },\r\n    //全局数据\r\n    globalData : {\r\n        gWH : 0\r\n    }\r\n}); index.js中可以获取app.js的全局数据//每个页面可以无条件、不引包的，直接使用getApp()函数，表示调用小程序的主体\r\nvar app = getApp(); \r\n\r\nPage({\r\n    //当页面加载的时候\r\n    onLoad(){\r\n        //得到窗口的高度，globalData.gWH数据是从全局获取的\r\n        this.setData({\r\n            wH: app.globalData.gWH\r\n        });\r\n},\r\n//局部数据\r\n    data:{\r\n        wH: 0  //当前屏幕的高度\r\n    }\r\n    tolower(){\r\n        console.log(\"已经滚到底部了\")\r\n    }\r\n});1.3页面布局<!--index.wxml-->\r\n<view class=\"container\">\r\n<scroll-view style=\"height:{{wH}}px\" scroll-y bindscrolltolower=\"tolower\">\r\n　　<view class=\"mingxing\">\r\n            <view class=\"box\" wx:for=\"{{mingxing}}\" wx:key=\"{{index}}\">\r\n                <view class=\"left\">\r\n                    <image src=\"{{baseURL}}/images/{{item.pic}}\"></image>\r\n                    {{item.name}}\r\n                </view>\r\n                <view class=\"right\">\r\n                    {{item.b_info}}\r\n                </view>\r\n            </view>\r\n　　　　</view>\r\n    </scroll-view>\r\n</view> index.wxss 示例代码1.4请求分页数据-显示页面效果index.js中加载默认数据Page({\r\n    //当页面加载的时候\r\n    onLoad(){\r\n        //得到窗口的高度，是从全局来的\r\n        this.setData({\r\n            wH: appInstance.globalData.wH\r\n        });\r\n\r\n        //核心语句：请求服务器的数据，参数page表示第几页，当前第几页就请求第几页\r\n        var self = this;\r\n        wx.request({\r\n            //请求的地址\r\n            url: 'http://127.0.0.1:3000/info?page=' + this.data.page,\r\n            //成功的回调\r\n            success({data}){\r\n                self.setData({\r\n                    mingxing: [\r\n                        ...self.data.mingxing,\r\n                        ...data.arr\r\n                    ]\r\n                });\r\n            }\r\n        });\r\n    },\r\n    data : {\r\n        wH : 0, //当前屏幕的高度\r\n        mingxing: [], //信息流，现在是空的，等服务器返回\r\n        page : 1, //当前第几页，默认第一页\r\n    }\r\n});    index.js下拉请求更多var app = getApp(); \r\n\r\n//请求服务器上某一个页面的明星，参数page表示第几页\r\nfunction queryServer(page){\r\n//显示一个Toast，Toast就是提示文本，黑色背景的方框。\r\nwx.showToast({\r\n   title: '正在加载更多',\r\n   icon: 'loading',\r\n   duration: 2000000  //持续时间，非常长，因为靠回调函数给它隐藏。\r\n});\r\n    var self = this;\r\n    //核心语句，请求服务器的数据，分页请求，当前第几页就请求第几页\r\n    wx.request({\r\n        //请求的地址\r\n        url: this.data.baseURL + '/info?page=' + page,\r\n        //成功的回调\r\n        success({ data }){\r\n//隐藏Toast\r\n        wx.hideToast();\r\n            //看一下请求的数组长度是不是0，如果是0此时就改变信号量\r\n            if(data.arr.length == 0){\r\n                self.setData({\r\n                    isMore : false\r\n                });\r\n                return;\r\n            }\r\n            //如果不是0，改变值，追加数据\r\n            self.setData({\r\n                mingxing: [\r\n                    ...self.data.mingxing,\r\n                    ...data.arr\r\n                ]\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nPage({\r\n    onLoad(){\r\n        //指定queryServer函数的上下文，绑定好后，调用时上下文自动就是这里的this了\r\n//不需要queryServer.call(this)了。\r\n        queryServer = queryServer.bind(this); \r\n          \r\n        //得到窗口的高度，是从全局来的\r\n        this.setData({\r\n            wH: app.globalData.wH\r\n        });\r\n\r\n        //请求第1页的数据\r\n        queryServer(1);\r\n    },\r\n    data : {\r\n        wH : 0 ,\r\n        mingxing: [],\r\n        page : 1,\r\n        baseURL:\"http://127.0.0.1/3000\",  //基路径\r\n        isMore : true //是否还有更多？\r\n    },\r\n    tolower(){\r\n        if(this.data.isMore){\r\n            //页面数加1\r\n            this.setData({\r\n                page : this.data.page + 1\r\n            });\r\n            //下拉到底部请求更多\r\n            queryServer(this.data.page);\r\n        }\r\n    }\r\n});1.5关键字查询<!--index.wxml-->\r\n<view class=\"container\">\r\n    <view class=\"s_b\">\r\n        <input value=\"{{searchWord}}\" bindconfirm=\"doSearch\" class=\"s_box\"  type=\"text\" />\r\n        <button bindtap='clearSearch'>×</button>\r\n    </view>\r\n</view>index.wxss  示例代码 index.jsPage({\r\n    data : {\r\n        ...\r\n    },\r\n    tolower(){\r\n        ...\r\n    },\r\n    //执行查询\r\n    doSearch(event){\r\n        var self = this;\r\n        wx.request({\r\n            url: baseURL + \"/search?word=\" + event.detail.value ,\r\n            success({data}){\r\n                self.setData({\r\n                    mingxing : data.arr\r\n                });\r\n            }\r\n        });\r\n    },\r\n    //清空查询\r\n    clearSearch(){\r\n        this.setData({\r\n            searchWord : \"\",\r\n            mingxing : []\r\n        });\r\n        //重新请求当前的页码，显示全部\r\n        //循环请求，比如当前页码是2，此时就要请求2、1\r\n        for(let i = 1 ; i <= this.data.page ; i++){\r\n            queryServer(i);\r\n        }\r\n    }\r\n});1.6点击查看详情页index.wxml<view class=\"mingxing\">\r\n    <view class=\"box\" wx:for=\"{{mingxing}}\" data-mid=\"{{item.id}}\" bindtap='tapBox' >\r\n        .....\r\n    </view>\r\n</view> info.wxml详情页<view>\r\n    <view>{{name}}</view>\r\n    <image wx:if=\"{{pic != ''}}\" src=\"{{baseURL}}/images/{{pic}}\"></image>\r\n    <view>\r\n        {{info}}\r\n    </view>\r\n</view> index.jsPage({\r\n    //点击了一个小白框，进入详情页\r\n    tapBox(event){\r\n        //通过自己的data-mid标签，知道自己是谁\r\n        var mid = event.currentTarget.dataset.mid;\r\n        //带给下一个页面\r\n        wx.navigateTo({\r\n            //通过?传参给info页面，是微信小程序的语法约定，而并不是GET请求\r\n            url: '/pages/info/info?mid=' + mid\r\n        })\r\n    }\r\n}); info.js//基路径\r\nconst baseURL = \"http://127.0.0.1:3000\";\r\n\r\nPage({\r\n    onLoad({mid}){\r\n        var self = this;\r\n        wx.request({\r\n            url : baseURL + \"/xiangqing?id=\" + mid ,\r\n            success({data}){\r\n                self.setData({\r\n                    name: data.xiangqing[0].name,\r\n                    pic : data.xiangqing[0].pic,\r\n                    info: data.xiangqing[0].info\r\n                })\r\n            }\r\n        })\r\n    },\r\n    data : {\r\n        name : \"\",\r\n        pic : \"\",\r\n        info : \"\",\r\n        baseURL\r\n    }\r\n});二、文件上传和相册API2.1小程序和Nodejs后端前端是小程序，后端Nodejs，用formidable来处理POST请求，上传图片。 在小程序中发起POST请求：<!--index.wxml-->\r\n<view class=\"container\">\r\n    <button bindtap=\"fasong\">按我将{a:8}这个信息用POST请求发给服务器</button>\r\n</view> index.jsPage({\r\n    fasong: function(){\r\n        wx.request({\r\n            //请求地址\r\n            url: 'http://127.0.0.1:3000/tijiao',\r\n            //请求类型\r\n            method : \"POST\" ,\r\n            //提交给服务端的数据\r\n            data : {\r\n                a : 8\r\n            },\r\n            //成功的回调函数\r\n            success : function({data}){\r\n                console.log(data.result);\r\n            }\r\n        });\r\n    }\r\n});后端： 示例代码2.2 图片的上传在微信中是两个事：第一：调用wx.chooseImage()这个API，让用户选择一个图片文件或者拍照；第二：调用wx.uploadFile()这个API，来传输文件。 从本地相册选择图片或使用相机拍照的API：wx.chooseImage(); 上传文件的API：wx.uploadFile();<!--index.wxml-->\r\n<view class=\"container\">\r\n    <button bindtap=\"chooseImg\">选择图片</button>\r\n</view> 前端代码index.js：Page({\r\n    chooseImg(){\r\n        //选择图片或者进行拍照\r\n        wx.chooseImage({\r\n            count : 1, //只能选择1张\r\n            //选择图片成功之后做的事情\r\n            success({tempFilePaths}){\r\n                wx.uploadFile({\r\n                    url : \"http://127.0.0.1:3000/tijiao\" , //上传地址\r\n                    filePath: tempFilePaths[0], //要上传的文件，只有1张图片也是数组，所以[0]\r\n                    name: \"tupian\",   //key \r\n                    success({data}){\r\n                        wx.showToast({\r\n                            title: \"上传成功！\"\r\n                        });\r\n                    }\r\n                }); \r\n            }\r\n        });\r\n    }\r\n}); 后端formidable可以处理图片的上传，只需要加一句话：const express = require(\"express\");\r\nconst app = express();\r\nconst formidable = require(\"formidable\");\r\n\r\napp.post(\"/tijiao\", (req,res)=>{\r\n    var form = new formidable.IncomingForm();\r\n    form.uploadDir = \"./uploads\";     //设置图片的保存路径\r\n    form.keepExtensions = true;      //保留拓展名\r\n\r\n    form.parse(req, (err, fileds, file)=>{\r\n        res.json({result: \"ok\"});\r\n    });\r\n});\r\n\r\napp.listen(3000); 开启下拉刷新，在需要下拉刷新的页面中index.json中添加：{\r\n    \"enablePullDownRefresh\" : true\r\n}<!--index.wxml-->\r\n<view class=\"container\">\r\n    <button bindtap=\"chooseImg\">选择图片</button>\r\n    <view wx:for=\"{{imgList}}\" wx:key=\"{{index}}\">\r\n        <image mode=\"center\" src=\"http://127.0.0.1:3000/uploads/{{item}}\"></image>\r\n    </view>\r\n</view> 后端app.jsconst express = require(\"express\");\r\nconst app = express();\r\nconst formidable = require(\"formidable\");\r\nconst fs = require(\"fs\");\r\n\r\n//静态化图片目录\r\napp.use(\"/uploads\" , express.static(\"uploads\"));\r\n\r\n\r\n//处理用户的提交\r\napp.post(\"/tijiao\" , (req,res) => {\r\n    var form = new formidable.IncomingForm();\r\n    form.uploadDir = \"./uploads\"; //设置图片的保存路径\r\n    form.keepExtensions = true;   //保留拓展名\r\n\r\n    form.parse(req , (err , fileds , files) => {\r\n        //将上传文件改名为现在的时间戳，就是1970年1月1日到现在的毫秒数\r\n        var date = Date.parse(new Date());\r\n    　　 var ext = path.extname(files.tupian.path); //获取文件扩展名\r\n        //改名\r\n        fs.rename(`./${files.tupian.path}`, `./uploads/${date}${ext}`, function(){\r\n            res.json({result : \"ok\"});\r\n        });\r\n    });\r\n});\r\n\r\n//列出所有文件的清单\r\napp.get(\"/list\" , (req,res)=>{\r\n    fs.readdir(\"./uploads\", (err, files) => {\r\n        res.json({ imgList: files.reverse()});\r\n    });\r\n});\r\n\r\napp.listen(3000); index.jsPage({\r\n    xuantu(){\r\n       ...\r\n    },\r\n    //显示所有已经上传的图片\r\n    onLoad(){\r\n        var self = this;\r\n        wx.request({\r\n            url: \"http://127.0.0.1:3000/list\",\r\n            success({data}){\r\n                self.setData({\r\n                    imgList: data.imgList\r\n                })\r\n            }\r\n        });\r\n    },\r\n    //当下拉刷新的时候\r\n    onPullDownRefresh(){\r\n        var self = this;\r\n        wx.request({\r\n            url: \"http://127.0.0.1:3000/list\",\r\n            success({data}){\r\n                self.setData({\r\n                    imgList: data.imgList\r\n                })\r\n            }\r\n        });\r\n    }\r\n});2.3获取微信用户信息 示例代码三、Nodejs配置https首先，需要申请SSL证书，证书可以在阿里云、腾讯云、宝塔等平台申请，申请成功后会提供SSL证书下载地址，下载好SSL证书会看见一个压缩包，里面包含很多版本的证书文件（IIS、Apache、Nginx、Tomcat）等，Nodejs服务端采用Nginx版本即可，里面有两个文件分别是：.key和.pem文件。 将文件放在你的Node项目中的某个文件夹中，这里我放在根目录的ssl文件夹中。然后写以下Node代码即可开启https注意：要修改自己的key和pem文件路径和名称//使用node自带的https模块开启https服务\r\nvar https = require(\"https\");\r\n\r\n//读取https配置文件\r\n//读取https配置\r\nvar httpsOption = {\r\n    key : fs.readFileSync(\"./ssl/0_iqd.webqianduan.cn.key\"),\r\n    cert: fs.readFileSync(\"./ssl/1_iqd.webqianduan.cn_bundle.pem\")\r\n}\r\n\r\n//监听端口\r\nhttp.createServer(app).listen(80);\r\nhttps.createServer(httpsOption, app).listen(443); 尽量让它越来越规范，这些文章都是本人的学习时的笔记整理，希望看完后可以指点一二，提提意见多多交流，自由转载-非商用-非衍生-保持署名。 笔记流程：html>css>javascript>jquery>html5/css3>移动端>ajax>面向对象>canvas>nodejs>es678>vue>react>小程序 联系邮箱：scarf666@163.com 有朋友私信问我是怎么学习的，在哪里学习的，感兴趣想学习朋友的可以私信我。"}
{"title": "在微信小程序里面不使用checkbox怎么实现view的多选 ", "author": "Rolan", "pub_time": "2019-9-24 00:27", "content": "wxml文件<block wx:for=\"{{itemList}}\" wx:key=\"id\">  <view class='item_container' bindtap='itemSelected' data-index='{{index}}'>     <image class='select_icon' src=\"{{item.isSelected?'/image/selected.png':'/image/unselected.png'}}\"></image>     <text class='text'>{{item.name}}</text>  </view></block>wxss文件.item_container {  display: flex;  flex-direction: row;  align-items: center;  padding: 20rpx;} .select_icon {  width: 40rpx;  height: 40rpx;} .text {  margin-left: 30rpx;}js文件data: {    itemList: [      { id: 1, name: 'C语言', isSelected: false, },      { id: 2, name: 'Java', isSelected: false, },      { id: 3, name: 'C++', isSelected: false, },    ]  }, itemSelected: function (e) {    var index = e.currentTarget.dataset.index;    var item = this.data.itemList[index];    item.isSelected = !item.isSelected;    this.setData({      itemList: this.data.itemList,    });  }效果如图"}
{"title": "【小程序】小程序优化-代码篇 ", "author": "Rolan", "pub_time": "2019-9-29 00:09", "content": "不知道大家有没有这种体会，刚到公司时，领导要你维护之前别人写的代码，你看着别人写的代码陷入了深深的思考：“这谁写的代码，这么残忍”俗话说“不怕自己写代码，就怕改别人的代码”，一言不和就改到你吐血，所以为了别人好，也为了自己好，代码规范，从我做起。项目目录结构在开发之前，首先要明确你要做什么，不要一上来就是干，咱们先把项目结构搭好。一般来说，开发工具初始化的项目基本可以满足需求，如果你的项目比较复杂又有一定的结构的话就要考虑分好目录结构了，我的做法如下图：component文件夹是放自定义组件的pages放页面public放公共资源如样式表和公共图标units放各种公共api文件和封装的一些js文件config.js是配置文件这么分已经足以满足我的需求，你可以根据自己的项目灵活拆分。配置文件我的项目中有个config.js，这个文件是用来配置项目中要用到的一些接口和其它私有字段，我们知道在开发时通常会有测试环境和正式环境，而测试环境跟正式环境的域名可能会不一样，如果不做好配置的话直接写死接口那等到上线的时候一个个改会非常麻烦，所以做好配置是必需的，文件大致如下：首先是定义域名，然后在config对象里定义接口名称，getAPI(key)是获取接口方法，最后通过module暴露出去就可以了.引用的时候只要在页面引入 import domain from '../../config'; ，然后wx.request的时候url的获取方式是 domain.getAPI('')代码健壮性、容错性例子代码的健壮性、容错性也是我们应该要考虑的一点，移动端的项目不像pc端的网络那么稳定，很多时候网络一不稳定就决定我们的项目是否能正常运行，而一个好的项目就一定要有良好的容错性，就是说在网络异常或其它因素导致我们的项目不能运行时程序要有一个友好的反馈，下面是一个网络请求的例子：相信多数人请求的方式是这样，包括我以前刚接触小程序的时候也是这样写，这样写不是说不好，而是不太严谨，如果能够正常获取数据那还好，但是一旦请求出现错误那程序可以到此就没法运行下去了，有些比较好的会加上faill失败回调，但也只是请求失败时的判断，在请求成功到获取数据的这段流程内其实是还有一些需要我们判断的，一般我的做法是这样：在请求成功后小程序会进行如下判断：判断是否返回200，是则进行一下步操作，否则抛出错误判断数据结构是否完整，是则进行一下步操作，否则抛出错误然后就可以在页面根据情况进行相应的操作了。定制错误提示码可以看到上面的截图的错误打印后面会带一个gde0或gde1的英文代码，这个代码是干嘛用的呢，其实是用来报障的，当我们的小程序上线后可能会遇到一些用户发来的报障，一般是通过截图发给我们，之前没有做错误提示码的时候可能只是根据一句错误提示来定位错误，但是很多时候误提示语都是一样的，我们根本不知道是哪里错了，这样一来就不能很快的定位的错误，所以加上这样一个提示码，到时用户一发截图来，我们只要根据这个错误码就能很快的定位错误并解决了，错误提示码建议命名如下：不宜过长，3个字母左右唯一性意义明确像上面gde表示获取草稿失败，后面加上数字表示是哪一步出错。模块化我们组内的大神说过， 模块化的意义在义分治，不在于复用 。 之前我以为模块化只是为了可以复用，其实不然，无论模块多么小也是可以模块化，哪怕只是一个简单的样式也一样，并是不为了复用，而是管理起来方便。 很多同学经常将一些公共的样式事js放在app.wxss和app.js里以便调用，这样做其实有一个坏处，就是维护性比较差，如果是比较小的项目还好，项目一大问题就来了。而且项目是会迭代的，不可能总是一个人开发，可能后面会交接给其他人开发，所以会造成的问题就是：app.wxss和app.js里的内容只会越来越多，因为别人不确定哪些是没用的也不敢删，只能往里加东西，造成文件臃肿，不利于维护。app.wxss和app.js对于每个页面都有效，可读性方面比较差。所以模块化的意义就出来了，将公共的部分进行模块化统一管理，也便于维护。样式模块化公共样式根据上面的目录结构我是放在public里的css里，每个文件命名好说明是哪个部分的模块化，比如下面这个就表示一个按钮的模块化前面说过模块化不在于大小，就算只是一个简单的样式也可以进行模块化，只要在用到的地方import一下就行了，就知道哪里有用到，哪里没有用到，清晰明了。js模块化js模块化这里分为两个部分的模块化，一部分是公共js的模块化，另一部分是页面js的模块化即业务与数据的拆分。公共js模块化比较常用的公共js有微信登录，弹窗，请求等，一般我是放在units文件夹里，这里经微信弹窗api为例：如图是在小程序中经常会用到的弹窗提示，这里进行封装，定义变量，只要在页面中引入就能直接调用了，不用每次都写一大串。比如在请求的时候是这样用的toast()就是封装的弹窗api，这样看起来是不是清爽多了！业务与数据模块化业务与数据模块化就是指业务和数据分开，互不影响，业务只负责业务，数据只负责数据，可以看到页面会比普通的页面多了一个api.js这个文件主要就是用来获取数据的，而index.js主要用来处理数据，这样分工明确，相比以往获取数据和处理数据都在一个页面要好很多，而且我这里获取数据是返回一个promise对象的，也方便处理一些异步操作。组件化组件化相信大家都不陌生了，自从小程序支持自定义组件，可以说是大大地提高了开发效率，我们可以将一些公共的部分进行组件化，这部分就不详细介绍，大家可以去看文档。组件化对于我们的项目来说有很大的好处，而且组件化的可移植性强，从一个项目复用到另一个项目基本不需要做什么改动。"}
{"title": "微信小程序项目-你是什么垃圾？ ", "author": "Rolan", "pub_time": "2019-9-29 00:23", "content": "垃圾分类特别火也不知道北京什么时候也开始执行，看见之前上海市民被灵魂拷问了以后垃圾真的不知道如何丢了，作为程序员就做一个小程序造福人类吧。效果图：一、全局的app.json和app.wxss加入了一点东西App.json{\r\n  \"pages\": [\r\n    \"pages/index/index\",\r\n    \"pages/details/details\",\r\n    \"pages/logs/logs\"\r\n    \r\n  ],\r\n  \"window\": {\r\n    \"backgroundTextStyle\": \"light\",\r\n    \"navigationBarBackgroundColor\": \"#fff\",\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n    \"navigationBarTextStyle\": \"white\",\r\n    \"navigationStyle\": \"custom\"\r\n  },\r\n  \"sitemapLocation\": \"sitemap.json\"\r\n  \r\n}App.wxss.bg{\r\n  position: absolute;\r\n  left:0;\r\n  top:0;\r\n  width:100%;\r\n  height: 100%;\r\n}二、下面就是首页的index.wxml、index.js、 index.wxssindex.wxml<image class='bg' src='../img/bg.png'></image>\r\n\r\n<view class='container'>\r\n    <view class='top'>\r\n        <text class='top-title'>你是什么垃圾</text>\r\n        <text class='top-more'>一键查询免烦恼，从我做起爱环保</text>\r\n    </view> \r\n\r\n    <view class='search'>\r\n       <view class='search-main'>\r\n         <icon type='search' size='16'></icon>\r\n         <input \r\n         placeholder=\"请输入查询的垃圾名称\"\r\n         bindinput='iptDetails'\r\n         bindconfirm=\"search\"\r\n         ></input>\r\n       </view>\r\n\r\n        <view class='search-end' wx:if='{{searchResultDatas.length > 0}}'>\r\n          <text \r\n          wx:for='{{searchResultDatas}}'\r\n          wx:key='{{index}}'\r\n          bindtap='toDetails'\r\n          data-title='{{item.itemName}}'\r\n          >{{item.itemName}}</text>\r\n        </view>\r\n    </view>\r\n\r\n    <view class='hot'>\r\n        <view class='hot-main'>\r\n          <view class='hot-title'>热门搜索：</view>\r\n          <view class='hot-item'>\r\n\r\n              <text \r\n                wx:for='{{hotSearch}}'\r\n                wx:key='{{index}}'\r\n                bindtap='toDetails'\r\n                data-title='{{item.itemName}}'\r\n              >{{item.itemName}}</text>\r\n             \r\n          </view>\r\n        </view>\r\n    </view>\r\n\r\n</view>index.jsPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    hotSearch:[],\r\n    searchResultDatas:[]\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n      let That = this;\r\n      wx.request({\r\n        url: 'http://apis.juhe.cn/rubbish/hotSearch',\r\n        data:{\r\n          key: 'ae200d60495f41dfb86da332dc059214',\r\n        },\r\n        success(res){\r\n          That.setData({\r\n            hotSearch: res.data.result\r\n          })\r\n        }\r\n      })\r\n    \r\n  },\r\n  toDetails(e){\r\n    let title = e.currentTarget.dataset.title;\r\n    wx.navigateTo({\r\n      url: `../details/details?id=${title}`\r\n    })\r\n  },\r\n  iptDetails(e){\r\n    let That = this;\r\n    let val = e.detail.value;\r\n    if(val.length == 0){\r\n      this.setData({\r\n        searchResultDatas: []\r\n      })\r\n      return;\r\n    }\r\n    \r\n    wx.request({\r\n      url: 'http://apis.juhe.cn/rubbish/search',\r\n      data:{\r\n        key:\"ae200d60495f41dfb86da332dc059214\",\r\n        q: val\r\n      },\r\n      success(res){\r\n        That.setData({\r\n          searchResultDatas: res.data.result\r\n        })\r\n      }\r\n    })\r\n  },\r\n  /**\r\n   * 生命周期函数--监听页面初次渲染完成\r\n   */\r\n  onReady: function () {\r\n    \r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面显示\r\n   */\r\n  onShow: function () {\r\n    \r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面隐藏\r\n   */\r\n  onHide: function () {\r\n    \r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面卸载\r\n   */\r\n  onUnload: function () {\r\n    \r\n  },\r\n\r\n  /**\r\n   * 页面相关事件处理函数--监听用户下拉动作\r\n   */\r\n  onPullDownRefresh: function () {\r\n    \r\n  },\r\n\r\n  /**\r\n   * 页面上拉触底事件的处理函数\r\n   */\r\n  onReachBottom: function () {\r\n    \r\n  },\r\n\r\n  /**\r\n   * 用户点击右上角分享\r\n   */\r\n  onShareAppMessage: function () {\r\n    \r\n  }\r\n})index.wxss.container{\r\n  position: relative;\r\n  left:0;\r\n  top:88rpx;\r\n}\r\n\r\n.search-end{\r\n  display: flex;\r\n  overflow-y:auto;\r\n  background: #fff;\r\n  width:100%;\r\n  height: 750rpx;\r\n  position: fixed;\r\n  left:0rpx;\r\n  bottom:0rpx;\r\n  z-index:999;\r\n  flex-direction: column;\r\n  padding:30rpx;\r\n}\r\n.search-end text{\r\n  padding:20rpx 0 ;\r\n  border-bottom:1px solid #f5f5f5;\r\n  font-size:12px;\r\n  color:#ccc;\r\n} \r\n\r\n.top{\r\n  display: flex;\r\n  align-items: center;\r\n  flex-direction: column;\r\n  padding-top:150rpx;\r\n  color:#fff;\r\n}\r\n.top-title{\r\n  font-size:36px;\r\n  font-weight: bold;\r\n}\r\n.top-more{\r\n  font-size:12px;\r\n}\r\n.search{\r\n  padding-top:40rpx;\r\n  display: flex;\r\n  justify-content: center;\r\n}\r\n.search-main{\r\n  display: flex;\r\n  align-items: center;\r\n  background: #fff;\r\n  height:80rpx;\r\n  width:90%;\r\n  border-radius: 10rpx;\r\n}\r\n.search-main icon{\r\n   width:80rpx;\r\n   text-align: center;\r\n}\r\n.search-main input{\r\n  flex:1;\r\n  font-size:12px;\r\n}\r\n\r\n\r\n.hot{\r\n  padding-top:40rpx;\r\n  display: flex;\r\n  justify-content: center;\r\n}\r\n.hot-main{\r\n  width:90%;\r\n  color:#fff;\r\n}\r\n.hot-title{\r\n  padding:20rpx 0;\r\n}\r\n.hot-item{\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n}\r\n.hot text{\r\n  border-radius: 30rpx;\r\n  border:1px solid #fff;\r\n  padding:5rpx 30rpx;\r\n  margin: 20rpx 20rpx 20rpx 0;\r\n  font-size:12px;\r\n}三、下面就是详情页details.wxml、details.js、details.wxssdetails.wxml<image class='bg' src='../img/bg.png'></image>\r\n\r\n<view class='details'>\r\n    <view class=\"end\">\r\n       <text class='name'>{{item.itemName}}</text>\r\n       <text class='attr'>属性“{{item.itemCategory}}”</text>\r\n    </view>\r\n\r\n    <view class='details-more'>\r\n\r\n       <view class='more-title'>\r\n        {{item.itemCategory}}投放指导\r\n       </view>\r\n\r\n       <view class='more-title'>\r\n           <text>·尽量沥干水分</text>\r\n           <text>·难以辨别的生活垃圾应投入垃圾容器内</text>\r\n           <text>·餐巾纸、纸巾、纸尿裤等其他垃圾</text>\r\n       </view>\r\n\r\n    </view>\r\n\r\n    <button bindtap='toHome'>关闭</button>\r\n    \r\n</view>details.js// pages/details/details.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    item:[]\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n    let itemName = options.id;\r\n    let That = this;\r\n    wx.request({\r\n      url: 'http://apis.juhe.cn/rubbish/search',\r\n      data:{\r\n        key: 'ae200d60495f41dfb86da332dc059214',\r\n        q: itemName,\r\n        type:2\r\n      },\r\n      success(res){\r\n        That.setData({\r\n          item: res.data.result[0]\r\n        })\r\n      }\r\n    })\r\n  },\r\n  toHome(){\r\n    // wx.navigateTo({\r\n    //   url: '../index/index',\r\n    // })\r\n    wx.navigateBack()\r\n  },\r\n  /**\r\n   * 生命周期函数--监听页面初次渲染完成\r\n   */\r\n  onReady: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面显示\r\n   */\r\n  onShow: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面隐藏\r\n   */\r\n  onHide: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面卸载\r\n   */\r\n  onUnload: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 页面相关事件处理函数--监听用户下拉动作\r\n   */\r\n  onPullDownRefresh: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 页面上拉触底事件的处理函数\r\n   */\r\n  onReachBottom: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 用户点击右上角分享\r\n   */\r\n  onShareAppMessage: function () {\r\n\r\n  }\r\n})index.wxss.details{\r\n  position: relative;\r\n  top:44px;\r\n  left:0;\r\n}\r\n.end{\r\n  padding-top:120rpx;\r\n  padding-bottom:100rpx;\r\n  color:#fff;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n}\r\n.end text{\r\n  padding:5rpx 0;\r\n}\r\n.name{\r\n  font-size:21px;\r\n}\r\n.attr{\r\n  font-size:36px;\r\n  font-weight: bold;\r\n}\r\n\r\n\r\n.details-more{\r\n  width:90%;\r\n  margin:0 auto;\r\n  background: #fff;\r\n  border-radius:  20rpx;\r\n  padding:20rpx;\r\n}\r\n.more-title{\r\n  padding:10rpx;\r\n  font-size:16px;\r\n}\r\n.more-title text{\r\n  padding:20rpx;\r\n  font-size:12px;\r\n  display: block;\r\n}\r\nbutton{\r\n  margin-top:100rpx;\r\n  background: #fff;\r\n  color:#0190ff;\r\n  border:none;\r\n  width:300rpx;\r\n  height: 80rpx;\r\n  border-radius: 50rpx;\r\n  font-size:14px;\r\n  text-align: center;\r\n  line-height: 80rpx;\r\n}"}
{"title": "【小程序】利用canvas生成朋友圈分享海报 ", "author": "Rolan", "pub_time": "2019-9-29 00:34", "content": "由于小程序的限制，我们不能很方便地在微信内直接分享小程序到朋友圈，所以普遍的做法是生成一张带有小程序分享码的分享海报，再将海报保存到手机相册，有两种方法可以生成分享海报，第一种是让后台生成然后返回图片链接，这一种方法比较简单，只需要传后台所需要的参数就行了，今天给大家介绍的是第二种方法，用canvas生成分享海报。效果主要步骤把海报样式用标签先写好，方便画图时可以比对用canvas进行画图，canvas要注意定好宽高canvas利用wx.canvasToTempFilePath这个api将canvas转化为图片将转化好的图片链接放入image标签里再利用wx.saveImageToPhotosAlbum保存图片坑点用canvas进行画图的时候要注意画出来的图的大小一定要是你用标签写好那个样式的两倍大小，比如你的海报大小是400 600的大小，那你用canvas画的时候大小就要是800 1200，宽高可以写在样式里，如果你画出来的图跟你海报图是一样的大小的话生成的图片是会很模糊的，所以才需要放大两倍。画图的时候要注意尺寸的转化，如果你是用rpx做单位的话，就要对单位进行转化，因为canvas提供的方法都是经px为单位的，所以这一点要注意一下，px转rpx的公式是w/750 z 2，w是手机屏幕宽度screenWidth，可以通过wx.getSystemInfo获取，z是你需要画图的单位，2就是乘以两倍大小。图片来源问题，因为canvas不支持网络图片画图，所以你的图片要么是固定的，如果不是固定的，那就要用wx.downloadFile下载后得到一个临时路径才行小程序码问题，小程序需要后台请求接口后返回一个二进制的图片，因为二进制图片canvas也是不支持的，所以也是要用wx.downloadFile下载后得到一个临时路径，或者可以叫后台直接返回一个小程序码的路径给你这里保存的时候是有个授权提醒的，如果拒绝的话再次点击就没有反应了，所以这里我做了一个判断是否有授权的，如果没有就弹窗提醒，确认的话会打开设置页面，确认授权后再次返回就行了，这里有个坑注意下，就是之前拒绝后再进入设置页面确认授权返回页面时保存图片会不成功，官方还没解决，我是加了个setTimeOut处理的，详情可以看这里 developers.weixin.qq.com/community/d…代码实现这里图片我先用的是网上的链接，实际项目中是后台返回的数据，这个可以自行处理，这里只是为了演示方便，生成临时路径的方法我这里是分别定义了一个方法，其实可以合成一个方法的，只是生成小程序码时如果要传入参数要注意一下。绘图方法是drawImg，这里截一部分，详细的可以看代码片段"}
{"title": "小程序日历组件 ", "author": "Rolan", "pub_time": "2019-7-19 00:42", "content": "程序日历组件\r\n闲来没事把之前想做的日历组件给做了 先上图\r\n\r\n参数\r\n\r\n        \r\n            参数\r\n            类型\r\n            说明\r\n            默认值\r\n        \r\n        \r\n            header\r\n            Boolean\r\n            是否显示头部操作栏\r\n            true\r\n        \r\n        \r\n            preMonth\r\n            Boolean\r\n            是否显示上个月按钮\r\n            true\r\n        \r\n         \r\n            nextMonth\r\n            Boolean\r\n            是否显示下个月按钮\r\n            true\r\n        \r\n         \r\n            preYear\r\n            Boolean\r\n            是否显示上一年按钮\r\n            false\r\n        \r\n         \r\n            nextYear\r\n            Boolean\r\n            是否显示下一年按钮\r\n            false\r\n        \r\n         \r\n            today\r\n            Boolean\r\n            是否显示今天按钮\r\n            false\r\n        \r\n        \r\n            weeks\r\n            Boolean\r\n            是否显示周标题\r\n            true\r\n        \r\n        \r\n            weeksType\r\n            String\r\n            周标题类型\r\n            cn\r\n        \r\n        \r\n            showMoreDays\r\n            Boolean\r\n            是否显示前后月份残余数据\r\n            false\r\n        \r\n        \r\n            formatType\r\n            String\r\n            日期连接符\r\n            -\r\n        \r\n    \r\n事件\r\n\r\n\r\n\r\n事件名称\r\n说明\r\n\r\n\r\n\r\n\r\nselect\r\n在选择日期时触发，返回选中的日期\r\n\r\n\r\n\r\n示例\r\nindex.wxml\r\n<calendar today=\"{{true}}\" bind:select=\"select\"></calendar>\r\n复制代码index.json\r\n\"usingComponents\": {\r\n        \"calendar\": \"../../../components/calendar/index\"\r\n    }\r\n复制代码index.js\r\nselect(e) {\r\n        console.log(e)\r\n    },\r\n复制代码返回选中的日期 e.detail.value\r\n\r\n详细代码看github\r\ngithub"}
{"title": "微信小程序 禁止弹框底部内容滑动 ", "author": "Rolan", "pub_time": "2019-7-29 00:11", "content": "我们需要解决的问题：当弹框显示的时候，弹框下面的内容不能滚动小程序的弹框特别多,像下面这样，弹框的底部是一个可以下拉的页面，但是当弹框出现的时候，需要禁止底部的滚动，那么怎么做呢？直接给出答案吧：给 view 加上 catchtouchmove='true' 就可以.比如下面这种：<view catchtouchmove='true' ></view>至于加到哪个view上边，自然是最外边包含整个屏幕的view了。如果你实在不知道哪一个，你试一下也成。网友们的方法网友们有人使用的方式是给 catchtouchmove 绑定一个空方法。这也是一个解决方法。<view catchtouchmove='prevent' ></view>\r\n\r\nprevent(){\r\n    return ;\r\n}友情提醒：关于不能滚动的这个效果需要在真机上面查看，在编辑器上面看不到效果。至此，完成。"}
{"title": "小程序页面栈详解 ", "author": "Rolan", "pub_time": "2019-8-6 00:08", "content": "原文链接小程序页面栈详解在做小程序项目的时候不难发现，使用navigateTo进行页面跳转后，点击左上角或使用navigateBack返回，总是会按照之前的页面进入倒序来展示页面，那么问题来了，它们的跳转规则是什么样的呢？结合到实际业务中如何灵活运用呢？什么是页面栈？首先先来了解一下微信小程序的运行环境： 小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。 小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。我们可以看到，一个页面使用一个 WebView 线程进行渲染。如果打开10个页面，则会开启 10 个 WebView 线程，此时内存中的十个webView线程我们称之为页面栈。当然小程序也会对这块内存做限制，目前页面栈的限制是不能超过十条。在小程序中页面的路由是小程序框架本身控制的我们不要去手动管理， 小程序框架通过一个页面栈的设计来管理所有的界面，当发生路由跳转时，页面栈就会做出相应的变化，在小程序页面中通过 getCurrentPages() 就可以获取到当前的页面栈。举个栗子： 在父页面中先获取页面栈：const page = getCurrentPages(); // 父页面\r\nconsole.log('父页面', page); //父页面\r\n复制代码通过wx.navigateTo跳转子页面，在子页面中再获取页面栈：const page = getCurrentPages(); // 子页面\r\nconsole.log('子页面', page); //子页面\r\n复制代码输出：通过上面的例子可以看到，我们可以在页面中通过 getCurrentPages() 方法来获取当前页面栈，并且获取到的是一个数组，其中每个item都是每个页面的Page对象（也就是在页面中的this对象），由此我们引发一些思考……路由跳转时页面栈表现？当发生路由切换的时候，页面栈的表现如下： 当发生路由切换的时候，页面栈的表现如下：情景页面栈表现对应路由跳转API小程序初始化新页面入栈打开新页面新页面入栈wx.navigateTo 或使用组件页面重定向当前页面出栈，新页面入栈wx.redirectTo 或使用组件页面返回页面不断出栈，直到目标页wx.navigateBack 或使用组件或用户按左上角返回按钮Tab 切换页面全部出栈，只留下新的 Tab 页面wx.switchTab 或使用组件 或用户切换 Tab重加载页面全部出栈，只留下新的页面wx.reLaunch 或使用组件我们在做项目的时候，巧妙运用路由跳转和页面栈会节省很多代码，用户体验也会得到相应的提升，所以，在开始项目之前，定好页面跳转规则相当重要。页面栈的实际运用分析下面我们分析一下页面栈的变化过程，从分析中，我们需要明白的一个重要问题就是，当客户按返回按钮的时候究竟会跳转到那个界面，这是我们分析页面栈变化的的意义。 首先我们在页面中调用两次navigateTo，页面栈情况如下这时显示的界面是pageC ，如果客户在此时返回则会一切正常，回退的第一个界面是pageB，然后是pageA。但是如果在pageC 界面调用 wx.redirectTo({url:'pageD'}) 则情况就会不一样，我们先看一下跳转到pageD后页面栈的情况如何。根据栈的情况，我们可以分析出。如果使用 wx.redirectTo跳转到pageD页面，然后在回退的时候是不能再次回退到pageC的，而会直接回退到pageB。 通过上面对页面栈的分析，我们可以看到栈的变化是会影响客户回退页面的顺序的，所以根据自己的需求合理的使用不同的跳转方法是非常重要的。如果使用不当就会导致跳转混乱让人摸不清头脑 下面分析一种调转重复页面的情况：如图所示栈中出现了两个相同的pageB界面，这个时候如果用户按退出键就会出现一个页面出现2次的情况，而且有一个界面的数据也是旧的数据。因此为了避免这个问题，我们应该在 PageC 页面避免将 PageB重复压入栈中，所以在pageC页面使用wx.navigateBack({delta:1}); 进行页面回退。而数据刷新的问题则在页面的onShow函数中进行即可。情景：确认订单页用户点击左上角返回假设场景：用户在商品详情页直接点击“立即购买”下单购买，进入确认订单页，付款成功后跳转到付款成功页面，此时用户点击左上角箭头进行了返回…… 处理：此时理应进入商品详情页，所以在确认订单页付款成功跳转时应当将确认订单页出栈，新页面入栈，那么就不可以使用wx.navigateTo来进行页面跳转，应当使用wx.redirectTo情景：确认订单页用户选择已有收货人假设场景：在确认订单页，用户需要选择已有的收货人，而已有收货人列表在另一个页面，那么用户点击“选择收货人”之后，使用wx.navigateTo跳转到收货人列表，点击某个收货人，带参数返回确认订单页…… 处理：在确认订单页使用wx.navigateTo跳转到收货人列表，然后在收货人列表里click事件中获取页面栈，直接往上一个页面setData，然后退回上一个页面，show code：const page = getCurrentPages()\r\nif (page.length > 1) {\r\n  page[page.length - 2].setData({\r\n    收货人: 选中的某个收货人详情   //[object]\r\n  })\r\n  wx.navigateBack({\r\n    delta: 1\r\n  })\r\n}\r\n复制代码上面例子中提到过，在页面中通过 getCurrentPages() 方法来获取当前页面栈，并且获取到的是一个数组，其中每个item都是每个页面的Page对象，那么我们就可以使用 setData 方法直接改变上一个页面展示的数据，并且直接退回上一个页面。此时官方提醒：虽然这种方法简便，但是官方也给出提醒，页面栈数据可以自行修改，但是！一定要慎重，否则会导致页面状态错误。总结： 总觉得漏了点啥，又想不起来…… 官方文档应有尽有，多研究官方文档，多引发思考并手写demo尝试，总会有一些新的发现，另外，方法千万条，随便选一条，根据自己业务逻辑选用合适的方法。"}
{"title": "一步一步踩坑实现微信小程序自动预览 ", "author": "Rolan", "pub_time": "2019-8-6 00:14", "content": "在最近的工作中，主要做的是C端的小程序，在开发过程中倒是还好，一到改BUG的时候，可能就会进入保存，编译，自动预览的循环了，虽然微信已经提供了快简介自动预览，但是总归是一个手动的过程，要是能监听文件变化自动预览不是更好吗？查看文档于是我就去看了下文档，发现微信已经提供了这个API，可以用命令行调用，也可以用HTTP调用。一开始本着配置少一点的原则，我选择了HTTP调用，因为命令行调用需要配置微信开发者工具的安装目录，而HTTP调用可以通过微信指定的路径获取端口号（实践证明，too young, too simple， 认真你就输了，\tHTTP调用的问题太多，所以我后来又改成了命令行调用 ）。然后就去官方所指示的ide文件夹找端口号了，结果并没有发现那个文件。怎么回事呢？一顿搜索之后，才知道目前的版本需要如下才能开启http服务：\t微信开发者工具 -> 查看所有项目 -> 设置 -> 安全 ，里面有个服务端口，选择开启以后就能找到ide文件，进而得到端口号进行后续操作了。前置工作commander ，主要是从命令行读取参数，实现动态配置，方便调用。chalk 控制台输出格式多样化。axios 用于发起http请求。package.json中的bin 字段，用于实现自定义命令。路径区分，\tprocess.cwd()执行命令时所在的目录，__dirname执行文件所在的目录。 导入配置文件主要是用前者。使用\tfs.watch 进行目录和文件的监听，在文件变动后调用自动预览读取端口号文档中提到 端口号文件位置：macOS : ~/Library/Application Support/微信开发者工具/Default/.ide Windows : ~/AppData/Local/微信开发者工具/User Data/Default/.ide既然路径有了，那么就好说了，只要\t获取到用户目录，然后再拼接上不同平台的后续路径，那么通过读取.ide文件就可以得到端口号了 。代码如下:const fs = require(\"fs\");\r\nconst os = require(\"os\");\r\nconst isWin = os.platform() === `win32`;\r\n\r\nfunction getHttpPort() {\r\n  const home = os.homedir();\r\n  const suffix = isWin\r\n    ? `/AppData/Local/微信开发者工具/User Data/Default/.ide`\r\n    : `/Library/Application Support/微信开发者工具/Default/.ide`;\r\n  const idePath = home + suffix;\r\n\r\n  const port = fs.readFileSync(idePath, { encoding: \"utf8\" });\r\n\r\n  return port;\r\n}\r\n复制代码打开工具或指定项目HTTP调用实例：# 打开工具\r\nhttp://127.0.0.1:端口号/open\r\n# 打开/刷新项目\r\nhttp://127.0.0.1:端口号/open?projectpath=项目全路径\r\n复制代码先在浏览器中直接进行访问，很好，你会发现\t微信开发者工具并没有打开 ，再仔细看了下文档，用法肯定没错的，总共就端口号和项目路径两个变量，怎么可能会出错呢？被某厂坑久了，就知道有问题是必然的。算了，打不开就打不开吧，影响并不是很大，反正平时开发的时候，开发者工具都是打开的。这个问题呢，我猜测是因为\t工具每次打开端口号都会变化 ，而读取的端口号是之前的，所以就没用了。命令行调用-o, --open [projectpath]: 打开工具，如果不带 projectpath，只是打开工具。如果带 project path，则打开路径中的项目，每次执行都会自动编译刷新，并且自动打开模拟器和调试器。projectpath 不能是相对路径。项目路径中必须含正确格式的 project.config.json 且其中有 appid 和 projectname 字段。调用：cli -o /Users/username/demo\r\n复制代码这次的调用完全没有问题的。自动预览HTTP调用接口定义：URL：/autopreviewHTTP 方法：GETURL 参数必填说明projectpath是指定路径中的项目。如项目已打开，自动刷新项目。如项目未创建，自动创建并自动预览项目infooutput否指定后，会将本次自动预览的额外信息以 json 格式输出至指定路径，如代码包大小、分包大小信息。compilecondition否指定自定义编译条件，值为 json 字符串，条件可指定两个字段，pathName 表示打开的页面，不填表示首页，query 表示页面参数这个接口请求以后，倒是可以用，但是坑也不小。infooutput 这个参数我写了，却并没有生成相应的文件。compilecondition 这个参数其实是我从预览那个接口凑过来的，官方文档只有2个参数 。本来我也没想到这个参数的，但是没办法，我们的项目首页是pages/home/index，自动预览以后可能是没找到pages/index/index这种默认的首页，然后就随便跳了一个？文档总是缺三少四的，这里一块那里一块，稍微看漏一点这个功能可能就出不来了，说到底看文档就是得仔细。命令行调用自动预览必须处于登录状态，如果没有登录，会提示需先登录。--auto-preview <project_root> : 自动预览代码，project_root 指定项目根路径。--auto-preview-info-output <path> : 指定后，会将本次预览的额外信息以 json 格式输出至指定路径，如代码包大小、分包大小信息。官方文档只介绍了这两个参数，还是像之前一样，从预览那个的调用凑一下吧。--compile-condition '<json>' : 指定自定义编译条件，json 条件可指定两个字段，pathName 表示打开的页面，不填表示首页，query 表示页面参数用命令行测试：cli --auto-preview /Users/username/demo --compile-condition {\\\"pathName\\\": \\\"pages/home/index\\\",\\\"query\\\":\\\"a=1\\\"}\r\n复制代码大坑命令行调用的时候编译条件应该是调用\tJSON.stringify(obj).replace(/\\\"/g, `\\\\\"`) 所获得的字符串，\t注意要把\"换成\\\"，且前后不需要单引号 ，文档里面那种调用方式会报错，不信的小伙伴可以自己尝试。查询参数query只能有一个参数 ，如果用&链接多个参数的话，提示信息是成功，但是手机并没有自动预览，害得我还纳闷了好久。这个问题必须得给官方反应一下，太影响使用了。node脚本编写思路辅助函数// 将D:\\\\www\\\\soft转换成D:/www/soft这种形式\r\n// msg为路径不存在时的报错信息\r\nfunction getPath(projectpath, msg) {\r\n  if (!projectpath) {\r\n    throw new Error(msg);\r\n  }\r\n  return projectpath.split(path.sep).join(`/`);\r\n}\r\n\r\n// 获取打包路径\r\nfunction getDist(config = {}) {\r\n  const { projectpath } = config;\r\n  return (\r\n    config.dist ||\r\n    (/dist\\/?$/.test(projectpath) ? projectpath : (projectpath || \"\") + `/dist`)\r\n  );\r\n}\r\n\r\n// 将exec转为promise类型的函数，方便使用async await\r\nconst promisify = require(\"util\").promisify;\r\nlet { exec } = require(\"child_process\");\r\nexec = promisify(exec);\r\n复制代码这里介绍一下execchild_process.exec(command[, options][, callback])\r\n复制代码参数类型说明commandstringThe command to run, with space-separated arguments. (需要运行的命令，参数用空格分开)optionsobject{ cwd: \"子进程工作目录，默认为null\", }\t其他参数我没怎么用过callback否回调函数: (error: Error, stdout: string | Buffer, stderr: string | Buffer）spawn和exec的却别在于，spawn的输出是实时的，而exec是执行完之后统一返回。前者还得监听事件略显麻烦，所以我选择了exec。open.jsasync function open({ projectpath, cli, }) {\r\n  return new Promise(async (resolve, reject) => {\r\n    log();\r\n    log(chalk.green(`打开开发者工具中...`));\r\n    const result = await exec(\r\n      `cli -o ${projectpath}`,\r\n      {\r\n        cwd: cli\r\n      }\r\n    );\r\n\r\n    const isSuccess = result.stdout;\r\n    log(isSuccess ? chalk.green(`打开成功`) : chalk.red(`打开失败`));\r\n    isSuccess ? resolve() : reject();\r\n  })\r\n}\r\n复制代码preview.jsasync function preview(config) {\r\n  await open(config);\r\n\r\n  const port = getHttpPort();\r\n  const { dist, projectpath, time, compile, cli } = config;\r\n\r\n  log();\r\n  log(chalk.blue(`开始监听文件变动`));\r\n  log(`路径参数: `, compile);\r\n\r\n  fs.watch(\r\n    dist,\r\n    debounce(async (evt, filename) => {\r\n      log();\r\n      console.log(`${filename} ${evt}`);\r\n\r\n      log(chalk.green(`自动预览重启中...`));\r\n      log(\r\n        `执行命令： cli --auto-preview ${projectpath} --compile-condition ${compile}`\r\n      );\r\n      const result = await exec(\r\n        `cli --auto-preview ${projectpath} --compile-condition ${compile}`,\r\n        {\r\n          cwd: cli\r\n        }\r\n      );\r\n\r\n      const isSuccess = result.stdout;\r\n      log(isSuccess ? chalk.green(`自动预览成功`) : chalk.red(`自动预览失败`));\r\n    }, time || 1000)\r\n  );\r\n}\r\n复制代码lib/index.jsconst fn = {\r\n  preview,\r\n  upload,\r\n};\r\n\r\nfunction run(config, type) {\r\n  if (!fn[type]) {\r\n    throw new Error(`type参数不合法，请确保为preview, upload的一种`);\r\n  }\r\n\r\n  log(chalk.green(`本次启动类型为: ${type}`));\r\n  fn[type](config);\r\n}\r\n复制代码config参数从命令行参数中读取文件获得，type参数为命令行参数。bin/index.js#! /usr/bin/env node\r\nconst run = require(\"../lib/index\");\r\nconst program = require(\"commander\");\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst { getPath, getHttpPort, getDist } = require(\"../util/index\");\r\n\r\nprogram\r\n  .option(\"-c, --config <type>\", \"config file\", \"auto.js\")\r\n  .option(\"-t, --type <type>\", \"auto type, etc: preview, upload\", \"preview\")\r\n  .parse(process.argv);\r\n\r\n// 获取执行命令时所在的目录，拼接上配置文件目录，使用require(ConfigFile)即可获得相关配置\r\nconst CD = process.cwd();\r\nconst Config = program.config;\r\nconst ConfigFile = path.join(CD, Config);\r\n\r\nconst defaultCompile = {\r\n  pathName: `pages/home/index`\r\n};\r\n\r\n// 判断配置文件不存在，则直接报错\r\nif (!fs.existsSync(ConfigFile)) {\r\n  throw new Error(`[ERROR]: ${Config} not found in ${CD}`);\r\n} else {\r\n  start();\r\n}\r\n\r\nfunction start() {\r\n  let config = require(ConfigFile);\r\n  config = { ...config };\r\n  config.projectpath = getPath(\r\n    config.projectpath,\r\n    `配置文件中projectPath字段必须有值`\r\n  );\r\n  const projectpath = config.projectpath;\r\n  config.dist = getDist(config);\r\n  config.compile = JSON.stringify(config.compile || defaultCompile).replace(\r\n    /\\\"/g,\r\n    `\\\\\"`\r\n  );\r\n  // 这里可写可不写，打开工具后会进行再次获取\r\n  config.port = getHttpPort();\r\n\r\n  run(config, program.type);\r\n}\r\n复制代码至此，该功能已经大致完成了，我已经上传到了npm，可以直接进行使用。wx-auto微信开发者工具，HTTP调用，自动预览，提高工作效率局部安装npm i wx-auto -D 或者 yarn add wx-auto -D\r\n复制代码全局安装npm i wx-auto -g \r\n复制代码使用方法wxauto\r\n或者\r\nwxauto -t preview -c auto.js\r\n复制代码参数(均有默认值)-t, --type 类型，目前支持preview和upload\r\n-c, --config 配置文件名，默认值为auto.js\r\n复制代码文件路径为相对路径，相对于执行命令时所在的路径配置文件{\r\n  cli: \"D:/soft/微信web开发者工具\", // cli文件所在的目录\r\n  projectpath: `D:/www/react/heywoof-app-frontend`, // 项目地址\r\n  compile: {\r\n    pathName: `pages/scene/index`, // 自动预览的页面路径\r\n    query: `activityId=5d45050569515b000c5b740a` // 查询参数，微信目前有BUG，只能识别一个参数\r\n  },\r\n  build: `yarn build-test:weapp`, // 上传之前需要执行的命令\r\n  upload: {\r\n    version: \"1.0.1\",\r\n    desc: \"测试自动上传，不要乱动\"\r\n  }\r\n};\r\n复制代码此外还包含了自动打包上传的功能，配置之后执行\twxauto -t upload -c auto.js ，上传完毕后就会自动打开微信公众平台登录的网站，个人感觉还是挺实用的。自动化测试在查看文档的时候，我发现微信官方推出了一个\t多端统一开发工具——kbone ，这个是基于vue的，就是配置略显麻烦。除此之外，微信小程序现在已经支持自动化测试了，感兴趣的小伙伴可以自行尝试。注意：\t该功能需要最新版本支持 ，一定要符合文档所说的版本，我简单尝试了一下，自动化是可以实现的，更具体的测试就得看工作需要了。"}
{"title": "小程序页面通信、数据刷新、事件总线 、event bus 终极解决方案之 iny-bus ... ", "author": "Rolan", "pub_time": "2019-8-6 00:48", "content": "背景介绍\r\n在各种小程序中，我们经常会遇到 这种情况\r\n有一个 列表，点击列表中的一项进入详情，详情有个按钮，删除了这一项，这个时候当用户返回到列表页时,\r\n发现列表中的这一项依然存在，这种情况，就是一个 `bug`，也就是数据不同步问题，这个时候测试小姐姐\r\n肯定会找你，让你解决，这个时候，你也许会很快速的解决，但过一会儿，测试小姐姐又来找你说，我打开了\r\n四五个页面更改了用户状态，但我一层一层返回到首页，发现有好几个页面数据没有刷新，也是一个 bug，\r\n这个时候你就犯愁了，怎么解决，常规方法有下面几种\r\n复制代码\r\n解决方法\r\n  1. 将所有请求放到 生命周期 `onShow` 中，只要我们页面重新显示，就会重新请求，数据也会刷新\r\n  2. 通过用 `getCurrentPages` 获取页面栈，然后找到对应的 页面实例，调用实例方法，去刷新数据\r\n  3. 通过设置一个全局变量，例如 App.globalData.xxx，通过改变这个变量的值，然后在对应 onShow \r\n  \t 中检查，如果值已改变，刷新数据\r\n  4. 在打开详情页时，使用 redirectTo 而不是 navigateTo，这样在打开新的页面时，会销毁当前页面，\r\n     返回时就不会回到这个里面，自然也不会有数据不同步问题\r\n复制代码\r\n存在的问题\r\n1. 假如我们将 所有 请求放到 onShow 生命周期中，自然能解决所有数据刷新问题，但是 onShow \r\n  这个生命周期，有两个问题\r\n  \r\n  第一个问题，它其实是在 onLoad 后面执行的，也就是说，假如请求耗时相同，从它发起请求到页面渲染，\r\n  会比 onLoad 慢\r\n  \r\n  第二个问题，那就是页面隐藏、调用微信分享、锁频等等都会触发执行，请求放置于 `onShow` 中就会造成\r\n  大量不需要的请求，造成服务器压力，多余的资源浪费、也会造成用户体验不好的问题\r\n\r\n2. 通过 `getCurrentPages` 获取页面栈，然后找到对应的 页面实例，调用实例方法，去刷新数据，这也\r\n不失为一个办法，但是就如微信官方文档所说\r\n\r\n  > 不要尝试修改页面栈，会导致路由以及页面状态错误。\r\n  > 不要在 App.onLaunch 的时候调用 `getCurrentPages()`，此时 page 还没有生成。\r\n\r\n  同时、当需要通信的页面有两个、三个、多个呢，这里去使用 `getCurrentPages` 就会比较困难、繁琐\r\n\r\n3. 通过设置全局变量的方法，当需要使用的地方比较少时，可以接受，当使用的地方多的时候，维护起来\r\n就会很困难，代码过于臃肿，也会有很多问题\r\n\r\n4. 使用 redirectTo 而不是 navigateTo，从用来体验来说，很糟糕，并且只存在一个页面，对于\r\ntab 页面，它也无能为力，不推荐使用\r\n复制代码\r\n最佳实践\r\n在 Vue 中， 可以通过 new Vue() 来实现一个 event bus作为事件总线，来达到事件通知的功能，在各大\r\n框架中，也有自身的事件机制实现，那么我们完全可以通过同样的方法，实现一个事件中心，来管理我们的事件，\r\n同时，解决我们的问题。iny-bus 就是这样一个及其轻量的事件库,使用 typescript 编写，100% 测试覆\r\n盖率，能运行 js 的环境，就能使用\r\n复制代码\r\n传送门\r\n源码\r\nNPM\r\n文档\r\n简单使用\r\niny-bus 使用及其简单，在需要的页面 onLoad 中添加事件监听， 在需要触发事件的地方派发事件，使监\r\n听该事件的每个页面执行处理函数，达到通信和刷新数据的目的，在小程序中的使用可以参考以下代码\r\n复制代码\r\n\r\n  // 小程序\r\n  import bus from 'iny-bus'\r\n\r\n  // 添加事件监听\r\n  // 在 onLoad 中注册, 避免在 onShow 中使用\r\n  onLoad () {\r\n    this.eventId = bus.on('事件名', (a, b, c, d) => {\r\n      // 支持多参数\r\n      console.log(a, b, c, d)\r\n\r\n      this.setData({\r\n        a,\r\n        b,\r\n        c\r\n      }\r\n      // 调用页面请求函数，刷新数据\r\n      this.refreshPageData()\r\n    })\r\n\r\n    // 添加只需要执行一次的 事件监听\r\n\r\n    this.eventIdOnce = bus.once('事件名', () => {\r\n      // do some thing\r\n    })\r\n  }\r\n\r\n  // 移除事件监听，该函数有两个参数，第二个事件id不传，会移除整个事件监听，传入ID，会移除该\r\n  页面的事件监听，避免多余资源浪费, 在添加事件监/// 听后，页面卸载(onUnload)时建议移除\r\n\r\n  onUnload () {\r\n    bus.remove('事件名', this.eventId)\r\n  }\r\n\r\n  // 派发事件，触发事件监听处更新视图\r\n  // 支持多参传递\r\n  onClick () {\r\n    bus.emit('事件名', a, b, c)\r\n  }\r\n\r\n复制代码更详细的使用和例子可以参考 Github iny-bus 小程序代码\r\niny-bus 具体实现\r\n\r\niny-bus 我们是使用 typescript 编写，同时要发布到 npm 上供大家使用，那我们就需要搭建开发环境，选择编辑打包工具，编写发布脚本，具体的细节这里不讲，只列举以下使用到的工具和库\r\n\r\n\r\n\r\n基本打包工具，这里使用非常优秀的开源库 typescript-library-starter，具体细节不展开\r\n\r\n\r\n测试工具 使用 facebook 的 jest\r\n\r\n\r\nbuild ci 使用 [travis-ci](www.travis-ci.org/）\r\n\r\n\r\n测试覆盖率上传使用 codecov\r\n\r\n\r\n具体的其他细节大家可以看源码中的 package.json，这里就一一展开讲了，我们来看具体实现\r\n\r\n\r\n\r\n具体实现\r\n\r\n\r\n首先，我们来设计我们的事件中心，iny-bus 作为事件中心，我们就需要一个容器来储存我们的事件，同时我们不希望，使用者可以直接访我们的容器，所以我们就需要私有化,例如这样\r\n\r\n\r\n\r\n\r\n  class EventBus {\r\n\r\n    private events: any[] = []\r\n\r\n  }\r\n\r\n复制代码\r\n然后，我们的事件中心希望拥有那些能力呢，比如说事件监听 on，监听了就需要派发 emit, 也就需要移除 remove,移除就需要查找，我们也需要一次性事件，比如说 once，大概是这样子\r\n\r\n\r\n  interface EventBus {\r\n\r\n    // 监听，我们需要知道一个事件名字，也需要一个 派发时的执行函数，同时，我们返回一个\r\n    // id 给使用者，方便使用者移除 事件监听\r\n    on(name: string, execute: Function): string\r\n\r\n    // once 和 on在使用创建和使用时，没什么区别，唯一的区别就在 执行一次后移除，所以在\r\n    // 创建时 和 on 没有任何区别\r\n    once(name: string, execute: Function): string\r\n\r\n    // remove, 前面提到了我们需要删除事件监听，那我们就需要 事件名称，为了多个页面可以监\r\n    // 听同一个事件，所以我们不能一次性把该事件监听全部移除\r\n    // 那么我们就用到 创建 事件时的 id 了, 同时，我们返回 我们的事件中心，可以链式调用\r\n    remove(name: string, eventId?: string): EventBus\r\n\r\n    // emit 我们需要告诉系统，我们需要派发的事件名和所携带的参数，同时返回 事件实例\r\n    emit(name: string, ...args: any[]): EventBus\r\n\r\n    // find 函数返回一个联合类型，有可能存在 该事件，也有可能返回 null\r\n    find(name: string): Event | null\r\n\r\n  }\r\n\r\n复制代码\r\n上面我们大概设计好我们的事件中心了，这个时候，我们需要明确，我们的每一个事件所拥有的能力和属性\r\n\r\n\r\n  // 每一个东西，都有一个名字，方便记忆和寻找，我们的事件\r\n  // 也需要一个 name，同时，我们的每一个事件，都有可能被监听 n 次，那么我们就需要\r\n  // 每个事件来有一个容器，存放每个事件的执行者\r\n\r\n  interface Event {\r\n\r\n    // 名称\r\n    name: string\r\n\r\n    // 执行者容器\r\n    executes: Execute[]\r\n  }\r\n\r\n  // 我们也需要确定每个执行者的类型，为了能精确的找到执行者，所以需要一个 id，这也是 用来\r\n  // 删除的id， 这里的 eventType 是来标示是否是一次性执行者， execute 则为每个执行者\r\n  // 的执行函数\r\n  interface Execute {\r\n    id: string\r\n    eventType: EventType\r\n    execute: Function\r\n  }\r\n\r\n复制代码\r\n在上面，我们提到了 eventType，这是为了标示是否为 一次性执行者，在 typescript 中，没有比 枚举 更适合这种情况了\r\n\r\n\r\n// 申明事件执行者的类型\r\n\r\ntype EventType = 1 | 2\r\n\r\n\r\nenum EventTypeEnum {\r\n  // 普通事件\r\n  NORMAL_EVENT = 1,\r\n  // 一次性事件\r\n  ONCE_EVENT = 2\r\n}\r\n\r\n复制代码\r\n基本的类型是定义完了，我们来写具体实现的代码，第一步，实现 on once 方法\r\n\r\n\r\n  \r\n  class EventBus {\r\n\r\n    /**\r\n    * 储存事件的容器\r\n    */\r\n    private events: Event[] = []\r\n\r\n    /**\r\n    * on 新增事件监听\r\n    * @param name 事件名\r\n    * @param execute 回调函数\r\n    * @returns { string } eventId 事件ID，用户取消该事件监听\r\n    */\r\n\r\n\r\n    on(name: string, execute: Function): string {\r\n      \r\n      // 因为 on 和 once 在新建上没什么区别，所以这里我们统一使用 addEvent, 但为了区分 on 和 once，我们传入了 EventType\r\n      return this.addEvent(name, EventTypeEnum.NORMAL_EVENT, execute)\r\n    }\r\n\r\n    /**\r\n    * one 只允许添加一次事件监听\r\n    * @param name 事件名\r\n    * @param execute 回调函数\r\n    * @returns { string } eventId 事件ID，用户取消该事件监听\r\n    */\r\n\r\n    once(name: string, execute: Function): string {\r\n      // 同理 on\r\n      return this.addEvent(name, EventTypeEnum.ONCE_EVENT, execute)\r\n    }\r\n\r\n  }\r\n\r\n\r\n复制代码\r\n实现 addEvent 方法\r\n\r\n\r\n  class EventBus {\r\n\r\n    /**\r\n     * 添加事件的方法\r\n    * @param name\r\n    * @param execute\r\n    */\r\n\r\n    private addEvent(name: string, eventType: EventType, execute: Function): string {\r\n      const eventId = createUid()\r\n\r\n      const events = this.events\r\n\r\n      const event = this.find(name)\r\n\r\n      if (event !== null) {\r\n        event.executes.push({ id: eventId, eventType, execute })\r\n\r\n        return eventId\r\n      }\r\n\r\n      events.push({\r\n        name,\r\n        executes: [\r\n          {\r\n            id: eventId,\r\n            eventType,\r\n            execute\r\n          }\r\n        ]\r\n      })\r\n\r\n      return eventId\r\n    }\r\n\r\n  }\r\n\r\n复制代码\r\n实现 find 方法\r\n\r\n\r\n  class EventBus {\r\n    /**\r\n     * 查找事件的方法\r\n    * @param name\r\n    */\r\n\r\n    find(name: string): Event | null {\r\n      const events = this.events\r\n\r\n      for (let i = 0; i < events.length; i++) {\r\n        if (name === events[i].name) {\r\n          return events[i]\r\n        }\r\n      }\r\n\r\n      return null\r\n    }\r\n  }\r\n\r\n复制代码\r\n实现 remove 方法\r\n\r\n\r\n  class EventBus {\r\n    /**\r\n     * remove 移除事件监听\r\n    * @param name 事件名\r\n    * @param eventId 移除单个事件监听需传入\r\n    * @returns { EventBus } EventBus EventBus 实例\r\n    */\r\n\r\n    remove(name: string, eventId: string): EventBus {\r\n      const events = this.events\r\n\r\n      for (let i = 0; i < events.length; i++) {\r\n        if (events[i].name === name) {\r\n          // 移除具体的操作函数\r\n          if (eventId && events[i].executes.length > 0) {\r\n            const eventIndex = events[i].executes.findIndex(item => item.id === eventId)\r\n\r\n            if (eventIndex !== -1) {\r\n              events[i].executes.splice(eventIndex, 1)\r\n            }\r\n          } else {\r\n            events.splice(i, 1)\r\n          }\r\n\r\n          return this\r\n        }\r\n      }\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n复制代码\r\n实现 emit 方法\r\n\r\n\r\n  class EventBus {\r\n    /**\r\n     * emit 派发事件\r\n    * @param name 事件名\r\n    * @param args 其余参数\r\n    * @returns { EventBus } EventBus EventBus 实例\r\n    */\r\n\r\n    emit(name: string, ...args: any[]): EventBus {\r\n      const events = this.events\r\n\r\n      for (let i = 0; i < events.length; i++) {\r\n        if (name === events[i].name) {\r\n          const funcs = events[i].executes\r\n\r\n          funcs.forEach((item, i) => {\r\n            item.execute(...args)\r\n\r\n            if (item.eventType === EventTypeEnum.ONCE_EVENT) {\r\n              funcs.splice(i, 1)\r\n            }\r\n          })\r\n\r\n          return this\r\n        }\r\n      }\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n复制代码\r\n作为一个事件中心，为了避免使用者错误使用，创建多个实例，我们可以使用 工厂模式，创建一个全局实例供使用者使用，同时提供使用者一个方法，创建新的实例\r\n\r\n\r\n  // 不直接 new EventBus， 而是通过 一个工厂函数来创建实例, 参考 axios 源码\r\n  function createInstance (): EventBusInstance {\r\n\r\n    const bus = new EventBus()\r\n\r\n    return bus as EventBusInstance\r\n  }\r\n\r\n  const bus = createInstance()\r\n\r\n  // 扩展 create 方法，用于 使用者 创建新的 bus 实例\r\n  bus.create = function create () {\r\n    return createInstance()\r\n  }\r\n复制代码总结\r\niny-bus 的核心代码，其实就这么多，总的来说，非常少，但是能解决我们在小程序中遇到的大量 通信 和 数据刷新问题，是采用 各大平台小程序 原生开发时，页面通信的不二之选，同时，100% 的测试覆盖率，确保了 iny-bus 在使用中的稳定性和安全性，当然，每个库都是从简单走向复杂，功能慢慢完善，如果\r\n大家在使用或者源码中发现了bug或者可以优化的点，欢迎大家提 pr 或者直接联系我\r\n最后，如果 iny-bus 给你提供了帮助或者让你有任何收获，请给 作者 点个赞，感谢大家 点赞"}
{"title": "小程序在线答题系统设计 ", "author": "Rolan", "pub_time": "2019-8-6 00:58", "content": "前言帮一个可爱的小姐姐改一个uni-app构建的微信小程序时，在使用textarea组件时遇到的一点小问题。描述问题：在uni-app中,<textarea>的auto-hetght属性会出现高度不够，文字能够上下移动的问题,具体见下图:当输入的文字过多时,textarea内的文字可以上下滚动。 这不属于产品的需求，产品要的是输入框高度随着文字的变化而变化不能出现滚动条，而在uni-app打包的微信小程序中却出现了滚动解决思路排查原生微信小程序中是否有该问题 在微信小程序原生语法中尝试使用该组件：    <textarea placeholder=\"sxx是猪\" class=\"textarea\" auto-height=\"true\"></textarea>\r\nHTML.textarea{\r\n  margin-top: 80rpx;\r\n  width: 80vw;\r\n  border: 1rpx solid red;\r\n  min-height: 100rpx;\r\n  font-size: 20px\r\n}\r\nCSS发现在原生微信小程序语法中,使用auto-height属性，输入框高度会随着文字的增加而增加。在uni-app中新建项目，打包编译至微信小程序开发工具查看效果<textarea auto-height=\"true\" placeholder=\"sxx是猪\" class=\"textarea\"></textarea>\r\nHTML.textarea {\r\n        margin-top: 80upx;\r\n        width: 80vw;\r\n        border: 1rpx solid red;\r\n        min-height: 100upx;\r\n        font-size: 20px\r\n    }\r\nCSS跟在微信原生语法中写的一模一样，却产生了不同的效果。说明是uni-app编译的小程序会出现这个bug进一步排查，查看小程序工具中调试工具Wxml下的Dom以及style初始没有输入文本的时候，微信小程序的textarea有一个height:22.5px的行内样式而在uni-app(以下简称uni-app)编译的小程序下面，初始的高度只有17px输入一段相同的文本之后进行比较：sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪微信小程序uni-app输入相同的内容，微信小程序高度为73px,uni-app高度也为73px,但是uni-app文本的字体高度却大于微信小程序的文本行高，所以会出现滚动尝试修改uni-app的行高.textarea {\r\n        margin-top: 80upx;\r\n        width: 80vw;\r\n        border: 1rpx solid red;\r\n        min-height: 100upx;\r\n        font-size: 20px;\r\n        line-height: 20px;\r\n    }\r\nCSS运行之后，解决问题！！原理观察得知，微信小程序中由于输入框中文字比较紧凑，uni-app中文字比较稀疏。故猜测可能是行高将文字的整体高度撑起，大于了输入框的可视区域。所uni-app中出现了滚动的效果。所以，修改uni-app的输入框中文本的行高即可解决该问题。关于文章首发于:uni-app textarea auto-hetght 文字出现上下滚动本文采用 CC BY-NC-SA 3.0 Unported 协议进行许可本文链接： https://www.ahwgs.cn/uni-app-textarea-auto-hetght.html"}
{"title": "微信小程序七夕节礼物 ", "author": "Rolan", "pub_time": "2019-8-7 00:09", "content": "VSCode Node.js HbuilderX安装前端开发环境npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g lessHBuilderX是国内最优秀的前端开发工具，我们用它来开发Electron项目和小程序项目{  \"pages\": [    \"pages/index/index\"  ],  \"requiredBackgroundModes\": [    \"audio\",    \"location\"  ],  \"subPackages\": [],  \"window\": {    \"navigationBarTextStyle\": \"black\",    \"navigationBarTitleText\": \"我喜欢你\",    \"navigationBarBackgroundColor\": \"#F8F8F8\",    \"backgroundColor\": \"#F8F8F8\"  },  \"usingComponents\": {}}@import './common/main.wxss';require('./common/runtime.js')require('./common/vendor.js')require('./common/main.js').content {  padding: 0 40rpx;}.content image {  width: 100%;}.content .title {  display: block;  text-align: center;  font-size: 50rpx;  font-weight: bold;}.content .operate {  text-align: center;  margin-top: 30rpx;  margin-bottom: 30rpx;}.content .operate .btn {  width: 200rpx;  height: 80rpx;  display: inline-block;}.content .operate .btn:first-of-type {  margin-right: 40rpx;}.content .message {  font-size: 34rpx;  margin: 15rpx 0;  color: #333;}<view class=\"content\"><image src=\"../../static/g1.gif\" mode=\"widthFix\"></image><text class=\"title\">小姐姐，做我女朋友吧！</text><view class=\"operate\"><button class=\"btn\" type=\"primary\" data-event-opts=\"{{[['tap',[['agree',['$event']]]]]}}\" bindtap=\"__e\">好呀</button><button class=\"btn\" type=\"warn\" data-event-opts=\"{{[['tap',[['disagree',['$event']]]]]}}\" bindtap=\"__e\">不好</button></view><block wx:for=\"{{love}}\" wx:for-item=\"one\" wx:for-index=\"__i0__\" wx:key=\"*this\"><view class=\"message\">{{one}}</view></block></view>若本号内容有做得不到位的地方（比如：涉及版权或其他问题），请及时联系我们进行整改即可，会在第一时间进行处理。"}
